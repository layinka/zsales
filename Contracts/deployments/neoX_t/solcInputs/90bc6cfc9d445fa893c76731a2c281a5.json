{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev A clone instance deployment failed.\n     */\n    error ERC1167FailedCreateClone();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC1155/IERC1155.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (token/ERC1155/IERC1155.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC1155 compliant contract, as defined in the\n * https://eips.ethereum.org/EIPS/eip-1155[EIP].\n */\ninterface IERC1155 is IERC165 {\n    /**\n     * @dev Emitted when `value` amount of tokens of type `id` are transferred from `from` to `to` by `operator`.\n     */\n    event TransferSingle(address indexed operator, address indexed from, address indexed to, uint256 id, uint256 value);\n\n    /**\n     * @dev Equivalent to multiple {TransferSingle} events, where `operator`, `from` and `to` are the same for all\n     * transfers.\n     */\n    event TransferBatch(\n        address indexed operator,\n        address indexed from,\n        address indexed to,\n        uint256[] ids,\n        uint256[] values\n    );\n\n    /**\n     * @dev Emitted when `account` grants or revokes permission to `operator` to transfer their tokens, according to\n     * `approved`.\n     */\n    event ApprovalForAll(address indexed account, address indexed operator, bool approved);\n\n    /**\n     * @dev Emitted when the URI for token type `id` changes to `value`, if it is a non-programmatic URI.\n     *\n     * If an {URI} event was emitted for `id`, the standard\n     * https://eips.ethereum.org/EIPS/eip-1155#metadata-extensions[guarantees] that `value` will equal the value\n     * returned by {IERC1155MetadataURI-uri}.\n     */\n    event URI(string value, uint256 indexed id);\n\n    /**\n     * @dev Returns the value of tokens of token type `id` owned by `account`.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function balanceOf(address account, uint256 id) external view returns (uint256);\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {balanceOf}.\n     *\n     * Requirements:\n     *\n     * - `accounts` and `ids` must have the same length.\n     */\n    function balanceOfBatch(\n        address[] calldata accounts,\n        uint256[] calldata ids\n    ) external view returns (uint256[] memory);\n\n    /**\n     * @dev Grants or revokes permission to `operator` to transfer the caller's tokens, according to `approved`,\n     *\n     * Emits an {ApprovalForAll} event.\n     *\n     * Requirements:\n     *\n     * - `operator` cannot be the caller.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns true if `operator` is approved to transfer ``account``'s tokens.\n     *\n     * See {setApprovalForAll}.\n     */\n    function isApprovedForAll(address account, address operator) external view returns (bool);\n\n    /**\n     * @dev Transfers a `value` amount of tokens of type `id` from `from` to `to`.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155Received} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits a {TransferSingle} event.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - If the caller is not `from`, it must have been approved to spend ``from``'s tokens via {setApprovalForAll}.\n     * - `from` must have a balance of tokens of type `id` of at least `value` amount.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155Received} and return the\n     * acceptance magic value.\n     */\n    function safeTransferFrom(address from, address to, uint256 id, uint256 value, bytes calldata data) external;\n\n    /**\n     * @dev xref:ROOT:erc1155.adoc#batch-operations[Batched] version of {safeTransferFrom}.\n     *\n     * WARNING: This function can potentially allow a reentrancy attack when transferring tokens\n     * to an untrusted contract, when invoking {onERC1155BatchReceived} on the receiver.\n     * Ensure to follow the checks-effects-interactions pattern and consider employing\n     * reentrancy guards when interacting with untrusted contracts.\n     *\n     * Emits either a {TransferSingle} or a {TransferBatch} event, depending on the length of the array arguments.\n     *\n     * Requirements:\n     *\n     * - `ids` and `values` must have the same length.\n     * - If `to` refers to a smart contract, it must implement {IERC1155Receiver-onERC1155BatchReceived} and return the\n     * acceptance magic value.\n     */\n    function safeBatchTransferFrom(\n        address from,\n        address to,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentKey(bytes32 key);\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 key => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        if (value == 0 && !contains(map, key)) {\n            revert EnumerableMapNonexistentKey(key);\n        }\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/Campaign.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\n// import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\n// import \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport './Lockers/DexLockerFactory.sol';\r\nimport {IDexLocker} from './Lockers/DexLocker.sol';\r\n// import './Lockers/TokenLocker.sol';\r\nimport \"./Lockers/VestSchedule.sol\";\r\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\r\nimport \"hardhat/console.sol\";\r\nimport {IDexRouter, IDexFactory} from \"./IDexRouter.sol\";\r\nimport {ICampaignList} from \"./CampaignList.sol\";\r\nimport \"./Errors.sol\";\r\n\r\nstruct PlatFormDetails{\r\n  address admin; //zsales admin - can setkyc and audited\r\n  address zsalesTokenAddress;\r\n  uint zsaleFee;  //2%   - percent of native currency to take\r\n  uint zsaleTokenFee;  //2% - percent fee of token to take\r\n  address zsalesWalletAddress ; // receives commissions    \r\n  address zsalesNFTTokenAddress;\r\n  uint maxTiersToCheckForNFT;\r\n}\r\n\r\ncontract Campaign is Initializable,Ownable, ReentrancyGuard {\r\n  using SafeERC20 for IERC20;\r\n  error InsufficientBalance();\r\n  error NoSendValue();\r\n\r\n  uint256 constant private MAX_INT = 2**256 - 1;\r\n\r\n  event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);\r\n  event ValueReceived(address user, uint amount);\r\n  event Withdrawn(address user, uint amount);\r\n  event Refunded(address user, uint amount);\r\n  event SoldOut();\r\n  event LiquidityAddedToRouter(address indexed router, address indexed token1,address indexed token2, uint amountToken1, uint amountToken2);\r\n\r\n  struct CampaignSaleInfo {\r\n      //token attributes\r\n      address   tokenAddress; \r\n      uint256  softCap; // Soft cap in coin\r\n      uint256  hardCap; // Max cap in coin\r\n      uint256  saleStartTime; // start sale time\r\n      uint256  saleEndTime; // end sale time\r\n      uint   liquidityPercent; // multiplied by 100 e.g 45% is 4500\r\n      uint   listRate; \r\n      uint   dexListRate;\r\n      // RefundType  refundType;\r\n      string logoUrl;\r\n      string desc;\r\n      string website;\r\n      string twitter;\r\n      string telegram;\r\n      string discord;\r\n      uint tokensOnSale;\r\n      // string bannerImage;\r\n      \r\n  }\r\n\r\n  enum CampaignStatus{ \r\n    CREATED,\r\n    TOKENS_SUBMITTED,//Owner has transferred the correct no of tokens and campaign is ready to receive\r\n    CANCELLED, // Cancelled before the start date\r\n    \r\n    FAILED, // WIll need refund\r\n    LIQUIDITY_SETUP\r\n\r\n  }\r\n\r\n  bool   public useWhiteList;//Use in only Tier 2\r\n  bool   public hasKYC;\r\n  uint public totalTeamTokensToBeVested=0;\r\n  bool _isAudited; \r\n  string public auditUrl;\r\n  CampaignStatus public  status = CampaignStatus.CREATED;\r\n\r\n  address public liquidityPairAddress;\r\n  address public liquidityPairLockerAddress;\r\n  uint256 public liquidityReleaseInDays; // days to release Lp tokens to owner\r\n  \r\n  \r\n  \r\n  CampaignSaleInfo public  saleInfo;\r\n  \r\n  \r\n  address public dexRouterAddress;\r\n  uint256 public totalCoinReceived; // total  received\r\n  uint256 public totalCoinInTierZero;\r\n  uint256 public totalCoinInTierOne; // total coin for tier one\r\n  uint256 public totalCoinInTierTwo; // total coin for tier Tier\r\n\r\n  address public purchaseTokenAddress=address(0); // Token address for Purchases for this campaign - address 0 is native currency\r\n  \r\n\r\n  uint public totalParticipants; // total participants in ido\r\n  \r\n\r\n  PlatFormDetails zsalesPlatformDetails;\r\n  \r\n  address public _campaignFactoryAddress ;\r\n\r\n  uint private tier1TimeLineInHours = 2; // e.g 2 hours before startime\r\n  uint private tier0TimeLineInHours = 3;\r\n\r\n  bool private ownerHasWithdrawnTokens=false;\r\n  \r\n  // max cap per tier\r\n  uint public tierZerohardCap;\r\n  uint public tierOnehardCap;\r\n  uint public tierTwohardCap;\r\n    \r\n  //total users per tier\r\n  // uint public totalUserInTierZero;\r\n  // uint public totalUserInTierOne;\r\n  // uint public totalUserInTierTwo;\r\n  \r\n  bool public useTokenVesting;\r\n  bool public useRaisedFundsVesting;\r\n\r\n\r\n  //Tier 0 - holders of our NFT\r\n  //Tier 1 - holders of our coin\r\n  //Tier 2 - Whitelisted or public   \r\n  uint public minAllocationPerUser;\r\n  //max allocations per user in a tier\r\n  uint public maxAllocationPerUserTierZero;\r\n  uint public maxAllocationPerUserTierOne;\r\n  uint public maxAllocationPerUserTierTwo; \r\n  \r\n  bytes32 private _whitelistTierTwoMerkleRoot;\r\n  \r\n\r\n  uint public campaignKey;\r\n  // enum RefundType{ BURN, REFUND }\r\n  \r\n  \r\n\r\n  //mapping the user purchase per tier\r\n  mapping(address => uint) public buyInZeroTier;\r\n  mapping(address => uint) public buyInOneTier;\r\n  mapping(address => uint) public buyInTwoTier;\r\n  mapping(address => uint) public buyInAllTiers;\r\n  DexLockerFactory private _dexLockerFactory;\r\n  \r\n  IDexLocker public _dexLocker;\r\n  uint private tokenDecimals;\r\n  uint private purchaseCoinDecimals;\r\n  \r\n\r\n  ///Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be taken over by an attacker, which may impact the proxy. \r\n  /// To prevent the implementation contract from being used, you should invoke the _disableInitializers function in the constructor to automatically lock it when it is deployed\r\n  /// @custom:oz-upgrades-unsafe-allow constructor\r\n  constructor() Ownable(msg.sender) {\r\n      _disableInitializers();\r\n  }\r\n\r\n  function initialize(\r\n    \r\n    /** address campaignOwner,\r\n    /* address campaignFactory,\r\n    /* address  _saletokenAddress, */\r\n    /* address  _purchaseTokenAddress, */\r\n    address[4] memory addresses,\r\n\r\n    uint tokensOnSale,\r\n\r\n    /** uint256 _normalizedTo18DecimalsSoftCap,\r\n     * uint256 __normalizedTo18DecimalsHardCap,\r\n     * uint256 _saleStartTime,\r\n     * uint256 _saleEndTime, \r\n     * uint256 _nomrlaizedTierOneHardCap, \r\n     * uint256 _nomrlaizedTierTwoHardCap,\r\n     * uint _minAllocationPerUser, \r\n     * uint256 _maxAllocationPerUserTierOne, \r\n     * uint256 _maxAllocationPerUserTierTwo ,\r\n     * uint _campaignKey,*/\r\n    uint256[10] memory capAndDate,  \r\n    \r\n    // RefundType _refundType, \r\n    address _dexRouterAddress,\r\n\r\n    /**uint _liquidityPercent, \r\n    /* uint liquidityReleaseTime,\r\n    /* uint _listRate, \r\n    /* uint _dexListRate,**/\r\n    uint[4] memory liquidityAllocationAndRates,\r\n\r\n    /**uint totalTeamTokensToBeVested, \r\n    /* uint firstReleasePercent,  \r\n    /* uint firstReleaseDays,\r\n    /* uint subsequentReleasePercent, \r\n    /* uint subsequentReleaseDays,,**/\r\n    uint256[5] memory teamTokenVestingDetails,\r\n\r\n    /**uint percentToLockx100, \r\n    /* uint firstReleaseDays,  \r\n    /* uint percentToReleaseEachTime**/\r\n    uint256[3] memory raisedFundVestingDetails,\r\n    \r\n    // UseTeamTokenVesting,\r\n    // UseRaisedFundVesting\r\n    bool[2] memory _useTokenOrRaisedFundVesting,\r\n    // VestSchedule[8] memory teamTokenVestingDetails, \r\n\r\n    \r\n    string[6] memory founderInfo,\r\n    DexLockerFactory dexLockerFactory \r\n  ) public payable initializer {\r\n\r\n    {\r\n      // require(capAndDate[3] > capAndDate[2], \"Sale End time needs to be above start time\");\r\n      // require(liquidityAllocationAndRates[0] >= 5100, \"Liquidity allowed is > 51 %\");\r\n      if (capAndDate[3] <= capAndDate[2]) revert SaleEndTimeBeforeStartTime();\r\n      if (liquidityAllocationAndRates[0] < 5100) revert LiquidityAboveLimit(5100);\r\n\r\n      _campaignFactoryAddress= addresses[1];\r\n      _setDefaultValues();\r\n      campaignKey=capAndDate[9];\r\n      \r\n      _dexLockerFactory=dexLockerFactory;\r\n      purchaseTokenAddress=addresses[3]; \r\n    }\r\n    \r\n      \r\n    // //block scopin to avoid stack too deep \r\n    {\r\n      \r\n      saleInfo = CampaignSaleInfo({\r\n        tokenAddress: addresses[2],\r\n        softCap: capAndDate[0],\r\n        hardCap: capAndDate[1],\r\n        saleStartTime: capAndDate[2], \r\n        saleEndTime: capAndDate[3],   \r\n        liquidityPercent: liquidityAllocationAndRates[0],\r\n        listRate: liquidityAllocationAndRates[2],\r\n        dexListRate: liquidityAllocationAndRates[3],\r\n        // refundType: _refundType, \r\n        logoUrl: founderInfo[0],\r\n        desc: founderInfo[1],\r\n        website: founderInfo[2],\r\n        twitter: founderInfo[3],\r\n        telegram: founderInfo[4],\r\n        discord: founderInfo[5],\r\n        tokensOnSale: tokensOnSale\r\n      });\r\n\r\n      dexRouterAddress=_dexRouterAddress; \r\n    }        \r\n    \r\n    \r\n    \r\n    { \r\n          // _updateTierDetails(capAndDate[4], capAndDate[5], capAndDate[6],capAndDate[7], capAndDate[8]);\r\n      _updateTierDetails(capAndDate);\r\n    \r\n\r\n      _transferOwnership(addresses[0]);\r\n      \r\n\r\n      _updateLockDetails(liquidityAllocationAndRates[1], _useTokenOrRaisedFundVesting[0], teamTokenVestingDetails,_useTokenOrRaisedFundVesting[1], raisedFundVestingDetails );\r\n    }\r\n    \r\n  }\r\n\r\n  //needed since initializable contracts do not have constructors\r\n  function _setDefaultValues() private {\r\n    //status = CampaignStatus.CREATED;\r\n    tier0TimeLineInHours = 3; // e.g 3 hours before startime\r\n    tier1TimeLineInHours = 2; // e.g 2 hours before startime\r\n\r\n    \r\n    ICampaignList cList = ICampaignList(_campaignFactoryAddress);\r\n    zsalesPlatformDetails= PlatFormDetails({\r\n      admin: cList.zsalesAdmin(), //zsales admin - can setkyc and audited\r\n      zsalesTokenAddress : cList.zsalesTokenAddress(),\r\n      zsaleFee : cList.zsaleFee(),  //2%   - percent of native currency to take\r\n      zsaleTokenFee : cList.zsaleTokenFee(),  //2% - percent fee of token to take\r\n      zsalesWalletAddress : cList.zsalesWalletAddress(), // receives commissions      \r\n      zsalesNFTTokenAddress: cList.zsalesNFTTokenAddress(),\r\n      maxTiersToCheckForNFT: cList.maxTiersToCheckForNFT()\r\n    });\r\n    // _admin= cList.zsalesAdmin(); //zsales admin - can setkyc and audited\r\n    // zsalesTokenAddress = cList.zsalesTokenAddress();\r\n    // zsaleFee = cList.zsaleFee();  //2%   - percent of native currency to take\r\n    // zsaleTokenFee = cList.zsaleTokenFee();  //2% - percent fee of token to take\r\n    // zsalesWalletAddress = cList.zsalesWalletAddress() ; // receives commissions\r\n    \r\n    // zsalesNFTTokenAddress= cList.zsalesNFTTokenAddress();\r\n  }\r\n  \r\n  // function to update other details not initialized in constructor - this is bcos solidity limits how many variables u can pass in at once\r\n  function _updateLockDetails(\r\n    uint liquidityReleaseTimeDays, //Time to add to startTime in days\r\n    bool _useTokenVesting,\r\n    uint256[5] memory teamTokenVestingDetails,\r\n    bool _useRaisedFundsVesting, \r\n    uint256[3] memory raisedFundVestingDetails\r\n      \r\n  ) private /*public onlyOwner*/ {\r\n    liquidityReleaseInDays  = liquidityReleaseTimeDays;\r\n    useTokenVesting=_useTokenVesting;\r\n    useRaisedFundsVesting=_useRaisedFundsVesting;\r\n\r\n    \r\n    //Set dexLock\r\n    _dexLocker = IDexLocker(payable(_dexLockerFactory.createDexLocker(dexRouterAddress,saleInfo.tokenAddress, purchaseTokenAddress, address(this), msg.sender) ) );\r\n    \r\n    \r\n    _dexLocker.setupLock([saleInfo.softCap,saleInfo.hardCap],  [saleInfo.listRate,  saleInfo.dexListRate],useTokenVesting, teamTokenVestingDetails, _useRaisedFundsVesting,  raisedFundVestingDetails);\r\n    \r\n    status = CampaignStatus.CREATED;\r\n    totalTeamTokensToBeVested = teamTokenVestingDetails[0];\r\n\r\n  }\r\n  \r\n  function _updateCampaignFounderDetails(\r\n    string memory logoUrl,\r\n    string memory desc,\r\n    string memory website,\r\n    string memory twitter,\r\n    string memory telegram,\r\n    string memory discord\r\n  ) private {\r\n    saleInfo.logoUrl= logoUrl;\r\n    saleInfo.desc= desc;\r\n    saleInfo.website= website;\r\n    saleInfo.twitter= twitter;\r\n    saleInfo.telegram= telegram;\r\n    saleInfo.discord= discord;\r\n  }\r\n\r\n  function updateCampaignFounderDetails(\r\n    string memory logoUrl,\r\n    string memory desc,\r\n    string memory website,\r\n    string memory twitter,\r\n    string memory telegram,\r\n    string memory discord\r\n  ) external onlyOwner {       \r\n    if (block.timestamp > saleInfo.saleStartTime) revert UpdateAfterSaleStartTime();\r\n    _updateCampaignFounderDetails(logoUrl,desc,website,twitter,telegram,discord);\r\n  }\r\n\r\n  function _updateTierDetails(uint256[10] memory capAndDate) private {\r\n    \r\n    _updateTierDetails(capAndDate[4], capAndDate[5], capAndDate[6],capAndDate[7], capAndDate[8]);\r\n  }\r\n    \r\n  // function to update the tiers users value manually\r\n  function _updateTierDetails(uint256 _tierOneHardCap, uint256 _tierTwoHardCap, uint256 _minAllocationPerUser, uint256 _maxAllocationPerUserTierOne, uint256 _maxAllocationPerUserTierTwo) private {\r\n    \r\n    tokenDecimals = IERC20Metadata(saleInfo.tokenAddress).decimals();\r\n    purchaseCoinDecimals=18;\r\n    if(purchaseTokenAddress!=address(0)){\r\n      purchaseCoinDecimals = IERC20Metadata(purchaseTokenAddress).decimals();\r\n    }\r\n    \r\n    if (_tierOneHardCap < saleInfo.hardCap * 2500 / 10000) revert TierCapTooLow(25);\r\n    // if (_tierOneHardCap + _tierTwoHardCap != saleInfo.hardCap) revert TierCapsExceedHardCap();\r\n    if (_tierOneHardCap > saleInfo.hardCap) revert TierOneCapExceedsHardCap();\r\n    if (_tierTwoHardCap > saleInfo.hardCap) revert TierTwoCapExceedsHardCap();\r\n\r\n    if (_minAllocationPerUser < 0) revert MinAllocationOutOfRange();\r\n    if (_maxAllocationPerUserTierOne <= 0) revert TierOneMaxAllocationOutOfRange();\r\n    if (_maxAllocationPerUserTierTwo <= 0) revert TierTwoMaxAllocationOutOfRange();\r\n    \r\n    \r\n    tierZerohardCap = _tierOneHardCap;\r\n    tierOnehardCap =_tierOneHardCap;\r\n    tierTwohardCap = _tierTwoHardCap;    \r\n    \r\n    minAllocationPerUser=_minAllocationPerUser; \r\n    maxAllocationPerUserTierZero = _maxAllocationPerUserTierOne;//same alloc for tier 0 and 1\r\n    maxAllocationPerUserTierOne = _maxAllocationPerUserTierOne;\r\n    maxAllocationPerUserTierTwo = _maxAllocationPerUserTierTwo;\r\n  }\r\n\r\n  function updateTierDetails(uint256 _tierOneHardCap, uint256 _tierTwoHardCap, uint256 _minAllocationPerUser, uint256 _maxAllocationPerUserTierOne, uint256 _maxAllocationPerUserTierTwo) public onlyOwner {\r\n    \r\n    if(block.timestamp > saleInfo.saleStartTime){\r\n      revert UpdateAfterSaleStartTime();\r\n    }\r\n    _updateTierDetails(_tierOneHardCap, _tierTwoHardCap, _minAllocationPerUser, _maxAllocationPerUserTierOne, _maxAllocationPerUserTierTwo);    \r\n  }\r\n\r\n  function _startReceivingBids() private \r\n  {    \r\n    status = CampaignStatus.TOKENS_SUBMITTED;\r\n  }\r\n\r\n  function startReceivingBids() public {\r\n    if (_campaignFactoryAddress != _msgSender()) revert NotOwner();\r\n    _startReceivingBids();\r\n  }\r\n\r\n  function cancelCampaign() public onlyOwner {\r\n      if (block.timestamp >= saleInfo.saleStartTime) revert CannotCancelAfterSaleStartTime();\r\n      status = CampaignStatus.CANCELLED;\r\n  }\r\n\r\n  \r\n  function postponeSale(uint newDate, uint newEndDate) public onlyOwner {\r\n      if (block.timestamp >= saleInfo.saleStartTime) revert PostponeBeforeSaleStartTime();\r\n      if (newDate <= saleInfo.saleStartTime) revert NewDateLessThanOldDate();\r\n      if (newEndDate <= newDate) revert EndDateLessThanStartTime();\r\n\r\n      saleInfo.saleStartTime = newDate;\r\n      saleInfo.saleEndTime = newEndDate;\r\n  }\r\n\r\n  function getDexListRate() public view returns (uint256) {\r\n    return saleInfo.dexListRate;\r\n  }\r\n\r\n  function getEndDate() public view returns (uint256) {\r\n    return saleInfo.saleEndTime;\r\n  }\r\n\r\n  // function totalTokensExpectedToBeLocked() public view returns (uint256) {\r\n  //   //Amount for sale + amount for liquidity\r\n  //   uint tokensForLiquidity = (saleInfo.dexListRate * saleInfo.liquidityPercent * saleInfo.hardCap)  / 10000;\r\n  //   return tokensForLiquidity + _dexLocker.totalTokensExpectedToBeLocked();\r\n  // }\r\n\r\n \r\n  function setZSalesTokenAddress(address _tokenAddress) public onlyAdmin {\r\n    zsalesPlatformDetails.zsalesTokenAddress = _tokenAddress;\r\n  }\r\n\r\n\r\n  /**************************|\r\n  |          Tier Info       |\r\n  |_________________________*/\r\n  //add the address in Whitelist tier two to invest\r\n  function disableTier2Whitelist() public onlyOwner {    \r\n    useWhiteList= false;\r\n  }\r\n\r\n  //add the address in Whitelist tier two to invest\r\n  function submitTier2Whitelist(bytes32 whitelistMerkleRoot) public onlyOwner {\r\n    \r\n    if (block.timestamp >= saleInfo.saleStartTime) revert AlterWhitelistingAfterSaleStartTime();\r\n    useWhiteList= true;\r\n    _whitelistTierTwoMerkleRoot=whitelistMerkleRoot;\r\n  }\r\n\r\n  // check the address is a Token Holder\r\n  function isAllowedInTier1(address _address) public view returns(bool) {\r\n\r\n    IERC20 token = IERC20(zsalesPlatformDetails.zsalesTokenAddress);\r\n    return token.balanceOf(_address) > 0;\r\n  }\r\n\r\n  // check the address is a NFT Token Holder\r\n  function isAllowedInTier0(address _address) public view returns(bool) {\r\n    \r\n    IERC1155 token = IERC1155(zsalesPlatformDetails.zsalesNFTTokenAddress);\r\n    address[] memory addresses=new address[](zsalesPlatformDetails.maxTiersToCheckForNFT);\r\n    addresses[0]=_address;\r\n\r\n    uint[] memory tokenIds=new uint[](zsalesPlatformDetails.maxTiersToCheckForNFT);\r\n    \r\n    for (uint256 i = 0; i < zsalesPlatformDetails.maxTiersToCheckForNFT; i++) {\r\n        tokenIds[i]=i;\r\n    }\r\n\r\n    uint[] memory balances = token.balanceOfBatch(addresses,tokenIds) ;\r\n    uint balance = 0;\r\n    for (uint256 i = 0; i < zsalesPlatformDetails.maxTiersToCheckForNFT; i++) {\r\n        balance += balances[i];\r\n    }\r\n    return balance>0;\r\n  }\r\n\r\n\r\n  // check the address in whitelist tier two\r\n  function isInTier2WhiteList(bytes32[] memory proof, address claimer) public view returns(bool) {\r\n    \r\n    bytes32 _leaf = keccak256(abi.encodePacked(claimer));\r\n    return MerkleProof.verify(proof, _whitelistTierTwoMerkleRoot, _leaf);\r\n    \r\n  }\r\n\r\n  /**\r\n    * @dev Throws if called by any account other than the owner.\r\n  */\r\n  modifier onlyAdmin() {\r\n      require(zsalesPlatformDetails.admin == _msgSender(), NotAdmin() );\r\n      _;\r\n  }\r\n\r\n  function changeAdmin(address newAdmin) public onlyAdmin  {\r\n      // require(_msgSender() == _admin, 'ADMIN: Only Admin can change');\r\n      if(_msgSender() != zsalesPlatformDetails.admin) revert NotAdmin();\r\n      address oldOwner = zsalesPlatformDetails.admin;\r\n      zsalesPlatformDetails.admin=newAdmin;\r\n\r\n      emit AdminOwnershipTransferred(oldOwner, newAdmin);\r\n  }\r\n\r\n  \r\n  function getHardCap() public view returns (uint) {\r\n    return saleInfo.hardCap;\r\n  }\r\n\r\n  /**************************|\r\n  |          Setters         |\r\n  |_________________________*/\r\n  \r\n  function setKYC(bool kyc) public onlyAdmin {\r\n    if (block.timestamp >= saleInfo.saleStartTime) revert KYCAfterSaleStartTime();\r\n    hasKYC = kyc;\r\n  } \r\n\r\n  function setAudited(bool audit) public onlyAdmin {\r\n      if (block.timestamp >= saleInfo.saleStartTime) revert AuditAfterSaleStartTime();\r\n      _isAudited = audit;\r\n  }\r\n  function setTier1TimeLineInHours (uint newValue) public onlyAdmin {\r\n    tier1TimeLineInHours=newValue;\r\n  }\r\n  function isAudited() public view returns (bool, string memory ) {\r\n    return (_isAudited, auditUrl);\r\n  }\r\n\r\n\r\n  /**\r\n    * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n    * `recipient`, forwarding all available gas and reverting on errors.\r\n    *\r\n    * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n    * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n    * imposed by `transfer`, making them unable to receive funds via\r\n    * `transfer`. {sendValue} removes this limitation.\r\n    *\r\n    * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n    *\r\n    * IMPORTANT: because control is transferred to `recipient`, care must be\r\n    * taken to not create reentrancy vulnerabilities. Consider using\r\n    * {ReentrancyGuard} or the\r\n    * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n    */\r\n  function sendValue(address recipient, uint256 amount) internal {\r\n      require(address(this).balance >= amount, InsufficientBalance());\r\n\r\n      // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n      (bool success, ) = recipient.call{ value: amount }(\"\");\r\n      require(success, NoSendValue());//Address: unable to send value, recipient may have reverted\r\n  }\r\n  \r\n  \r\n  // send coin to the contract address\r\n  function submitBid(bytes32[] calldata proof, uint256 purchasedAmount) public payable nonReentrant  {\r\n    \r\n    uint256 normalizedBid ;\r\n    if(purchaseTokenAddress==address(0)){\r\n      normalizedBid= msg.value;\r\n    }else{\r\n      normalizedBid= purchasedAmount * 10**(18-purchaseCoinDecimals);//normalize\r\n      IERC20(purchaseTokenAddress).safeTransferFrom(msg.sender, address(this), purchasedAmount);\r\n    }\r\n    \r\n    \r\n    if (status == CampaignStatus.CANCELLED || status == CampaignStatus.FAILED) revert CampaignFailedOrCancelled();\r\n    if (status != CampaignStatus.TOKENS_SUBMITTED) revert NotTokenSubmitted();\r\n    if (totalCoinReceived >= saleInfo.hardCap) revert SoldOutError();\r\n    if (block.timestamp > saleInfo.saleEndTime) revert ClosedSale();\r\n    if (totalCoinReceived + normalizedBid > saleInfo.hardCap) revert ExceedMaxCap();\r\n    if (normalizedBid < minAllocationPerUser) revert LessThanMinBuy();\r\n    \r\n          \r\n    address sender = _msgSender();\r\n\r\n    if (block.timestamp >= saleInfo.saleStartTime) {\r\n        if (useWhiteList) {\r\n            if (!isInTier2WhiteList(proof, sender)) revert NotInTier2Whitelist();\r\n        }\r\n        if (totalCoinInTierTwo + normalizedBid > tierTwohardCap) revert ExceedTierTwoMaxCap();\r\n        if (buyInTwoTier[sender] + normalizedBid > maxAllocationPerUserTierTwo) revert ExceedTierTwoUserLimit();\r\n        buyInTwoTier[sender] += normalizedBid;\r\n        buyInAllTiers[sender] += normalizedBid;\r\n        totalCoinReceived += normalizedBid;\r\n        totalCoinInTierTwo += normalizedBid;\r\n        totalParticipants++;\r\n\r\n        emit ValueReceived(sender, purchasedAmount);\r\n    } else if (ICampaignList(_campaignFactoryAddress).getTierStatus(0) && block.timestamp >= saleInfo.saleStartTime - (tier0TimeLineInHours * 1 hours)) {  \r\n        if (!isAllowedInTier0(sender)) revert NotInTier0();\r\n        if (totalCoinInTierZero + normalizedBid > tierZerohardCap) revert ExceedTierZeroMaxCap();\r\n        if (buyInZeroTier[sender] + normalizedBid > maxAllocationPerUserTierZero) revert ExceedTierZeroUserLimit();\r\n        buyInZeroTier[sender] += normalizedBid;\r\n        buyInAllTiers[sender] += normalizedBid;\r\n        totalCoinReceived += normalizedBid;\r\n        totalCoinInTierZero += normalizedBid;\r\n        totalParticipants++;\r\n\r\n        emit ValueReceived(sender, purchasedAmount);\r\n    } else if (ICampaignList(_campaignFactoryAddress).getTierStatus(1) && block.timestamp >= saleInfo.saleStartTime - (tier1TimeLineInHours * 1 hours)) {  \r\n        if (!isAllowedInTier1(sender)) revert NotInTier1();\r\n        if (totalCoinInTierOne + normalizedBid > tierOnehardCap) revert ExceedTierOneMaxCap();\r\n        if (buyInOneTier[sender] + normalizedBid > maxAllocationPerUserTierOne) revert ExceedTierOneUserLimit();\r\n        buyInOneTier[sender] += normalizedBid;\r\n        buyInAllTiers[sender] += normalizedBid;\r\n        totalCoinReceived += normalizedBid;\r\n        totalCoinInTierOne += normalizedBid;\r\n        totalParticipants++;\r\n\r\n        emit ValueReceived(sender, purchasedAmount);\r\n    } else {\r\n        revert SaleNotStarted();\r\n    }\r\n\r\n  }\r\n\r\n  \r\n\r\n  /**\r\n  * @dev Withdraw tokens or coin by user after end time\r\n  * If this project does not reach softcap, return their funds otherwise get tokens \r\n  */\r\n  function withdrawFunds() public {\r\n\r\n    if (status != CampaignStatus.LIQUIDITY_SETUP) revert OngoingSales();\r\n\r\n    address usr = _msgSender();\r\n\r\n    if (usr == owner()) revert OwnersCannotWithdraw();\r\n    \r\n    // if campaign is sold out no need to wait for endtime finalize and setup liquidity\r\n    if (block.timestamp < saleInfo.saleEndTime && totalCoinReceived < saleInfo.hardCap) revert OngoingSales();\r\n    \r\n    if (buyInAllTiers[usr] == 0) revert NoCoinsToClaim();\r\n  \r\n    if (totalCoinReceived < saleInfo.softCap) {\r\n      status = CampaignStatus.FAILED;\r\n    }\r\n\r\n    uint256 amount = buyInAllTiers[usr];\r\n    buyInAllTiers[usr] = 0;\r\n    \r\n\r\n    if (status == CampaignStatus.FAILED) {\r\n      // return back funds\r\n      if(purchaseTokenAddress==address(0)){\r\n        payable(usr).transfer(amount);\r\n      }else{\r\n        IERC20(purchaseTokenAddress).safeTransfer(usr, amount/10**(18-purchaseCoinDecimals));\r\n      }          \r\n      emit Refunded(usr, amount/10**(18-purchaseCoinDecimals));\r\n    } else {\r\n\r\n      \r\n\r\n      uint256 amountTokens = amount * saleInfo.listRate;\r\n      IERC20 _token = IERC20(saleInfo.tokenAddress);\r\n      // Transfer Tokens to User\r\n      _token.safeTransfer(usr, amountTokens/10**(18-tokenDecimals));\r\n\r\n      emit Withdrawn(usr, amountTokens/10**(18-tokenDecimals));\r\n    }    \r\n  }\r\n\r\n  /**\r\n  * @dev Withdraw owner tokens If this project does not reach softcap\r\n  */\r\n \r\n\r\n  function withdrawOwnerTokens() public onlyOwner {\r\n      if (status != CampaignStatus.FAILED && status != CampaignStatus.CANCELLED && status != CampaignStatus.LIQUIDITY_SETUP) revert RequireCancelorFail();\r\n      if (block.timestamp < saleInfo.saleEndTime) revert NotEndDate();\r\n      if(ownerHasWithdrawnTokens) revert OwnerHasWithdrawnAlready();\r\n\r\n      if(totalCoinReceived < saleInfo.softCap){\r\n        status= CampaignStatus.FAILED;\r\n      }\r\n\r\n      IERC20 _token = IERC20(saleInfo.tokenAddress);\r\n      //if (totalCoinReceived >= saleInfo.softCap ) revert AlreadyReachedSoftCap(saleInfo.softCap);\r\n      if(status == CampaignStatus.FAILED || status == CampaignStatus.CANCELLED){\r\n        \r\n        uint256 tokensAmount = _token.balanceOf(address(this));\r\n\r\n        if (tokensAmount == 0) revert NoTokens();\r\n        ownerHasWithdrawnTokens=true;\r\n        _token.safeTransfer(msg.sender, tokensAmount);\r\n\r\n\r\n      }else if(status == CampaignStatus.LIQUIDITY_SETUP){\r\n        // // Todo\r\n        // uint tokensForUsers = totalCoinReceived * saleInfo.listRate ;\r\n        // uint tokensForLiquidity = totalCoinReceived * saleInfo.dexListRate *  saleInfo.liquidityPercent/10000;\r\n        // uint tokensForFees =zsalesPlatformDetails.zsaleTokenFee * totalCoinReceived / 10000;\r\n\r\n        // uint withdrawableTokens  = (tokensForLiquidity + tokensForUsers + tokensForFees )/ 10**(18-tokenDecimals);\r\n        // ownerHasWithdrawnTokens=true;\r\n        // _token.safeTransfer(msg.sender, withdrawableTokens);\r\n        uint256 tokensAmount = _token.balanceOf(address(this));\r\n\r\n        if (tokensAmount == 0) revert NoTokens();\r\n        ownerHasWithdrawnTokens=true;\r\n        _token.safeTransfer(msg.sender, tokensAmount);\r\n\r\n        \r\n      }\r\n      \r\n  }\r\n\r\n  function calcFairLaunchRate() public view returns (uint256 tokenRate) {\r\n    uint256 balance = purchaseTokenAddress==address(0) ? (address(this).balance) : IERC20(purchaseTokenAddress).balanceOf(address(this));\r\n    if(purchaseCoinDecimals!= 18){\r\n      balance = balance * (10 ** (18 - purchaseCoinDecimals));\r\n    }\r\n    uint tokensToSell = tokenDecimals == 18 ? saleInfo.tokensOnSale : saleInfo.tokensOnSale * (10 ** (18 - tokenDecimals));\r\n       \r\n    tokenRate = tokensToSell/balance;\r\n  }\r\n  \r\n\r\n  /**\r\n    * Setup liquidity and transfer all amounts according to defined percents, if softcap not reached set Refunded flag\r\n    */\r\n  function finalizeAndSetupLiquidity() public nonReentrant {\r\n    \r\n    require (totalCoinReceived >= saleInfo.hardCap || block.timestamp > saleInfo.saleEndTime, NoSoldOutOrEndDate());\r\n    if (status == CampaignStatus.FAILED || status == CampaignStatus.CANCELLED) revert CampaignFailedOrCancelled();\r\n    \r\n    if (status == CampaignStatus.LIQUIDITY_SETUP) revert LiquiditySetupAlreadyDone();\r\n    //\r\n    if(totalCoinReceived < saleInfo.softCap){ // set to failed and stop\r\n        status= CampaignStatus.FAILED ;\r\n        return;\r\n    }\r\n\r\n    \r\n    IERC20 tokenOnSale = IERC20(saleInfo.tokenAddress);\r\n    \r\n    if(saleInfo.softCap==0){//fairlaunch\r\n        //set listrate and dexlisrate\r\n      saleInfo.dexListRate = calcFairLaunchRate();\r\n      saleInfo.listRate = calcFairLaunchRate();\r\n    }\r\n\r\n    // Total amount invested\r\n    uint256 currentCoinBalance = purchaseTokenAddress==address(0) ? address(this).balance: IERC20(purchaseTokenAddress).balanceOf(address(this));\r\n    \r\n    if(currentCoinBalance<=0 || (totalCoinReceived/ 10**(18-purchaseCoinDecimals)) > currentCoinBalance ){\r\n       revert NoCoin();\r\n    }\r\n    \r\n    uint256 zsaleFeeAmount = (totalCoinReceived * zsalesPlatformDetails.zsaleFee / 10000) / 10**(18-purchaseCoinDecimals);\r\n    uint256 zsaleTokenFeeAmount = (saleInfo.listRate * totalCoinReceived * zsalesPlatformDetails.zsaleTokenFee/ 10000) /10**(18 -tokenDecimals);\r\n    \r\n    //Fees charged in Purchase coin\r\n    if(purchaseTokenAddress==address(0)){\r\n      payable(zsalesPlatformDetails.zsalesWalletAddress).transfer(zsaleFeeAmount);\r\n    }else{\r\n      IERC20(purchaseTokenAddress).safeTransfer(zsalesPlatformDetails.zsalesWalletAddress, zsaleFeeAmount);\r\n    }\r\n    // //Fee charged in Token listed, \r\n    tokenOnSale.safeTransfer(zsalesPlatformDetails.zsalesWalletAddress, zsaleTokenFeeAmount);\r\n\r\n\r\n    uint256 supplyAfterFees = purchaseTokenAddress==address(0) ? address(this).balance : IERC20(purchaseTokenAddress).balanceOf(address(this));\r\n    //Amount of Token to be sent to dex\r\n    if(purchaseTokenAddress!=address(0)){\r\n      supplyAfterFees = supplyAfterFees * (10 ** (18 - purchaseCoinDecimals));\r\n    }\r\n\r\n    \r\n    console.log('CTRACT:: 5 : supplyAfterFees: %d, saleInfo.liquidityPercent %d,saleInfo.dexListRate  %d  ', supplyAfterFees, saleInfo.liquidityPercent, saleInfo.dexListRate );\r\n    uint256 tokensBalance =  tokenOnSale.balanceOf(address(this)) * (10 ** (18 - tokenDecimals));\r\n    // Amount to be sent to dex\r\n    uint256 liquidityAmount = (supplyAfterFees * saleInfo.liquidityPercent) / 10000;\r\n    if(tokensBalance < liquidityAmount * saleInfo.dexListRate ) revert NoTokensForLiquidity();\r\n    \r\n    uint256 tokensForLiquidity = liquidityAmount * saleInfo.dexListRate / (10 ** (18 - tokenDecimals)); \r\n    bool approvalSucess = tokenOnSale.approve(dexRouterAddress, tokensForLiquidity);\r\n    require(approvalSucess == true, RouterApprovalFailed());\r\n\r\n    // console.log('CTRACT:: 6 : tokensForLiquidity: %d ', tokensForLiquidity);\r\n    IDexRouter _dexRouter=IDexRouter(dexRouterAddress);\r\n    if(purchaseTokenAddress==address(0)){\r\n      \r\n      _dexRouter.addLiquidityETH{value: liquidityAmount}(\r\n            saleInfo.tokenAddress,\r\n            tokensForLiquidity,\r\n            0, //tokensForLiquidity,\r\n            liquidityAmount, // liquidityAmount,\r\n            address(this),\r\n            block.timestamp + 100\r\n      );\r\n      \r\n      \r\n      emit LiquidityAddedToRouter(dexRouterAddress, address(0),saleInfo.tokenAddress,liquidityAmount,tokensForLiquidity  );\r\n\r\n    }else{\r\n      \r\n      tokenOnSale.approve(dexRouterAddress, MAX_INT);\r\n      \r\n      IERC20(purchaseTokenAddress).approve(dexRouterAddress, MAX_INT);\r\n      _dexRouter.addLiquidity(\r\n          address(tokenOnSale),\r\n          purchaseTokenAddress,\r\n          tokensForLiquidity,\r\n          liquidityAmount/(10** (18-purchaseCoinDecimals)),\r\n          0,\r\n          0,            \r\n          address(this),\r\n          block.timestamp + 100\r\n      );\r\n      emit LiquidityAddedToRouter(dexRouterAddress, purchaseTokenAddress,address(tokenOnSale),liquidityAmount,tokensForLiquidity  );\r\n\r\n    }\r\n\r\n        \r\n    // get lp address from factory\r\n    IDexFactory _dexFactory = IDexFactory(_dexRouter.factory());\r\n    liquidityPairAddress = _dexFactory.getPair(saleInfo.tokenAddress, purchaseTokenAddress==address(0)?_dexRouter.WETH(): purchaseTokenAddress );\r\n    uint lpPairbalance=IERC20(liquidityPairAddress).balanceOf(address(this));\r\n    liquidityPairLockerAddress = _dexLocker.lockERC20(liquidityPairAddress, owner(),lpPairbalance, 100,liquidityReleaseInDays,0,0);// address(tokenLocker);\r\n    \r\n    IERC20(liquidityPairAddress).safeTransfer(liquidityPairLockerAddress, lpPairbalance);\r\n\r\n    uint256 balanceAfterLiquidityAndFees = purchaseTokenAddress==address(0) ? address(this).balance : IERC20(purchaseTokenAddress).balanceOf(address(this));\r\n    if(useRaisedFundsVesting){\r\n      //send raised funds to Lock\r\n      // Remainder after all dedeuctions and liquidity\r\n      if(purchaseTokenAddress==address(0)){        \r\n        _dexLocker.startRaisedFundsLock{value: (_dexLocker.raisedFundsPercent() * balanceAfterLiquidityAndFees) / 10000 }( balanceAfterLiquidityAndFees );\r\n        \r\n      }else{\r\n        IERC20(purchaseTokenAddress).safeTransfer(address(_dexLocker),(_dexLocker.raisedFundsPercent() * balanceAfterLiquidityAndFees) / 10000);\r\n        _dexLocker.startRaisedFundsLock( balanceAfterLiquidityAndFees );\r\n      }\r\n    }    \r\n\r\n    // Send Balance to Owner\r\n    if(purchaseTokenAddress==address(0)){\r\n      sendValue(owner(),address(this).balance);      \r\n    }else{\r\n      IERC20(purchaseTokenAddress).safeTransfer(owner(),IERC20(purchaseTokenAddress).balanceOf(address(this)) );\r\n      \r\n    }\r\n    \r\n    status=CampaignStatus.LIQUIDITY_SETUP;\r\n  }\r\n\r\n  \r\n  function getCampaignInfo() public view returns( uint256 softcap, uint256 hardcap,uint256 saleStartTime, uint256 saleEndTime,uint256 listRate, uint256 dexListRate, uint liquidity,uint _liquidityReleaseTime ,uint256 totalCoins, uint256 totalParticipant, bool use_WhiteList, bool hasKyc, bool isAuditd, string memory _auditUrl ){\r\n    return ( saleInfo.softCap, saleInfo.hardCap,saleInfo.saleStartTime, saleInfo.saleEndTime, saleInfo.listRate, saleInfo.dexListRate, saleInfo.liquidityPercent, liquidityReleaseInDays, totalCoinReceived,totalParticipants, useWhiteList,hasKYC, _isAudited, auditUrl );\r\n  }\r\n\r\n  function getCampaignSalePriceInfo() public view returns(uint256 , uint256,uint256 , uint256,uint256 , uint256,uint256 ){\r\n    return (saleInfo.listRate, saleInfo.dexListRate, saleInfo.softCap, saleInfo.hardCap, tierOnehardCap,tierTwohardCap, maxAllocationPerUserTierTwo  );\r\n  }\r\n\r\n    \r\n  function dexLockerAddress() public view onlyAdmin returns (address) {\r\n      return address( _dexLocker);\r\n  }\r\n\r\n  //Get Sale token\r\n  function tokenAddress() public view returns (address) {\r\n      return saleInfo.tokenAddress;\r\n  }\r\n\r\n  // Refund any mistakenly sent in ERC20\r\n  function refundERC20(IERC20 _token, address recipient, uint256 amount) public onlyAdmin {      \r\n    _token.safeTransfer(recipient, amount);\r\n  }\r\n\r\n}"
    },
    "contracts/CampaignList.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n// import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\n// import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"./Campaign.sol\";\r\nimport \"./FairLaunchCampaign.sol\";\r\nimport \"./Confirmations/ConfirmAddress.sol\";\r\nimport './Lockers/DexLockerFactory.sol';\r\nimport './Lockers/VestSchedule.sol';\r\nimport \"hardhat/console.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\n\r\nimport './Interfaces/Turnstile.sol';\r\nimport \"./Errors.sol\";\r\n\r\nerror NotEnoughBalance(uint balance);\r\n\r\ninterface ICampaignList{\r\n    function zsaleFee() external view returns (uint);// 2%   - percent of purchase currency to take\r\n    function zsaleTokenFee() external view returns (uint);// percent fee of token to take\r\n    function campaignCreationPrice() external view returns (uint);// \r\n    function zsalesWalletAddress() external view returns (address); //receives commissions\r\n\r\n    function zsalesAdmin() external view returns (address);\r\n    function zsalesTokenAddress() external view returns (address);\r\n    function zsalesNFTTokenAddress() external view returns (address);\r\n    function getTierStatus(uint tier) external view returns (bool);\r\n    function maxTiersToCheckForNFT() external view returns(uint);\r\n}\r\n\r\n\r\ncontract CampaignList is Context,Ownable, ICampaignList  {\r\n    error NoCampaignCreatePrice();\r\n    error RequiresTokenContract();\r\n    error ExistingCampaign();\r\n    error TokensOnSaleRequired();\r\n\r\n    using SafeERC20 for IERC20;\r\n  // Add the library methods\r\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\r\n    \r\n    // Declare a set state variable\r\n    EnumerableMap.UintToAddressMap private _campaigns;\r\n\r\n    uint private _counter;\r\n\r\n    DexLockerFactory private _dexLockerFactory;\r\n\r\n    ConfirmAddress addressConfirmer;\r\n\r\n    /**\r\n    * @dev percent of native currency to take multiplied by 100 i.e 200 for 2%.\r\n    */\r\n    uint public zsaleFee = 200;  //2%   - percent of native currency to take\r\n    uint public zsaleTokenFee = 200;  //2% - percent fee of token to take\r\n    uint public campaignCreationPrice = 0.00001 ether; \r\n    address public zsalesWalletAddress = 0xB7e16f5fa9941B84baCd1601F277B00911Aed339 ; // receives commissions\r\n\r\n    address public zsalesAdmin  ;\r\n\r\n    address public zsalesTokenAddress = 0x97CEe927A48dc119Fd0b0b1047a879153975e893 ;\r\n\r\n    address public zsalesNFTTokenAddress = 0x97CEe927A48dc119Fd0b0b1047a879153975e893 ;\r\n\r\n    mapping(address => uint256[]) private ownersCampaign; //owneraddress -> campaignIndex\r\n\r\n    mapping(uint256 => bool) private _tierStatuses; //tier -> enable/disable\r\n\r\n    mapping(address => uint256) public campaignTokensLocked; //owneraddress -> campaignIndex\r\n    \r\n\r\n    mapping(address => address payable ) public _tokenCampaigns; //tokenAddress=>Campaign\r\n\r\n    event CampaignCreated(address indexed creator,uint256 indexed index, address createdCampaignAddress);\r\n    \r\n    uint public maxTiersToCheckForNFT= 5;\r\n    \r\n    address  _campaignImplementationAddress;\r\n\r\n    address public turnstileAddress = address(0);\r\n    Turnstile private turnstile;\r\n\r\n    constructor(DexLockerFactory dexLockerFactory,address zsalesToken,address zsalesNFTToken, address campaignImplementationAddress) Ownable(msg.sender)  {      \r\n       _dexLockerFactory=dexLockerFactory;\r\n       _campaignImplementationAddress = campaignImplementationAddress;\r\n       zsalesTokenAddress=zsalesToken;\r\n       zsalesNFTTokenAddress=zsalesNFTToken;\r\n       addressConfirmer=new ConfirmAddress();\r\n       zsalesAdmin= _msgSender();\r\n    }\r\n\r\n    function updateTurnstileAddress(address newAddress) public onlyOwner{\r\n        \r\n        turnstileAddress=newAddress;\r\n        turnstile = Turnstile(turnstileAddress);\r\n        //Registers the smart contract with Turnstile\r\n        //Mints the CSR NFT to the contract creator\r\n        turnstile.register(tx.origin);\r\n\r\n    }\r\n\r\n    /**************************|\r\n    |          Setters         |\r\n    |_________________________*/\r\n    function setCampaignImplementation(address campaignImplementationAddress) public onlyOwner  {   \r\n       _campaignImplementationAddress = campaignImplementationAddress;\r\n    }\r\n\r\n    function setCampaignCreationPrice(uint256 newPrice) public onlyOwner{\r\n        campaignCreationPrice=newPrice;\r\n    }\r\n\r\n    function setCampaignFee(uint256 saleFee, uint256 saleTokenFee) public onlyOwner{\r\n        zsaleFee=saleFee;\r\n        zsaleTokenFee=saleTokenFee;\r\n    }\r\n\r\n    function setFeeWallet(address salesWalletAddress) public onlyOwner{\r\n        zsalesWalletAddress=salesWalletAddress;\r\n    }\r\n\r\n    function setAdmin(address newAdmin) public onlyOwner{\r\n        zsalesAdmin=newAdmin;\r\n    }\r\n\r\n    function setZSalesMaxTiersToCheckForNFT(uint newMax) public onlyOwner{\r\n        maxTiersToCheckForNFT=newMax;\r\n    }\r\n\r\n    function setZSalesNFTTokenAddress(address newAddress) public onlyOwner{\r\n        zsalesNFTTokenAddress=newAddress;\r\n    }\r\n\r\n    function setZSalesTokenAddress(address newAddress) public onlyOwner{\r\n        zsalesTokenAddress=newAddress;\r\n    }\r\n\r\n    function setTierStatus(uint tier,bool status) public onlyOwner{\r\n        _tierStatuses[tier]=status;\r\n    }\r\n\r\n    function getTierStatus(uint tier) public view returns (bool){\r\n        return _tierStatuses[tier];\r\n    }\r\n\r\n    function getCampaignValues(\r\n        /** uint256 softCap,\r\n         * uint256 hardCap,\r\n         * uint256 _saleStartTime,\r\n         * uint256 _saleEndTime,  \r\n         * uint256 _minAllocationPerUser ,   \r\n         * uint256 _maxAllocationPerUserTierTwo ,\r\n         */\r\n        uint256[6] memory _capAndDate\r\n    ) public pure returns(uint256[10] memory capAndDate){\r\n        for (uint i=0; i < 4; i += 1) {\r\n            capAndDate[i] = _capAndDate[i];\r\n        }\r\n        capAndDate[4]=1000 * _capAndDate[1] / 4000;// tier 1 hardcap is 1/4th of hardcap\r\n        capAndDate[5]=_capAndDate[1];// tier 2 hardcap is equal to hardcap\r\n        capAndDate[6]=_capAndDate[4];//min allocation\r\n        capAndDate[7]=_capAndDate[5];// max allocation\r\n        capAndDate[8]=_capAndDate[5];// max allocation\r\n        capAndDate[9]=0;\r\n    }\r\n    \r\n\r\n    /**\r\n    * @dev Create A new Campaign. Throws if Campaign for token already exists.\r\n    */\r\n    function createNewCampaign(address _tokenAddress, address _purchaseTokenAddress, \r\n        uint tokensOnSale,  //tokensOnSale ,if fairlaunch\r\n        /** uint256 softCap,\r\n     * uint256 hardCap,\r\n     * uint256 _saleStartTime,\r\n     * uint256 _saleEndTime,  \r\n     * uint256 _minAllocationPerUser ,   \r\n     * uint256 _maxAllocationPerUserTierTwo \r\n     */\r\n        uint256[6] memory _capAndDate, address _dexRouterAddress,uint[4] memory liquidityAllocationAndRates,\r\n        string[6] memory founderInfo,bool[2] memory _useTokenOrRaisedFundsVesting,\r\n        // VestSchedule[8] memory teamTokenVestingDetails,\r\n        uint256[5] memory teamTokenVestingDetails,\r\n        /**\r\n         * uint256 _percent,\r\n         * uint256 _vestingDurationInDays,\r\n         * uint256 _vestingCliffInDays,\r\n         */\r\n        uint256[3] memory raisedFundVestingDetails\r\n    ) public payable  {\r\n        /** uint256 _normalizedTo18DecimalsSoftCap,\r\n         * uint256 __normalizedTo18DecimalsHardCap,\r\n         * uint256 _saleStartTime,\r\n         * uint256 _saleEndTime, \r\n         * \r\n         * uint256 _nomrlaizedTierOneHardCap, \r\n         * uint256 _nomrlaizedTierTwoHardCap, \r\n         * _minAllocationPerUser\r\n         * uint256 _maxAllocationPerUserTierOne, \r\n         * uint256 _maxAllocationPerUserTierTwo ,\r\n         * uint _campaignKey,*/\r\n        uint256[10] memory capAndDate = getCampaignValues(_capAndDate);\r\n\r\n        if(capAndDate[0]==0){//FairLaunch\r\n            require(tokensOnSale>1, TokensOnSaleRequired());\r\n        }\r\n\r\n        if(capAndDate[0]!=0){//Capped campaign\r\n            require(capAndDate[1]  <= capAndDate[0] * 4, HardCapGreaterThanX4OfSoftCap());\r\n        }\r\n\r\n        require(msg.value >= campaignCreationPrice, NoCampaignCreatePrice() );\r\n        require(addressConfirmer.isContract(_tokenAddress), RequiresTokenContract());        \r\n        if(_tokenCampaigns[_tokenAddress] != address(0)){\r\n            Campaign ct = Campaign(_tokenCampaigns[_tokenAddress]);\r\n            require(ct.status() == Campaign.CampaignStatus.CANCELLED || ct.status() == Campaign.CampaignStatus.FAILED, ExistingCampaign());\r\n        }\r\n        \r\n        {     \r\n            _counter++; \r\n            capAndDate[9] = _counter;\r\n            \r\n            if(_purchaseTokenAddress!= address(0)){\r\n                uint purchaseDecimals = IERC20Metadata(_purchaseTokenAddress).decimals();\r\n                if( purchaseDecimals !=18){\r\n                    capAndDate[0]=normalizeTokenAmount(capAndDate[0], purchaseDecimals); //Softcap\r\n                    capAndDate[1]=normalizeTokenAmount(capAndDate[1], purchaseDecimals);\r\n\r\n                    capAndDate[4]=normalizeTokenAmount(capAndDate[4], purchaseDecimals); \r\n                    capAndDate[5]=normalizeTokenAmount(capAndDate[5], purchaseDecimals);\r\n\r\n                    capAndDate[6]=normalizeTokenAmount(capAndDate[6], purchaseDecimals); \r\n                    capAndDate[7]=normalizeTokenAmount(capAndDate[7], purchaseDecimals);\r\n                    capAndDate[8]=normalizeTokenAmount(capAndDate[8], purchaseDecimals);\r\n                }else if(purchaseDecimals >18){\r\n                    revert OnlyDecimals18AndBelow();\r\n                }\r\n            }\r\n\r\n            address payable newCampaignCloneAddress = payable(Clones.clone(_campaignImplementationAddress) );\r\n            Campaign(newCampaignCloneAddress).initialize([msg.sender, address(this) ,  _tokenAddress, _purchaseTokenAddress],\r\n                capAndDate[0]==0?tokensOnSale:0, \r\n                capAndDate, _dexRouterAddress,liquidityAllocationAndRates,teamTokenVestingDetails, raisedFundVestingDetails,\r\n                 _useTokenOrRaisedFundsVesting, founderInfo, _dexLockerFactory);\r\n\r\n             _campaigns.set(_counter, newCampaignCloneAddress);\r\n            ownersCampaign[msg.sender].push( _counter);        \r\n            _tokenCampaigns[_tokenAddress]= payable(newCampaignCloneAddress);\r\n\r\n\r\n            emit CampaignCreated(msg.sender, _counter,newCampaignCloneAddress);\r\n\r\n            _transferTokensRequired(Campaign(newCampaignCloneAddress),liquidityAllocationAndRates[0],capAndDate[0],capAndDate[1], liquidityAllocationAndRates[2],tokensOnSale,  _useTokenOrRaisedFundsVesting[0], teamTokenVestingDetails[0]);\r\n\r\n        }\r\n    }\r\n\r\n    function _transferTokensRequired(Campaign ct,uint liquidityPercent,uint softCap, uint hardCap, uint listRate, uint tokensOnSale, bool useTeamTokenVesting, uint totalTeamTokensToBeVested) private \r\n    {               \r\n        uint tokenDecimals = IERC20Metadata(ct.tokenAddress()).decimals();\r\n        \r\n        //tokensForLiquidity // in 18 digits\r\n        uint amountOfTokensToLock = softCap !=0 ?  (ct.getDexListRate() * liquidityPercent * hardCap)  / 10000 : liquidityPercent * normalizeTokenAmount(tokensOnSale, tokenDecimals ) /10000;\r\n        \r\n        //tokensForSale // in 18 digits\r\n        uint tokensForSale = softCap !=0 ?  (listRate * hardCap) : normalizeTokenAmount(tokensOnSale, tokenDecimals );\r\n        amountOfTokensToLock += tokensForSale;\r\n               \r\n\r\n        // add zsale fee\r\n        uint256 feeAmount =  softCap !=0? ((zsaleTokenFee *  ct.getHardCap() )/10000) * ct.getDexListRate() : (zsaleTokenFee *  normalizeTokenAmount(tokensOnSale, tokenDecimals ) /10000);\r\n\r\n        uint total = ((amountOfTokensToLock + feeAmount) / (10**(18 - tokenDecimals )) );\r\n        \r\n        if(useTeamTokenVesting){\r\n            \r\n            total += totalTeamTokensToBeVested;\r\n            // console.log('CONTRACT::  Vested Tokens: %d, norm: %d, FINALTOTAL: %d', totalTeamTokensToBeVested, normalizeTokenAmount(totalTeamTokensToBeVested, tokenDecimals ), total );\r\n        }\r\n\r\n        IERC20 _token = IERC20(ct.tokenAddress());\r\n        \r\n        _token.safeTransferFrom(_msgSender(), address(ct), total);\r\n\r\n        campaignTokensLocked[address(ct)]=total;//(amountOfTokensToLock+feeAmount) * (10**tokenDecimals ) / (10**(18 - tokenDecimals ));//  * (10**(18 - tokenDecimals ))  ;\r\n        \r\n        // _token.safeTransfer( address(ct), total);\r\n        ct.startReceivingBids();\r\n    }\r\n\r\n    \r\n\r\n    function hasExistingCampaign(address _tokenAddress) external view returns (bool){\r\n        return _tokenCampaigns[_tokenAddress] != address(0);\r\n    }\r\n\r\n    function allOwnersCampaignsSize() public view returns (uint256) {\r\n        return ownersCampaign[msg.sender].length;\r\n    }\r\n    function allOwnersCampaignsSize(address owner) public view returns (uint256) {\r\n        return ownersCampaign[owner].length;\r\n    }\r\n\r\n    //offset \r\n    function allOwnersCampaigns( uint256 start, uint256 offset) public view returns (uint256[] memory) {\r\n        uint256[] memory list = new uint256[](offset) ;\r\n        for (uint256 i=start; i < start + offset ; i++) {\r\n            list[i-start] = ownersCampaign[msg.sender][i]; \r\n        }\r\n        return list;\r\n    }\r\n\r\n    function allOwnersCampaigns(address owner, uint256 start, uint256 offset) public view returns (uint256[] memory) {\r\n        uint256[] memory list = new uint256[](offset) ;\r\n        for (uint256 i=start; i < start + offset ; i++) {\r\n            list[i-start] = ownersCampaign[owner][i]; \r\n        }\r\n        return list;\r\n    }\r\n\r\n    \r\n    function campaignSize() public view returns (uint256) {\r\n        return _campaigns.length();\r\n    }\r\n\r\n    \r\n\r\n        \r\n\r\n    function contains(uint256 key) public view returns (bool) {\r\n        return _campaigns.contains(key);\r\n    }\r\n\r\n        \r\n\r\n    function campaignAt(uint256 index) public view returns (uint256 key, address value) {\r\n        return _campaigns.at(index);\r\n    }\r\n\r\n    function tryGetCampaignByKey(uint256 key) public view returns (bool, address) {\r\n        return _campaigns.tryGet(key);\r\n    }\r\n\r\n    function tryGetCampaignByTokenAddress(address _tokenAddress) public view returns ( address) {\r\n        return _tokenCampaigns[_tokenAddress];\r\n    }\r\n\r\n    receive() external payable {\r\n        \r\n    }\r\n\r\n    // //abi.encodePacked(x)\r\n    // function concatenate(string memory s1, string memory s2) public pure returns (string memory) {\r\n    //     return string(abi.encodePacked(s1, s2));\r\n    // }\r\n\r\n    // function concatenate(string memory s1, address s2) public pure returns (string memory) {\r\n    //     return string(abi.encodePacked(s1, s2));\r\n    // }\r\n\r\n\r\n    /**\r\n     * Normalization function that adjusts token amounts to a common decimal base (18 decimals in this case). \r\n     * This function either scales up or scales down the token amount based on the number of decimals the token uses,\r\n     * ensuring the final amount will be always displayed with 18 decimals. \r\n     * Of course this can result in a minor truncation if tokens >18 decimals are being used, this must be considered\r\n     */\r\n    function normalizeTokenAmount(uint tokenAmount, uint tokenDecimals) public pure returns (uint) {\r\n        uint standardDecimal = 18;\r\n        if(tokenDecimals>standardDecimal){\r\n            return tokenAmount / (10 ** (tokenDecimals-standardDecimal));\r\n        }\r\n        else if(tokenDecimals< standardDecimal){\r\n            return tokenAmount * (10 ** (standardDecimal - tokenDecimals));\r\n        }\r\n        else{\r\n            return tokenAmount;\r\n        }\r\n    }\r\n    \r\n    // Sends to th 'to' address or the zsalesWalletAddress if to address is zeroAddress\r\n    function  withdrawFee(address to, uint amount) public onlyOwner  {\r\n        \r\n        uint balance = address(this).balance;\r\n        if(amount>=balance){\r\n            if(to==address(0)){\r\n                to=zsalesWalletAddress;\r\n            }\r\n\r\n            payable(to).transfer(amount);\r\n        }else {\r\n            revert NotEnoughBalance(balance);\r\n        }\r\n    }\r\n\r\n}"
    },
    "contracts/Confirmations/ConfirmAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\n\r\ncontract ConfirmAddress{\r\n    \r\n    address private  _account;\r\n    \r\n    \r\n    // to dectect if the address is a contract or not\r\n   /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) public view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // bytes32 tokenaddress= 0xDf8681e9bF215076c1661Cbb5cd10F0d4902D662;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}"
    },
    "contracts/Errors.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.27;\r\n\r\nerror OnlyDeployer();\r\nerror NoToken();\r\nerror NoZeroTokenAddress();\r\nerror NoEthForLiquidity();\r\nerror NoTokenBalanceForLiquidity();\r\nerror NoPurchaseTokensForLiquidity();\r\nerror NoTokensForLiquidity();\r\nerror RouterApprovalFailed();\r\n\r\nerror AlreadyReachedSoftCap(uint cap);\r\n\r\nerror LiquiditySetupAlreadyDone();\r\n\r\nerror AddLiquidityNotCalledYet();\r\nerror NoLPTokensToRelease();\r\nerror NoTokensToRelease();\r\nerror NoPurchaseTokensToRelease();\r\nerror CurrentTimeIsBeforeRelease();\r\n\r\nerror SaleEndTimeBeforeStartTime();\r\nerror LiquidityAboveLimit(uint limit);\r\n\r\nerror UpdateAfterSaleStartTime();\r\n\r\nerror TierCapTooLow(uint limit);\r\nerror TierCapsExceedHardCap();\r\nerror TierOneCapExceedsHardCap();\r\nerror TierTwoCapExceedsHardCap();\r\nerror MinAllocationOutOfRange();\r\nerror TierOneMaxAllocationOutOfRange();\r\nerror TierTwoMaxAllocationOutOfRange();\r\nerror HardCapGreaterThanX4OfSoftCap();\r\n\r\nerror NotOwner();\r\nerror NotAdmin();\r\nerror CannotCancelAfterSaleStartTime();\r\nerror PostponeBeforeSaleStartTime();\r\nerror NewDateLessThanOldDate();\r\nerror EndDateLessThanStartTime();\r\n\r\nerror AlterWhitelistingAfterSaleStartTime();\r\n\r\nerror KYCAfterSaleStartTime();\r\nerror AuditAfterSaleStartTime();\r\n\r\nerror SaleCancelled();\r\nerror SaleFailed();\r\nerror NotTokenSubmitted();\r\nerror SoldOutError();\r\nerror ClosedSale();\r\nerror ExceedMaxCap();\r\nerror LessThanMinBuy();\r\n\r\n\r\nerror NotInTier2Whitelist();\r\nerror ExceedTierTwoMaxCap();\r\nerror ExceedTierTwoUserLimit();\r\nerror NotInTier0();\r\nerror ExceedTierZeroMaxCap();\r\nerror ExceedTierZeroUserLimit();\r\nerror NotInTier1();\r\nerror ExceedTierOneMaxCap();\r\nerror ExceedTierOneUserLimit();\r\nerror SaleNotStarted();\r\n\r\nerror OwnersCannotWithdraw();\r\nerror OngoingSales();\r\nerror NoCoinsToClaim();\r\nerror NoCoin();\r\n\r\nerror CampaignFailedOrCancelled();\r\nerror CampaignCancelled();\r\n\r\nerror NotEndDate();\r\nerror NoReachSoftCap();\r\n\r\nerror RequireCancelorFail();\r\nerror NoTokens();\r\n\r\nerror NoSoldOutOrEndDate();\r\n\r\nerror OnlyDecimals18AndBelow();\r\n\r\nerror TransferDExLockerFailed();\r\n\r\nerror OwnerHasWithdrawnAlready();\r\n\r\n\r\nerror InvalidDexRouterAddress(address addr);\r\nerror InvalidSalesTokenAddress(address addr);\r\nerror InvalidPurchaseTokenAddress(address addr);\r\nerror InvalidOwnerAddress(address addr);\r\nerror InvalidDeployerAddress(address addr);"
    },
    "contracts/FairLaunchCampaign.sol": {
      "content": "// // SPDX-License-Identifier: MIT\r\n// pragma solidity ^0.8.28;\r\n\r\n// import \"@openzeppelin/contracts/utils/Context.sol\";\r\n// // import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n// // import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\n// import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n// import {IERC1155} from \"@openzeppelin/contracts/token/ERC1155/IERC1155.sol\";\r\n\r\n// import \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\n// // import \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\r\n\r\n// import \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n// import './Lockers/DexLockerFactory.sol';\r\n// import {IDexLocker} from './Lockers/DexLocker.sol';\r\n// // import './Lockers/TokenLocker.sol';\r\n// import \"./Lockers/VestSchedule.sol\";\r\n// import \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\r\n// import \"hardhat/console.sol\";\r\n// import {IDexRouter, IDexFactory} from \"./IDexRouter.sol\";\r\n// import {ICampaignList} from \"./CampaignList.sol\";\r\n// import {PlatFormDetails} from \"./Campaign.sol\";\r\n// import \"./Errors.sol\";\r\n\r\n// contract FairLaunchCampaign is Initializable,Ownable, ReentrancyGuard {\r\n//   using SafeERC20 for IERC20;\r\n//   error InsufficientBalance();\r\n//   error NoSendValue();\r\n\r\n//   uint256 constant private MAX_INT = 2**256 - 1;\r\n\r\n//   event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);\r\n//   event ValueReceived(address user, uint amount);\r\n//   event Withdrawn(address user, uint amount);\r\n//   event Refunded(address user, uint amount);\r\n//   event SoldOut();\r\n//   event LiquidityAddedToRouter(address indexed router, address indexed token1,address indexed token2, uint amountToken1, uint amountToken2);\r\n\r\n//   struct CampaignSaleInfo {\r\n//       //token attributes\r\n//       address   tokenAddress; \r\n//       uint256  softCap; // Soft cap in coin\r\n//       uint256  hardCap; // Max cap in coin\r\n//       uint256  saleStartTime; // start sale time\r\n//       uint256  saleEndTime; // end sale time\r\n//       uint   liquidityPercent; // multiplied by 100 e.g 45% is 4500\r\n//       uint   tokensOnSale; \r\n//       // RefundType  refundType;\r\n//       string logoUrl;\r\n//       string desc;\r\n//       string website;\r\n//       string twitter;\r\n//       string telegram;\r\n//       string discord;\r\n//       // string bannerImage;\r\n      \r\n//   }\r\n\r\n//   enum CampaignStatus{ \r\n//     CREATED,\r\n//     TOKENS_SUBMITTED,//Owner has transferred the correct no of tokens and campaign is ready to receive\r\n//     CANCELLED, // Cancelled before the start date\r\n    \r\n//     FAILED, // WIll need refund\r\n//     LIQUIDITY_SETUP\r\n\r\n//   }\r\n\r\n//   bool   public useWhiteList;//Use in only Tier 2\r\n//   bool   public hasKYC;\r\n//   uint public totalTeamTokensToBeVested=0;\r\n//   bool _isAudited; \r\n//   string public auditUrl;\r\n//   CampaignStatus public  status = CampaignStatus.CREATED;\r\n\r\n//   address public liquidityPairAddress;\r\n//   address public liquidityPairLockerAddress;\r\n\r\n  \r\n  \r\n  \r\n//   CampaignSaleInfo public  saleInfo;\r\n  \r\n  \r\n//   address public dexRouterAddress;\r\n//   uint256 public totalCoinReceived; // total  received\r\n//   uint256 public totalCoinInTierZero;\r\n//   uint256 public totalCoinInTierOne; // total coin for tier one\r\n//   uint256 public totalCoinInTierTwo; // total coin for tier Tier\r\n\r\n//   address public purchaseTokenAddress=address(0); // Token address for Purchases for this campaign - address 0 is native currency\r\n  \r\n\r\n//   uint public totalParticipants; // total participants in ido\r\n  \r\n\r\n//   PlatFormDetails zsalesPlatformDetails;\r\n//   // address private _admin= 0xB7e16f5fa9941B84baCd1601F277B00911Aed339; //zsales admin - can setkyc and audited\r\n//   // address public zsalesTokenAddress = 0x97CEe927A48dc119Fd0b0b1047a879153975e893;\r\n//   // uint zsaleFee = 200;  //2%   - percent of native currency to take\r\n//   // uint zsaleTokenFee = 200;  //2% - percent fee of token to take\r\n\r\n//   // address public zsalesNFTTokenAddress = 0x97CEe927A48dc119Fd0b0b1047a879153975e893;\r\n//   // address zsalesWalletAddress = 0xB7e16f5fa9941B84baCd1601F277B00911Aed339 ; // receives commissions\r\n//   address public _campaignFactoryAddress ;\r\n\r\n//   uint private tier1TimeLineInHours = 2; // e.g 2 hours before startime\r\n//   uint private tier0TimeLineInHours = 3;\r\n\r\n//   bool private ownerHasWithdrawnTokens=false;\r\n  \r\n//   // max cap per tier\r\n//   uint public tierZerohardCap;\r\n//   uint public tierOnehardCap;\r\n//   uint public tierTwohardCap;\r\n    \r\n//   //total users per tier\r\n//   // uint public totalUserInTierZero;\r\n//   // uint public totalUserInTierOne;\r\n//   // uint public totalUserInTierTwo;\r\n  \r\n//   bool public useTokenVesting;\r\n//   bool public useRaisedFundsVesting;\r\n\r\n\r\n//   //Tier 0 - holders of our NFT\r\n//   //Tier 1 - holders of our coin\r\n//   //Tier 2 - Whitelisted or public   \r\n//   uint public minAllocationPerUser;\r\n//   //max allocations per user in a tier\r\n//   uint public maxAllocationPerUserTierZero;\r\n//   uint public maxAllocationPerUserTierOne;\r\n//   uint public maxAllocationPerUserTierTwo; \r\n  \r\n \r\n//   // // address array for tier one whitelist\r\n//   // address[] private whitelistTierOne;  // every tokenholder is automatically whitelisted\r\n  \r\n//   // // address array for tier two whitelist\r\n//   // address[] private whitelistTierTwo; \r\n\r\n//   bytes32 private _whitelistTierTwoMerkleRoot;\r\n  \r\n\r\n//   uint public campaignKey;\r\n//   // enum RefundType{ BURN, REFUND }\r\n  \r\n//   uint256 public liquidityReleaseInDays; // days to release Lp tokens to owner\r\n\r\n//   //mapping the user purchase per tier\r\n//   mapping(address => uint) public buyInZeroTier;\r\n//   mapping(address => uint) public buyInOneTier;\r\n//   mapping(address => uint) public buyInTwoTier;\r\n//   mapping(address => uint) public buyInAllTiers;\r\n//   DexLockerFactory private _dexLockerFactory;\r\n  \r\n//   IDexLocker public _dexLocker;\r\n//   uint private tokenDecimals;\r\n//   uint private purchaseCoinDecimals;\r\n  \r\n\r\n//   ///Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be taken over by an attacker, which may impact the proxy. \r\n//   /// To prevent the implementation contract from being used, you should invoke the _disableInitializers function in the constructor to automatically lock it when it is deployed\r\n//   /// @custom:oz-upgrades-unsafe-allow constructor\r\n//   constructor() Ownable(msg.sender) {\r\n//       _disableInitializers();\r\n//   }\r\n\r\n//   function initialize(\r\n    \r\n//     /** address campaignOwner,\r\n//     /* address campaignFactory,\r\n//     /* address  _saletokenAddress, */\r\n//     /* address  _purchaseTokenAddress, */\r\n//     address[4] memory addresses,\r\n\r\n//     uint tokensOnSale,\r\n\r\n//     /** uint256 _normalizedTo18DecimalsSoftCap,\r\n//      * uint256 __normalizedTo18DecimalsHardCap,\r\n//      * uint256 _saleStartTime,\r\n//      * uint256 _saleEndTime, \r\n//      * uint256 _nomrlaizedTierOneHardCap, \r\n//      * uint256 _nomrlaizedTierTwoHardCap,\r\n//      * uint _minAllocationPerUser, \r\n//      * uint256 _maxAllocationPerUserTierOne, \r\n//      * uint256 _maxAllocationPerUserTierTwo ,\r\n//      * uint _campaignKey,*/\r\n//     uint256[10] memory capAndDate,  \r\n    \r\n//     // RefundType _refundType, \r\n//     address _dexRouterAddress,\r\n\r\n//     /**uint _liquidityPercent, \r\n//     /* uint liquidityReleaseTime,\r\n//     /* uint _listRate, \r\n//     /* uint _dexListRate,**/\r\n//     uint[4] memory liquidityAllocationAndRates,\r\n\r\n//     /**uint totalTeamTokensToBeVested, \r\n//     /* uint firstReleasePercent,  \r\n//     /* uint firstReleaseDays,\r\n//     /* uint subsequentReleasePercent, \r\n//     /* uint subsequentReleaseDays,,**/\r\n//     uint256[5] memory teamTokenVestingDetails,\r\n\r\n//     uint256[3] memory raisedFundVestingDetails,\r\n    \r\n//     // UseTeamTokenVesting,\r\n//     // UseRaisedFundVesting\r\n//     bool[2] memory _useTokenOrRaisedFundVesting,\r\n//     // VestSchedule[8] memory teamTokenVestingDetails, \r\n\r\n    \r\n//     string[6] memory founderInfo,\r\n//     DexLockerFactory dexLockerFactory \r\n//   ) public payable initializer {\r\n\r\n//     {\r\n//       // require(capAndDate[3] > capAndDate[2], \"Sale End time needs to be above start time\");\r\n//       // require(liquidityAllocationAndRates[0] >= 5100, \"Liquidity allowed is > 51 %\");\r\n//       if (capAndDate[3] <= capAndDate[2]) revert SaleEndTimeBeforeStartTime();\r\n//       if (liquidityAllocationAndRates[0] < 5100) revert LiquidityAboveLimit(5100);\r\n\r\n//       _campaignFactoryAddress= addresses[1];\r\n//       _setDefaultValues();\r\n//       campaignKey=capAndDate[9];\r\n      \r\n//       _dexLockerFactory=dexLockerFactory;\r\n//       purchaseTokenAddress=addresses[3]; \r\n//     }\r\n    \r\n      \r\n//     // //block scopin to avoid stack too deep \r\n//     {\r\n     \r\n//       saleInfo = CampaignSaleInfo({\r\n//         tokenAddress: addresses[2],\r\n//         softCap: capAndDate[0],\r\n//         hardCap: capAndDate[1],\r\n//         saleStartTime: capAndDate[2], \r\n//         saleEndTime: capAndDate[3],   \r\n//         liquidityPercent: liquidityAllocationAndRates[0],\r\n//         tokensOnSale: tokensOnSale,\r\n//         // refundType: _refundType, \r\n//         logoUrl: founderInfo[0],\r\n//         desc: founderInfo[1],\r\n//         website: founderInfo[2],\r\n//         twitter: founderInfo[3],\r\n//         telegram: founderInfo[4],\r\n//         discord: founderInfo[5]\r\n//       });\r\n\r\n//       dexRouterAddress=_dexRouterAddress; \r\n//     }        \r\n    \r\n    \r\n    \r\n//     { \r\n//           // _updateTierDetails(capAndDate[4], capAndDate[5], capAndDate[6],capAndDate[7], capAndDate[8]);\r\n//       _updateTierDetails(capAndDate);\r\n    \r\n\r\n//       _transferOwnership(addresses[0]);\r\n      \r\n\r\n//       _updateLockDetails(liquidityAllocationAndRates[1], _useTokenOrRaisedFundVesting[0], teamTokenVestingDetails,_useTokenOrRaisedFundVesting[1], raisedFundVestingDetails );\r\n//     }\r\n    \r\n//   }\r\n\r\n//   //needed since initializable contracts do not have constructors\r\n//   function _setDefaultValues() private {\r\n//     //status = CampaignStatus.CREATED;\r\n//     tier0TimeLineInHours = 3; // e.g 3 hours before startime\r\n//     tier1TimeLineInHours = 2; // e.g 2 hours before startime\r\n\r\n    \r\n//     ICampaignList cList = ICampaignList(_campaignFactoryAddress);\r\n//     zsalesPlatformDetails= PlatFormDetails({\r\n//       admin: cList.zsalesAdmin(), //zsales admin - can setkyc and audited\r\n//       zsalesTokenAddress : cList.zsalesTokenAddress(),\r\n//       zsaleFee : cList.zsaleFee(),  //2%   - percent of native currency to take\r\n//       zsaleTokenFee : cList.zsaleTokenFee(),  //2% - percent fee of token to take\r\n//       zsalesWalletAddress : cList.zsalesWalletAddress(), // receives commissions      \r\n//       zsalesNFTTokenAddress: cList.zsalesNFTTokenAddress()\r\n//     });\r\n//     // _admin= cList.zsalesAdmin(); //zsales admin - can setkyc and audited\r\n//     // zsalesTokenAddress = cList.zsalesTokenAddress();\r\n//     // zsaleFee = cList.zsaleFee();  //2%   - percent of native currency to take\r\n//     // zsaleTokenFee = cList.zsaleTokenFee();  //2% - percent fee of token to take\r\n//     // zsalesWalletAddress = cList.zsalesWalletAddress() ; // receives commissions\r\n    \r\n//     // zsalesNFTTokenAddress= cList.zsalesNFTTokenAddress();\r\n//   }\r\n  \r\n//   // function to update other details not initialized in constructor - this is bcos solidity limits how many variables u can pass in at once\r\n//   function _updateLockDetails(\r\n//     uint liquidityReleaseTimeDays, //Time to add to startTime in days\r\n//     bool _useTokenVesting,\r\n//     uint256[5] memory teamTokenVestingDetails,\r\n//     bool _useRaisedFundsVesting, \r\n//     uint256[3] memory raisedFundVestingDetails\r\n      \r\n//   ) private /*public onlyOwner*/ {\r\n//     liquidityReleaseInDays  = liquidityReleaseTimeDays;\r\n//     useTokenVesting=_useTokenVesting;\r\n//     useRaisedFundsVesting=_useRaisedFundsVesting;\r\n\r\n    \r\n//     //Set dexLock\r\n//     _dexLocker = IDexLocker(payable(_dexLockerFactory.createDexLocker(dexRouterAddress,saleInfo.tokenAddress, purchaseTokenAddress, address(this), msg.sender) ) );\r\n    \r\n    \r\n//     _dexLocker.setupLock([saleInfo.softCap,saleInfo.hardCap],  [uint256(0),uint256(0)],useTokenVesting, teamTokenVestingDetails, _useRaisedFundsVesting,  raisedFundVestingDetails);\r\n    \r\n//     status = CampaignStatus.CREATED;\r\n//     totalTeamTokensToBeVested = teamTokenVestingDetails[0];\r\n    \r\n\r\n//     // //if doesnt use tokenvesting , _startReceivingBids();\r\n//     // if(!useTokenVesting){\r\n//     //   _startReceivingBids();\r\n//     // }\r\n\r\n    \r\n\r\n//   }\r\n  \r\n//   function _updateCampaignFounderDetails(\r\n//     string memory logoUrl,\r\n//     string memory desc,\r\n//     string memory website,\r\n//     string memory twitter,\r\n//     string memory telegram,\r\n//     string memory discord\r\n//   ) private {\r\n//     saleInfo.logoUrl= logoUrl;\r\n//     saleInfo.desc= desc;\r\n//     saleInfo.website= website;\r\n//     saleInfo.twitter= twitter;\r\n//     saleInfo.telegram= telegram;\r\n//     saleInfo.discord= discord;\r\n//   }\r\n\r\n//   function updateCampaignFounderDetails(\r\n//     string memory logoUrl,\r\n//     string memory desc,\r\n//     string memory website,\r\n//     string memory twitter,\r\n//     string memory telegram,\r\n//     string memory discord\r\n//   ) external onlyOwner {       \r\n//     if (block.timestamp > saleInfo.saleStartTime) revert UpdateAfterSaleStartTime();\r\n//     _updateCampaignFounderDetails(logoUrl,desc,website,twitter,telegram,discord);\r\n//   }\r\n\r\n//   function _updateTierDetails(uint256[10] memory capAndDate) private {\r\n    \r\n//     _updateTierDetails(capAndDate[4], capAndDate[5], capAndDate[6],capAndDate[7], capAndDate[8]);\r\n//   }\r\n    \r\n//   // function to update the tiers users value manually\r\n//   function _updateTierDetails(uint256 _tierOneHardCap, uint256 _tierTwoHardCap, uint256 _minAllocationPerUser, uint256 _maxAllocationPerUserTierOne, uint256 _maxAllocationPerUserTierTwo) private {\r\n    \r\n//     tokenDecimals = IERC20Metadata(saleInfo.tokenAddress).decimals();\r\n//     purchaseCoinDecimals=18;\r\n//     if(purchaseTokenAddress!=address(0)){\r\n//       purchaseCoinDecimals = IERC20Metadata(purchaseTokenAddress).decimals();\r\n//     }\r\n    \r\n//     if (_tierOneHardCap < saleInfo.hardCap * 2500 / 10000) revert TierCapTooLow(25);\r\n//     // if (_tierOneHardCap + _tierTwoHardCap != saleInfo.hardCap) revert TierCapsExceedHardCap();\r\n//     if (_tierOneHardCap > saleInfo.hardCap) revert TierOneCapExceedsHardCap();\r\n//     if (_tierTwoHardCap > saleInfo.hardCap) revert TierTwoCapExceedsHardCap();\r\n\r\n//     if (_minAllocationPerUser < 0) revert MinAllocationOutOfRange();\r\n//     if (_maxAllocationPerUserTierOne <= 0) revert TierOneMaxAllocationOutOfRange();\r\n//     if (_maxAllocationPerUserTierTwo <= 0) revert TierTwoMaxAllocationOutOfRange();\r\n    \r\n    \r\n//     tierZerohardCap = _tierOneHardCap;\r\n//     tierOnehardCap =_tierOneHardCap;\r\n//     tierTwohardCap = _tierTwoHardCap;    \r\n    \r\n//     minAllocationPerUser=_minAllocationPerUser; \r\n//     maxAllocationPerUserTierZero = _maxAllocationPerUserTierOne;//same alloc for tier 0 and 1\r\n//     maxAllocationPerUserTierOne = _maxAllocationPerUserTierOne;\r\n//     maxAllocationPerUserTierTwo = _maxAllocationPerUserTierTwo;\r\n//   }\r\n\r\n//   function updateTierDetails(uint256 _tierOneHardCap, uint256 _tierTwoHardCap, uint256 _minAllocationPerUser, uint256 _maxAllocationPerUserTierOne, uint256 _maxAllocationPerUserTierTwo) public onlyOwner {\r\n    \r\n//     if(block.timestamp > saleInfo.saleStartTime){\r\n//       revert UpdateAfterSaleStartTime();\r\n//     }\r\n//     _updateTierDetails(_tierOneHardCap, _tierTwoHardCap, _minAllocationPerUser, _maxAllocationPerUserTierOne, _maxAllocationPerUserTierTwo);    \r\n//   }\r\n\r\n//   function _startReceivingBids() private \r\n//   {    \r\n//     status = CampaignStatus.TOKENS_SUBMITTED;\r\n//   }\r\n\r\n//   function startReceivingBids() public {\r\n//     if (_campaignFactoryAddress != _msgSender()) revert NotOwner();\r\n//     _startReceivingBids();\r\n//   }\r\n\r\n//   function cancelCampaign() public onlyOwner {\r\n//       if (block.timestamp >= saleInfo.saleStartTime) revert CannotCancelAfterSaleStartTime();\r\n//       status = CampaignStatus.CANCELLED;\r\n//   }\r\n\r\n//   function calcFairLaunchRate() public view returns (uint256 tokenRate) {\r\n//     uint256 balance = purchaseTokenAddress==address(0) ? (address(this).balance) : IERC20(purchaseTokenAddress).balanceOf(address(this));\r\n//     tokenRate = 10 ** 18 / balance * saleInfo.tokensOnSale;\r\n//   }\r\n\r\n//   function postponeSale(uint newDate, uint newEndDate) public onlyOwner {\r\n//       if (block.timestamp >= saleInfo.saleStartTime) revert PostponeBeforeSaleStartTime();\r\n//       if (newDate <= saleInfo.saleStartTime) revert NewDateLessThanOldDate();\r\n//       if (newEndDate <= newDate) revert EndDateLessThanStartTime();\r\n\r\n//       saleInfo.saleStartTime = newDate;\r\n//       saleInfo.saleEndTime = newEndDate;\r\n//   }\r\n\r\n//   function getDexListRate() public view returns (uint256) {\r\n//     return 0;\r\n//   }\r\n\r\n//   function getEndDate() public view returns (uint256) {\r\n//     return saleInfo.saleEndTime;\r\n//   }\r\n\r\n//   function totalTokensExpectedToBeLocked() public view returns (uint256) {\r\n//     //Amount for sale + amount for liquidity\r\n//     uint tokensForLiquidity = (saleInfo.tokensOnSale * saleInfo.liquidityPercent )  / 10000;\r\n//     return tokensForLiquidity ;// + _dexLocker.totalTokensExpectedToBeLocked();\r\n//   }\r\n\r\n \r\n//   function setZSalesTokenAddress(address _tokenAddress) public onlyAdmin {\r\n//     zsalesPlatformDetails.zsalesTokenAddress = _tokenAddress;\r\n//   }\r\n\r\n\r\n//   /**************************|\r\n//   |          Tier Info       |\r\n//   |_________________________*/\r\n//   //add the address in Whitelist tier two to invest\r\n//   function disableTier2Whitelist() public onlyOwner {    \r\n//     useWhiteList= false;\r\n//   }\r\n\r\n//   //add the address in Whitelist tier two to invest\r\n//   function submitTier2Whitelist(bytes32 whitelistMerkleRoot) public onlyOwner {\r\n    \r\n//     if (block.timestamp >= saleInfo.saleStartTime) revert AlterWhitelistingAfterSaleStartTime();\r\n//     useWhiteList= true;\r\n//     _whitelistTierTwoMerkleRoot=whitelistMerkleRoot;\r\n//   }\r\n\r\n//   // check the address is a Token Holder\r\n//   function isAllowedInTier1(address _address) public view returns(bool) {\r\n\r\n//     IERC20 token = IERC20(zsalesPlatformDetails.zsalesTokenAddress);\r\n//     return token.balanceOf(_address) > 0;\r\n//   }\r\n\r\n//   // check the address is a NFT Token Holder\r\n//   function isAllowedInTier0(address _address) public view returns(bool) {\r\n\r\n//     uint maxTiersToCheck= 5;\r\n//     IERC1155 token = IERC1155(zsalesPlatformDetails.zsalesNFTTokenAddress);\r\n//     address[] memory addresses=new address[](maxTiersToCheck);\r\n//     addresses[0]=_address;\r\n\r\n//     uint[] memory tokenIds=new uint[](maxTiersToCheck);\r\n    \r\n//     for (uint256 i = 0; i < maxTiersToCheck; i++) {\r\n//         tokenIds[i]=i;\r\n//     }\r\n\r\n//     uint[] memory balances = token.balanceOfBatch(addresses,tokenIds) ;\r\n//     uint balance = 0;\r\n//     for (uint256 i = 0; i < maxTiersToCheck; i++) {\r\n//         balance += balances[i];\r\n//     }\r\n//     return balance>0;\r\n//   }\r\n\r\n\r\n//   // check the address in whitelist tier two\r\n//   function isInTier2WhiteList(bytes32[] memory proof, address claimer) public view returns(bool) {\r\n    \r\n//     bytes32 _leaf = keccak256(abi.encodePacked(claimer));\r\n//     return MerkleProof.verify(proof, _whitelistTierTwoMerkleRoot, _leaf);\r\n    \r\n//   }\r\n\r\n//   /**\r\n//     * @dev Throws if called by any account other than the owner.\r\n//   */\r\n//   modifier onlyAdmin() {\r\n//       require(zsalesPlatformDetails.admin == _msgSender(), NotAdmin() );\r\n//       _;\r\n//   }\r\n\r\n//   function changeAdmin(address newAdmin) public onlyAdmin  {\r\n//       // require(_msgSender() == _admin, 'ADMIN: Only Admin can change');\r\n//       if(_msgSender() != zsalesPlatformDetails.admin) revert NotAdmin();\r\n//       address oldOwner = zsalesPlatformDetails.admin;\r\n//       zsalesPlatformDetails.admin=newAdmin;\r\n\r\n//       emit AdminOwnershipTransferred(oldOwner, newAdmin);\r\n//   }\r\n\r\n  \r\n//   function getHardCap() public view returns (uint) {\r\n//     return saleInfo.hardCap;\r\n//   }\r\n\r\n//   /**************************|\r\n//   |          Setters         |\r\n//   |_________________________*/\r\n  \r\n//   function setKYC(bool kyc) public onlyAdmin {\r\n//     if (block.timestamp >= saleInfo.saleStartTime) revert KYCAfterSaleStartTime();\r\n//     hasKYC = kyc;\r\n//   } \r\n\r\n//   function setAudited(bool audit) public onlyAdmin {\r\n//       if (block.timestamp >= saleInfo.saleStartTime) revert AuditAfterSaleStartTime();\r\n//       _isAudited = audit;\r\n//   }\r\n//   function setTier1TimeLineInHours (uint newValue) public onlyAdmin {\r\n//     tier1TimeLineInHours=newValue;\r\n//   }\r\n//   function isAudited() public view returns (bool, string memory ) {\r\n//     return (_isAudited, auditUrl);\r\n//   }\r\n\r\n\r\n//   /**\r\n//     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n//     * `recipient`, forwarding all available gas and reverting on errors.\r\n//     *\r\n//     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n//     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n//     * imposed by `transfer`, making them unable to receive funds via\r\n//     * `transfer`. {sendValue} removes this limitation.\r\n//     *\r\n//     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n//     *\r\n//     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n//     * taken to not create reentrancy vulnerabilities. Consider using\r\n//     * {ReentrancyGuard} or the\r\n//     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n//     */\r\n//   function sendValue(address recipient, uint256 amount) internal {\r\n//       require(address(this).balance >= amount, InsufficientBalance());\r\n\r\n//       // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n//       (bool success, ) = recipient.call{ value: amount }(\"\");\r\n//       require(success, NoSendValue());//Address: unable to send value, recipient may have reverted\r\n//   }\r\n  \r\n  \r\n//   // send coin to the contract address\r\n//   function submitBid(bytes32[] calldata proof, uint256 purchasedAmount) public payable nonReentrant  {\r\n    \r\n//     uint256 normalizedBid ;\r\n//     if(purchaseTokenAddress==address(0)){\r\n//       normalizedBid= msg.value;\r\n//     }else{\r\n//       normalizedBid= purchasedAmount * 10**(18-purchaseCoinDecimals);//normalize\r\n//       IERC20(purchaseTokenAddress).safeTransferFrom(msg.sender, address(this), purchasedAmount);\r\n//     }\r\n    \r\n    \r\n//     if (status == CampaignStatus.CANCELLED) revert SaleCancelled();\r\n//     if (status == CampaignStatus.FAILED) revert SaleFailed();\r\n//     if (status != CampaignStatus.TOKENS_SUBMITTED) revert NotTokenSubmitted();\r\n//     if (totalCoinReceived >= saleInfo.hardCap) revert SoldOutError();\r\n//     if (block.timestamp > saleInfo.saleEndTime) revert ClosedSale();\r\n//     if (totalCoinReceived + normalizedBid > saleInfo.hardCap) revert ExceedMaxCap();\r\n//     if (normalizedBid < minAllocationPerUser) revert LessThanMinBuy();\r\n    \r\n          \r\n//     address sender = _msgSender();\r\n//     if (block.timestamp >= saleInfo.saleStartTime) {\r\n//         if (useWhiteList) {\r\n//             if (!isInTier2WhiteList(proof, sender)) revert NotInTier2Whitelist();\r\n//         }\r\n//         if (totalCoinInTierTwo + normalizedBid > tierTwohardCap) revert ExceedTierTwoMaxCap();\r\n//         if (buyInTwoTier[sender] + normalizedBid > maxAllocationPerUserTierTwo) revert ExceedTierTwoUserLimit();\r\n//         buyInTwoTier[sender] += normalizedBid;\r\n//         buyInAllTiers[sender] += normalizedBid;\r\n//         totalCoinReceived += normalizedBid;\r\n//         totalCoinInTierTwo += normalizedBid;\r\n//         totalParticipants++;\r\n\r\n//         emit ValueReceived(sender, purchasedAmount);\r\n//     } else if (ICampaignList(_campaignFactoryAddress).getTierStatus(0) && block.timestamp >= saleInfo.saleStartTime - (tier0TimeLineInHours * 1 hours)) {  \r\n//         if (!isAllowedInTier0(sender)) revert NotInTier0();\r\n//         if (totalCoinInTierZero + normalizedBid > tierZerohardCap) revert ExceedTierZeroMaxCap();\r\n//         if (buyInZeroTier[sender] + normalizedBid > maxAllocationPerUserTierZero) revert ExceedTierZeroUserLimit();\r\n//         buyInZeroTier[sender] += normalizedBid;\r\n//         buyInAllTiers[sender] += normalizedBid;\r\n//         totalCoinReceived += normalizedBid;\r\n//         totalCoinInTierZero += normalizedBid;\r\n//         totalParticipants++;\r\n\r\n//         emit ValueReceived(sender, purchasedAmount);\r\n//     } else if (ICampaignList(_campaignFactoryAddress).getTierStatus(1) && block.timestamp >= saleInfo.saleStartTime - (tier1TimeLineInHours * 1 hours)) {  \r\n//         if (!isAllowedInTier1(sender)) revert NotInTier1();\r\n//         if (totalCoinInTierOne + normalizedBid > tierOnehardCap) revert ExceedTierOneMaxCap();\r\n//         if (buyInOneTier[sender] + normalizedBid > maxAllocationPerUserTierOne) revert ExceedTierOneUserLimit();\r\n//         buyInOneTier[sender] += normalizedBid;\r\n//         buyInAllTiers[sender] += normalizedBid;\r\n//         totalCoinReceived += normalizedBid;\r\n//         totalCoinInTierOne += normalizedBid;\r\n//         totalParticipants++;\r\n\r\n//         emit ValueReceived(sender, purchasedAmount);\r\n//     } else {\r\n//         revert SaleNotStarted();\r\n//     }\r\n\r\n    \r\n\r\n//     // return '';\r\n//   }\r\n\r\n//   /**\r\n//   * @dev Withdraw tokens or coin by user after end time\r\n//   * If this project does not reach softcap, return their funds otherwise get tokens \r\n//   */\r\n//   function withdrawFunds() public {\r\n//     address usr = _msgSender();\r\n\r\n//     if (usr == owner()) revert OwnersCannotWithdraw();\r\n    \r\n//     // if campaign is sold out no need to wait for endtime finalize and setup liquidity\r\n//     if (block.timestamp < saleInfo.saleEndTime && totalCoinReceived < saleInfo.softCap) revert OngoingSales();\r\n    \r\n//     if (buyInAllTiers[usr] == 0) revert NoCoinsToClaim();\r\n\r\n//     // if (totalCoinReceived < saleInfo.softCap) {\r\n//     //     status = CampaignStatus.FAILED;\r\n//     // }\r\n\r\n//     uint256 amount = buyInAllTiers[usr];\r\n//     buyInAllTiers[usr] = 0;\r\n    \r\n\r\n//     if (status == CampaignStatus.FAILED) {\r\n//       // return back funds\r\n//       if(purchaseTokenAddress==address(0)){\r\n//         payable(usr).transfer(amount);\r\n//       }else{\r\n//         IERC20(purchaseTokenAddress).safeTransfer(usr, amount/10**(18-purchaseCoinDecimals));\r\n//       }          \r\n//       emit Refunded(usr, amount/10**(18-purchaseCoinDecimals));\r\n//     } else {\r\n//         uint256 amountTokens = amount * calcFairLaunchRate();\r\n//         IERC20 _token = IERC20(saleInfo.tokenAddress);\r\n//         // Transfer Tokens to User\r\n//         _token.safeTransfer(usr, amountTokens/10**(18-tokenDecimals));\r\n\r\n//         emit Withdrawn(usr, amountTokens/10**(18-tokenDecimals));\r\n//     }    \r\n//   }\r\n\r\n//   /**\r\n//   * @dev Withdraw owner tokens If this project does not reach softcap\r\n//   */\r\n \r\n\r\n//   function withdrawOwnerTokens() public onlyOwner {\r\n//       if (status != CampaignStatus.FAILED && status != CampaignStatus.CANCELLED && status != CampaignStatus.LIQUIDITY_SETUP) revert RequireCancelorFail();\r\n//       if (block.timestamp < saleInfo.saleEndTime) revert NotEndDate();\r\n//       if(ownerHasWithdrawnTokens) revert OwnerHasWithdrawnAlready();\r\n\r\n//       if(totalCoinReceived < saleInfo.softCap){\r\n//         status= CampaignStatus.FAILED;\r\n//       }\r\n\r\n//       IERC20 _token = IERC20(saleInfo.tokenAddress);\r\n//       //if (totalCoinReceived >= saleInfo.softCap ) revert AlreadyReachedSoftCap(saleInfo.softCap);\r\n//       if(status == CampaignStatus.FAILED || status == CampaignStatus.CANCELLED){\r\n        \r\n//         uint256 tokensAmount = _token.balanceOf(address(this));\r\n\r\n//         if (tokensAmount == 0) revert NoTokens();\r\n//         ownerHasWithdrawnTokens=true;\r\n//         _token.safeTransfer(msg.sender, tokensAmount);\r\n\r\n\r\n//       }else if(status == CampaignStatus.LIQUIDITY_SETUP){\r\n//         // // Todo\r\n//         // uint tokensForUsers = saleInfo.tokensOnSale ;\r\n//         // uint tokensForLiquidity = tokensForUsers *  saleInfo.liquidityPercent/10000;\r\n//         // uint tokensForFees =zsalesPlatformDetails.zsaleTokenFee * tokensForUsers / 10000;\r\n\r\n//         // uint withdrawableTokens  = (tokensForLiquidity + tokensForUsers + tokensForFees )/ 10**(18-tokenDecimals);\r\n//         // ownerHasWithdrawnTokens=true;\r\n\r\n//         // _token.safeTransfer(msg.sender, withdrawableTokens);\r\n//         uint256 tokensAmount = _token.balanceOf(address(this));\r\n\r\n//         if (tokensAmount == 0) revert NoTokens();\r\n//         ownerHasWithdrawnTokens=true;\r\n//         _token.safeTransfer(msg.sender, tokensAmount);\r\n//       }\r\n      \r\n//   }\r\n\r\n  \r\n  \r\n\r\n//   /**\r\n//     * Setup liquidity and transfer all amounts according to defined percents, if softcap not reached set Refunded flag\r\n//     */\r\n//   function finalizeAndSetupLiquidity() public nonReentrant {\r\n    \r\n//     require (totalCoinReceived >= saleInfo.hardCap || block.timestamp > saleInfo.saleEndTime, NoSoldOutOrEndDate());\r\n//     if (status == CampaignStatus.FAILED) revert CampaignFailed();\r\n//     if (status == CampaignStatus.CANCELLED) revert CampaignCancelled();\r\n//     if (status == CampaignStatus.LIQUIDITY_SETUP) revert LiquiditySetupAlreadyDone();\r\n//     //\r\n//     if(totalCoinReceived < saleInfo.softCap){ // set to failed and stop\r\n//         status= CampaignStatus.FAILED ;\r\n//         return;\r\n//     }\r\n\r\n    \r\n//     IERC20 tokenOnSale = IERC20(saleInfo.tokenAddress);\r\n\r\n//     // Total amount invested\r\n//     uint256 currentCoinBalance = address(this).balance;\r\n//     if(purchaseTokenAddress!=address(0)){\r\n//       currentCoinBalance = IERC20(purchaseTokenAddress).balanceOf(address(this));\r\n//     }\r\n\r\n//     if(currentCoinBalance<=0 || (totalCoinReceived/ 10**(18-purchaseCoinDecimals)) > currentCoinBalance ){\r\n//        revert NoCoin();\r\n//     }\r\n    \r\n\r\n//     uint256 zsaleFeeAmount = (totalCoinReceived * zsalesPlatformDetails.zsaleFee / 10000) / 10**(18-purchaseCoinDecimals);\r\n    \r\n//     uint256 sold_tokens_amount = calcFairLaunchRate() * totalCoinReceived / 10 ** (18 - tokenDecimals);\r\n//     uint256 zsaleTokenFeeAmount = (sold_tokens_amount * zsalesPlatformDetails.zsaleTokenFee/ 10000); // /10**(18 -tokenDecimals);\r\n    \r\n//     //Fees charged in Purchase coin\r\n//     if(purchaseTokenAddress==address(0)){\r\n//       payable(zsalesPlatformDetails.zsalesWalletAddress).transfer(zsaleFeeAmount);\r\n//     }else{\r\n//       IERC20(purchaseTokenAddress).safeTransfer(zsalesPlatformDetails.zsalesWalletAddress, zsaleFeeAmount);\r\n//     }\r\n//     // //Fee charged in Token listed, \r\n//     tokenOnSale.safeTransfer(zsalesPlatformDetails.zsalesWalletAddress, zsaleTokenFeeAmount);\r\n\r\n\r\n//     uint256 supplyAfterFees = purchaseTokenAddress==address(0) ? address(this).balance : IERC20(purchaseTokenAddress).balanceOf(address(this));\r\n//     //Amount of Token to be sent to dex\r\n//     if(purchaseTokenAddress!=address(0)){\r\n//       supplyAfterFees = supplyAfterFees * (10 ** (18 - purchaseCoinDecimals));\r\n//     }\r\n    \r\n//     uint256 tokensBalance =  tokenOnSale.balanceOf(address(this)) * (10 ** (18 - tokenDecimals));\r\n//     // Amount to be sent to dex\r\n//     uint256 liquidityAmount = (supplyAfterFees * saleInfo.liquidityPercent) / 10000;\r\n//     if(tokensBalance < liquidityAmount * calcFairLaunchRate() ) revert NoTokensForLiquidity();\r\n\r\n//     uint256 tokensForLiquidity = liquidityAmount * calcFairLaunchRate() / (10 ** (18 - tokenDecimals)); \r\n//     bool approvalSucess = tokenOnSale.approve(dexRouterAddress, tokensForLiquidity);\r\n//     require(approvalSucess == true, RouterApprovalFailed());\r\n\r\n    \r\n//     IDexRouter _dexRouter=IDexRouter(dexRouterAddress);\r\n//     if(purchaseTokenAddress==address(0)){\r\n      \r\n//       _dexRouter.addLiquidityETH{value: liquidityAmount}(\r\n//             saleInfo.tokenAddress,\r\n//             tokensForLiquidity,\r\n//             0, // tokensForLiquidity,\r\n//             0, //liquidityAmount,\r\n//             address(this),\r\n//             block.timestamp + 100\r\n//       );\r\n      \r\n//       emit LiquidityAddedToRouter(dexRouterAddress, address(0),saleInfo.tokenAddress,liquidityAmount,tokensForLiquidity  );\r\n\r\n//     }else{\r\n      \r\n//       tokenOnSale.approve(dexRouterAddress, MAX_INT);\r\n      \r\n//       IERC20(purchaseTokenAddress).approve(dexRouterAddress, MAX_INT);\r\n//       _dexRouter.addLiquidity(\r\n//           address(tokenOnSale),\r\n//           purchaseTokenAddress,\r\n//           tokensForLiquidity,\r\n//           liquidityAmount/(10** (18-purchaseCoinDecimals)),\r\n//           0,\r\n//           0,            \r\n//           address(this),\r\n//           block.timestamp + 100\r\n//       );\r\n//       emit LiquidityAddedToRouter(dexRouterAddress, purchaseTokenAddress,address(tokenOnSale),liquidityAmount,tokensForLiquidity  );\r\n\r\n//     }\r\n\r\n        \r\n//     // get lp address from factory\r\n//     IDexFactory _dexFactory = IDexFactory(_dexRouter.factory());\r\n//     liquidityPairAddress = _dexFactory.getPair(saleInfo.tokenAddress, purchaseTokenAddress==address(0)?_dexRouter.WETH(): purchaseTokenAddress );\r\n//     uint lpPairbalance=IERC20(liquidityPairAddress).balanceOf(address(this));\r\n//     liquidityPairLockerAddress = _dexLocker.lockERC20(liquidityPairAddress, owner(),lpPairbalance, 100,liquidityReleaseInDays,0,0);// address(tokenLocker);\r\n    \r\n//     IERC20(liquidityPairAddress).safeTransfer(liquidityPairLockerAddress, lpPairbalance);\r\n\r\n//     uint256 balanceAfterLiquidityAndFees = purchaseTokenAddress==address(0) ? address(this).balance : IERC20(purchaseTokenAddress).balanceOf(address(this));\r\n//     if(useRaisedFundsVesting){\r\n//       //send raised funds to Lock\r\n//       // Remainder after all dedeuctions and liquidity\r\n//       if(purchaseTokenAddress==address(0)){\r\n        \r\n//         _dexLocker.startRaisedFundsLock{value: (_dexLocker.raisedFundsPercent() * balanceAfterLiquidityAndFees) / 10000 }( balanceAfterLiquidityAndFees );\r\n        \r\n//       }else{\r\n//         IERC20(purchaseTokenAddress).safeTransfer(address(_dexLocker),(_dexLocker.raisedFundsPercent() * balanceAfterLiquidityAndFees) / 10000);\r\n//         _dexLocker.startRaisedFundsLock( balanceAfterLiquidityAndFees );\r\n//       }\r\n//     }  \r\n\r\n//     // Send Balance to Owner\r\n//     if(purchaseTokenAddress==address(0)){\r\n//       sendValue(owner(),address(this).balance);      \r\n//     }else{\r\n//       IERC20(purchaseTokenAddress).safeTransfer(owner(),IERC20(purchaseTokenAddress).balanceOf(address(this)) );\r\n      \r\n//     }  \r\n    \r\n//     status=CampaignStatus.LIQUIDITY_SETUP;\r\n//   }\r\n\r\n  \r\n//   function getCampaignInfo() public view returns( uint256 softcap, uint256 hardcap,uint256 saleStartTime, uint256 saleEndTime,uint256 listRate, uint256 dexListRate,uint tokensOnSale, uint liquidity,uint _liquidityReleaseTime ,uint256 totalCoins, uint256 totalParticipant, bool use_WhiteList, bool hasKyc, bool isAuditd, string memory _auditUrl ){\r\n//       return ( saleInfo.softCap, MAX_INT,saleInfo.saleStartTime, saleInfo.saleEndTime, 0, 0,saleInfo.tokensOnSale, saleInfo.liquidityPercent, liquidityReleaseInDays, totalCoinReceived,totalParticipants, useWhiteList,hasKYC, _isAudited, auditUrl );\r\n//   }\r\n\r\n  \r\n\r\n//   function getCampaignStatus() public view returns(CampaignStatus ){\r\n//       return status ;\r\n//   }\r\n\r\n//   function getCampaignPeriod() public view returns(uint256 saleStartTime, uint256 saleEndTime ){\r\n//       return (saleInfo.saleStartTime, saleInfo.saleEndTime );\r\n//   }\r\n\r\n//   function getCampaignSalePriceInfo() public view returns(uint256 , uint256,uint256 , uint256,uint256 , uint256,uint256 ){\r\n//       return (0, 0, saleInfo.softCap, saleInfo.hardCap, tierOnehardCap,tierTwohardCap, maxAllocationPerUserTierTwo  );\r\n//   }\r\n\r\n//   /**\r\n//     * \r\n//     */\r\n//   function isSoldOut() public view returns (bool) {\r\n//       return totalCoinReceived>= saleInfo.hardCap;\r\n//   }\r\n\r\n//     /**\r\n//     * \r\n//     */\r\n//   function hasFailed() public view returns (bool) {\r\n//       return status == CampaignStatus.FAILED;\r\n//   }\r\n\r\n  \r\n//   function dexLockerAddress() public view onlyAdmin returns (address) {\r\n//       return address( _dexLocker);\r\n//   }\r\n\r\n//   function tokenAddress() public view returns (address) {\r\n//       return saleInfo.tokenAddress;\r\n//   }\r\n\r\n//   // Refund any mistakenly sent in ERC20\r\n//   function refundERC20(IERC20 _token, address recipient, uint256 amount) public onlyAdmin {      \r\n//     _token.safeTransfer(recipient, amount);\r\n//   }\r\n\r\n// }"
    },
    "contracts/IDexRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface IDexRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    \r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external  returns (uint amountA, uint amountB, uint liquidity) ;\r\n\r\n\r\n\t\r\n    \r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\t\r\n\t\r\n\tfunction swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\t\r\n\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n\t// Identical to swapExactTokensForTokens, but succeeds for tokens that take a fee on transfer.\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    \r\n}\r\n\r\ninterface IDexFactory {\r\n    function getPair(address token0, address token1) external view returns (address);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n"
    },
    "contracts/Interfaces/Turnstile.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface Turnstile {\r\n    function register(address) external returns(uint256);\r\n}"
    },
    "contracts/Lockers/DexLocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\n\r\nimport \"./VestSchedule.sol\";\r\nimport \"./TokenLocker.sol\";\r\nimport \"../Errors.sol\";\r\n\r\nimport \"./PurchasedCoinVestingVault.sol\";\r\n// import \"./LiquidityLocker.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\nerror NotEnoughCoinsForRaisedFundsLock();\r\nerror LiquidityAmountTransferFailed();\r\n\r\n/// @title IDexLocker\r\n/// @notice Manages liquidity and vesting for tokens raised in sales campaigns\r\ninterface IDexLocker {\r\n    function initialize(\r\n        // address dexRouterAddress,\r\n        address token,\r\n        address purchaseToken,\r\n        address deployer,\r\n        address owner,\r\n        address purchasedCoinVestingVaultImplementationAddress\r\n    ) external;\r\n\r\n    function setupLock(\r\n        \r\n        // uint minRaisedFunds,uint maxRaisedFunds, \r\n        uint[2] calldata raisedFunds,\r\n        // bool isFairLaunch, \r\n        // uint256 saleListPrice,  uint256 dexListPrice, \r\n        uint256[2] calldata saleAndDexRates,\r\n\r\n        bool useTeamTokenVesting, \r\n        uint256[5] calldata teamTokenVestingDetails, \r\n        bool useRaisedFundsVesting, \r\n        uint256[3] calldata raisedFundVestingDetails \r\n    ) external;\r\n\r\n     \r\n     /// @dev If campaign Locks raised fund, lock the calculated amount\r\n     ///\r\n    function startRaisedFundsLock(uint256 raisedAmountAfterAllDeductions) external payable;\r\n\r\n    function lockERC20(address tokenAddress,address tokenOwner, uint totalTokens, uint firstReleasePercent, uint firstReleaseDays, \r\n        uint subsequentReleasePercent, uint subsequentReleaseDays ) external returns(address lockerAddress);\r\n\r\n    function getOwner() external view returns (address);\r\n\r\n    function releaseTeamTokens() external;\r\n\r\n    function releaseCoinVaultETH() external;\r\n\r\n    function raisedFundsVaultAddress() external view returns (address);\r\n\r\n    function raisedFundsPercent() external view returns (uint);\r\n\r\n    function tokenLockerAddress() external view returns (address);\r\n\r\n    // function liquidityLockerAddress() external view returns (address);\r\n\r\n    // function totalTokensExpectedToBeLocked() external view returns(uint);\r\n}\r\n\r\n/// @title DexLocker\r\n/// @notice Manages vesting for tokens raised in sales campaigns, LP TOkens and Team Vesting tokens\r\ncontract DexLocker is Initializable, IDexLocker{\r\n    error DLOnlyDeployer();\r\n    error DLReleaseBeforeTime();\r\n    error TokenCannotBeAddressZero();\r\n    using SafeERC20 for IERC20;\r\n\r\n    event ERC20LockCreated(address indexed lockerAddress, address indexed token, address indexed owner, uint totalTokensLocked);\r\n    \r\n    address private _owner;\r\n\r\n    address private _deployer;\r\n\r\n    uint256 constant private MAX_INT = 2**256 - 1;\r\n\r\n    // uint public totalTokensExpectedToBeLocked;\r\n\r\n    address private _token;\r\n    address private _purchaseToken;\r\n\r\n    TokenLocker private _teamTokensLocker;\r\n    PurchasedCoinVestingVault private _purchasedCoinVestingVault;\r\n    // LiquidityLocker private _liquidityLocker;\r\n    // uint private _liquidityPercentOfRaisedFunds;\r\n\r\n    /**\r\n    Maps to \r\n    \r\n        uint256 _percentOfRaisedFundsToLock,\r\n        uint256 _vestingDurationInDays,\r\n        uint256 _vestingCliffInDays\r\n     */\r\n    uint256[3] _raisedFundVestingDetails;\r\n    bool _useRaisedFundsVesting;\r\n\r\n    address  _purchasedCoinVestingVaultImplementationAddress;\r\n\r\n    ///Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be taken over by an attacker, which may impact the proxy. \r\n    /// To prevent the implementation contract from being used, you should invoke the _disableInitializers function in the constructor to automatically lock it when it is deployed\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    function initialize( address token, address purchaseToken,address deployer,address owner, address purchasedCoinVestingVaultImplementationAddress ) public initializer  {\r\n        require(token != address(0), InvalidSalesTokenAddress(token));\r\n        require(deployer != address(0), InvalidDeployerAddress(deployer));\r\n        require(owner != address(0), InvalidOwnerAddress(owner));\r\n\r\n        \r\n        _deployer = deployer; //msg.sender;\r\n        \r\n        _owner = owner;\r\n        _token = token; \r\n        _purchaseToken=purchaseToken;\r\n        _purchasedCoinVestingVaultImplementationAddress=purchasedCoinVestingVaultImplementationAddress;       \r\n    }\r\n\r\n    \r\n    function setupLock(\r\n        // uint minRaisedFunds,uint maxRaisedFunds, \r\n        uint[2] calldata raisedFunds,  \r\n        // bool isFairLaunch,      \r\n        // uint256 saleListPrice,  uint256 dexListPrice, \r\n        uint256[2] calldata saleAndDexRates,\r\n        bool useTeamTokenVesting, \r\n        uint256[5] calldata teamTokenVestingDetails, \r\n        bool useRaisedFundsVesting, \r\n        uint256[3] calldata raisedFundVestingDetails \r\n    ) public {\r\n        \r\n        require(msg.sender == _deployer, DLOnlyDeployer());        \r\n\r\n        // totalTokensExpectedToBeLocked = 0;\r\n        \r\n        // if(!isFairLaunch){\r\n        //     //Sold tokens\r\n        //     totalTokensExpectedToBeLocked += saleAndDexRates[0] * raisedFunds[1];\r\n        // }\r\n        \r\n        if(useTeamTokenVesting){\r\n            \r\n            _teamTokensLocker = new TokenLocker(_token, _owner,teamTokenVestingDetails[0],teamTokenVestingDetails[1],teamTokenVestingDetails[2],teamTokenVestingDetails[3],teamTokenVestingDetails[4] );\r\n            //totalTokensExpectedToBeLocked += normalizeTokenAmount(teamTokenVestingDetails[0], IERC20Metadata(_token).decimals());\r\n        }\r\n        \r\n\r\n        _useRaisedFundsVesting=useRaisedFundsVesting;\r\n        if(_useRaisedFundsVesting){\r\n            for (uint8 i=0; i < 3 ; i++) {\r\n                _raisedFundVestingDetails[i] = raisedFundVestingDetails[i]; \r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n     * Raised funds\r\n     */\r\n    function startRaisedFundsLock(uint256 _raisedAmountAfterAllDeductions) public payable {\r\n        require(msg.sender == _deployer, DLOnlyDeployer());\r\n        \r\n        if(_useRaisedFundsVesting){\r\n           if(_purchaseToken==address(0) && msg.value< _raisedFundVestingDetails[0] * _raisedAmountAfterAllDeductions /10000 ) revert NotEnoughCoinsForRaisedFundsLock();\r\n            address newCoinVaultCloneAddress = Clones.clone(_purchasedCoinVestingVaultImplementationAddress);\r\n            _purchasedCoinVestingVault = PurchasedCoinVestingVault(payable(newCoinVaultCloneAddress) );\r\n            \r\n            _purchasedCoinVestingVault.initialize(_owner,block.timestamp, _raisedFundVestingDetails[0] * _raisedAmountAfterAllDeductions /10000, _raisedFundVestingDetails[1],_raisedFundVestingDetails[2], _purchaseToken);\r\n            \r\n            //Send coins\r\n            if(_purchaseToken==address(0)){\r\n                payable(_purchasedCoinVestingVault).transfer(_raisedFundVestingDetails[0] * _raisedAmountAfterAllDeductions /10000);\r\n            }else{\r\n                IERC20(_purchaseToken).safeTransfer(address(_purchasedCoinVestingVault),_raisedFundVestingDetails[0] * _raisedAmountAfterAllDeductions /10000);\r\n                //_purchasedCoinVestingVault.receiveTokens(_raisedFundVestingDetails[0] * _raisedAmountAfterAllDeductions /10000 );\r\n            }\r\n            \r\n        }\r\n        \r\n    }\r\n\r\n    receive() external payable {\r\n        // payable(_coinLocker).transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n     * Normalization function that adjusts token amounts to a common decimal base (18 decimals in this case). \r\n     * This function either scales up or scales down the token amount based on the number of decimals the token uses,\r\n     * ensuring the final amount will be always displayed with 18 decimals. \r\n     * Of course this can result in a minor truncation if tokens >18 decimals are being used, this must be considered\r\n     */\r\n    function normalizeTokenAmount(uint tokenAmount, uint tokenDecimals) public pure returns (uint) {\r\n        uint standardDecimal = 18;\r\n        if(tokenDecimals>standardDecimal){\r\n            return tokenAmount / (10 ** (tokenDecimals-standardDecimal));\r\n        }\r\n        else if(tokenDecimals< standardDecimal){\r\n            return tokenAmount * (10 ** (standardDecimal - tokenDecimals));\r\n        }\r\n        else{\r\n            return tokenAmount;\r\n        }\r\n    }\r\n\r\n    function lockERC20(address tokenAddress,address tokenOwner, uint totalTokens, uint firstReleasePercent, uint firstReleaseDays, \r\n        uint subsequentReleasePercent, uint subsequentReleaseDays ) public returns(address lockerAddress) {\r\n        require(tokenAddress!=address(0), TokenCannotBeAddressZero());\r\n        TokenLocker tokenLocker= new TokenLocker(tokenAddress, tokenOwner,totalTokens, firstReleasePercent,firstReleaseDays,subsequentReleasePercent,subsequentReleaseDays );\r\n        lockerAddress= address(tokenLocker);\r\n        emit ERC20LockCreated(lockerAddress,tokenAddress, tokenOwner ,totalTokens );\r\n    }\r\n  \r\n\r\n//    /**\r\n//      * @return the time when the LP tokens are released.\r\n//      */\r\n//     function getLiquidityReleaseTime() public view returns (uint256) {\r\n//         return _lpReleaseTime;\r\n//     }\r\n\r\n      /**\r\n     * @return the owner of the locked funds\r\n     */\r\n    function getOwner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    // /**\r\n    //  * @notice Transfers tokens held by Lock to owner.\r\n    //    @dev Able to withdraw LP funds after release time \r\n    //  */\r\n    // function releaseLPTokens() public {\r\n    //     _liquidityLocker.releaseLPTokens(); \r\n    // }\r\n\r\n    /**\r\n     * @notice Transfers tokens held by Lock to owner.\r\n     */\r\n    function releaseTeamTokens() public {\r\n        _teamTokensLocker.release();\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ETH back to the owner\r\n     */\r\n    function releaseCoinVaultETH() public {\r\n        _purchasedCoinVestingVault.claimVestedCoins();\r\n    }\r\n\r\n    function raisedFundsVaultAddress() public view returns (address) {\r\n        return address(_purchasedCoinVestingVault);\r\n    }\r\n\r\n    function raisedFundsPercent() public view returns (uint) {\r\n        return _raisedFundVestingDetails[0];\r\n    }\r\n\r\n    function tokenLockerAddress() public view returns (address) {\r\n        return address(_teamTokensLocker);\r\n    }\r\n\r\n    // function liquidityLockerAddress() public view returns (address) {\r\n    //     return address(_liquidityLocker);\r\n    // }\r\n}"
    },
    "contracts/Lockers/DexLockerFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport {DexLocker} from \"./DexLocker.sol\";\r\nimport \"../Errors.sol\";\r\n\r\n\r\n/// @title DexLockerFactory\r\n/// @notice Factory contract for creating DexLocker instances using Clones - Used to avoid contract size becoming too large\r\ncontract DexLockerFactory {\r\n    /// @notice Address of the DexLocker implementation contract\r\n    address   _dexLockerImplementationAddress;\r\n    address  _coinVaultImplementationAddress;\r\n\r\n    \r\n\r\n    constructor(address  dexLockerImplementationAddress,address  coinVaultImplementationAddress){\r\n        _dexLockerImplementationAddress=dexLockerImplementationAddress;\r\n        _coinVaultImplementationAddress=coinVaultImplementationAddress;\r\n    }\r\n    \r\n\r\n    /// @notice Creates a new DexLocker instance\r\n    /// @param dexRouterAddress Address of the DEX router\r\n    /// @param salesTokenAddress Address of the sales token\r\n    /// @param purchaseTokenAddress Address of the purchase token\r\n    /// @param deployer Address of the deployer\r\n    /// @param owner Address of the locker owner\r\n    /// @return Address of the newly created DexLocker instance\r\n    function createDexLocker(address dexRouterAddress, address salesTokenAddress, address purchaseTokenAddress,address deployer,address owner)  public returns(address) {\r\n        require(dexRouterAddress != address(0), InvalidDexRouterAddress(dexRouterAddress));\r\n        require(salesTokenAddress != address(0), InvalidSalesTokenAddress(salesTokenAddress));\r\n        // require(purchaseTokenAddress != address(0), InvalidPurchaseTokenAddress(purchaseTokenAddress));\r\n        require(deployer != address(0), InvalidDeployerAddress(deployer));\r\n        require(owner != address(0), InvalidOwnerAddress(owner));\r\n\r\n        address payable newCloneAddress = payable(Clones.clone(_dexLockerImplementationAddress ) );\r\n        DexLocker(newCloneAddress).initialize(salesTokenAddress,purchaseTokenAddress, deployer, owner,_coinVaultImplementationAddress);\r\n\r\n        return  newCloneAddress;\r\n    }\r\n}"
    },
    "contracts/Lockers/PurchasedCoinVestingVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.26;\r\n\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\n\r\n\r\nerror MustBeLessThanYears(string info,uint noOfYears);\r\nerror DurationLessThanCliff();\r\nerror DailyVestedAmountLessThanZero();\r\nerror OnlyOwner();\r\nerror AmountVestedLessThanZero();\r\n/**\r\n* Locks liquidity for Purchased Coins in a vested style. using Cliffs\r\n* @dev \r\n*/\r\ncontract PurchasedCoinVestingVault is Initializable, ReentrancyGuard  {\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 constant public SECONDS_PER_DAY = 86400;\r\n\r\n    struct Grant {\r\n        uint256 startTime;\r\n        uint256 amount;\r\n        uint256 vestingDuration;\r\n        uint256 vestingCliff;\r\n        uint256 daysClaimed;\r\n        uint256 totalClaimed;\r\n    }\r\n    address private _owner;\r\n    address public _deployer;\r\n\r\n    address private _coinOrTokenAddress;\r\n    \r\n    event GrantTokensClaimed(address indexed recipient, uint256 amountClaimed);\r\n    \r\n    \r\n    Grant public grant;\r\n\r\n    ///Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be taken over by an attacker, which may impact the proxy. \r\n    /// To prevent the implementation contract from being used, you should invoke the _disableInitializers function in the constructor to automatically lock it when it is deployed\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n    \r\n\r\n    function initialize(address vaultOwner, \r\n        uint256 _startTime,\r\n        uint256 _amount,\r\n        uint256 _vestingDurationInDays,\r\n        uint256 _vestingCliffInDays,\r\n        address coinOrTokenAddress) public initializer {\r\n\r\n        _deployer=msg.sender;\r\n        _owner=vaultOwner;\r\n        _coinOrTokenAddress=coinOrTokenAddress;\r\n        require(_vestingCliffInDays <= 10*365, MustBeLessThanYears('Cliff',10) );\r\n        require(_vestingDurationInDays <= 25*365, MustBeLessThanYears('Duration',25));\r\n        require(_vestingDurationInDays >= _vestingCliffInDays, DurationLessThanCliff());\r\n        \r\n        uint256 amountVestedPerDay = ((_amount * 100000000)/_vestingDurationInDays)/100000000;\r\n        require(amountVestedPerDay > 0, DailyVestedAmountLessThanZero());\r\n\r\n        // Transfer the grant tokens under the control of the vesting contract\r\n        // require(token.transferFrom(owner(), address(this), _amount), \"transfer failed\");\r\n\r\n        grant = Grant({\r\n            startTime: _startTime == 0 ? currentTime() : _startTime,\r\n            amount: _amount,\r\n            vestingDuration: _vestingDurationInDays,\r\n            vestingCliff: _vestingCliffInDays,\r\n            daysClaimed: 0,\r\n            totalClaimed: 0\r\n        });\r\n        \r\n        \r\n    }\r\n\r\n    receive() external payable {\r\n\r\n    }\r\n    // or\r\n    function receiveTokens(uint256 amount) public payable {\r\n      IERC20(_coinOrTokenAddress).safeTransferFrom(msg.sender, address(this), amount);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        \r\n        return _owner;\r\n\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public  {\r\n        \r\n        require(msg.sender== _owner, OnlyOwner());\r\n        _owner=newOwner;\r\n\r\n    }\r\n    \r\n\r\n    /// @notice Calculate the vested and unclaimed months and tokens available for `_grantId` to claim\r\n    /// Due to rounding errors once grant duration is reached, returns the entire left grant amount\r\n    /// Returns (0, 0) if cliff has not been reached\r\n    function calculateGrantClaim() public view returns (uint256, uint256) {\r\n        \r\n\r\n        // For grants created with a future start date, that hasn't been reached, return 0, 0\r\n        if (currentTime() < grant.startTime) {\r\n            return (0, 0);\r\n        }\r\n\r\n        // Check cliff was reached\r\n        uint elapsedTime = currentTime()-grant.startTime;\r\n        uint elapsedDays = elapsedTime/SECONDS_PER_DAY;\r\n        \r\n        if (elapsedDays < grant.vestingCliff) {\r\n            return (elapsedDays, 0);\r\n        }\r\n\r\n        // If over vesting duration, all tokens vested\r\n        if (elapsedDays >= grant.vestingDuration) {\r\n            uint256 remainingGrant = grant.amount-grant.totalClaimed;\r\n            return (grant.vestingDuration, remainingGrant);\r\n        } else {\r\n            uint256 daysVested = elapsedDays-grant.daysClaimed;\r\n            uint256 amountVestedPerDay = grant.amount/ grant.vestingDuration;\r\n            uint256 amountVested = daysVested*amountVestedPerDay;\r\n            return (daysVested, amountVested);\r\n        }\r\n    }\r\n\r\n    /// @notice Allows a grant recipient to claim their vested tokens. Errors if no tokens have vested\r\n    /// It is advised recipients check they are entitled to claim via `calculateGrantClaim` before calling this\r\n    function claimVestedCoins() external nonReentrant {\r\n        uint256 daysVested;\r\n        uint256 amountVested;\r\n        address recipient=owner();\r\n\r\n        (daysVested, amountVested) = calculateGrantClaim();\r\n        require(amountVested > 0, AmountVestedLessThanZero());\r\n\r\n        \r\n        grant.daysClaimed = grant.daysClaimed+ daysVested;\r\n        grant.totalClaimed = grant.totalClaimed + amountVested;\r\n        \r\n        // token.safeTransfer(recipient, amountVested);\r\n        if(_coinOrTokenAddress==address(0)){\r\n            payable(recipient).transfer(amountVested);\r\n        }else{            \r\n            IERC20(_coinOrTokenAddress).safeTransfer(recipient, amountVested); \r\n        }\r\n        \r\n        emit GrantTokensClaimed(recipient, amountVested);\r\n    }\r\n\r\n    function currentTime() private view returns(uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function tokensVestedPerDay() public view returns(uint256) {\r\n        \r\n        return grant.amount/ grant.vestingDuration;\r\n    }\r\n\r\n    \r\n\r\n}"
    },
    "contracts/Lockers/TokenLocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\n\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"./VestSchedule.sol\";\r\n\r\n\r\n/**\r\n* Locks ERC20 Tokens in a vested style.\r\n* @dev Percentages are specified normally, e.g. 50% is 50\r\n*/\r\ncontract TokenLocker is ReentrancyGuard{\r\n    error InvalidPercent();\r\n    error NotEnoughTokens();\r\n    error WrongToken();\r\n\r\n    using SafeERC20 for IERC20;\r\n    // using SafeMath for uint256;\r\n    \r\n\r\n   \r\n    address private _owner;\r\n\r\n    address private _deployer;    \r\n\r\n    address private _token;\r\n    \r\n\r\n    uint _cycles ;\r\n\r\n    event TokenReleased(address indexed token, uint256 amount);\r\n    \r\n    VestSchedule[] public tokenVestSchedule ;\r\n\r\n    constructor( address tokenAddress, address owner, \r\n        uint totalTokens, uint firstReleasePercent, uint firstReleaseDays, uint subsequentReleasePercent, uint subsequentReleaseDays) {\r\n\r\n        // require(schedule.length <= 8, \"TokenLocker: Vesting cannot have more than 8 schedules\");\r\n        \r\n     \r\n        require(firstReleasePercent + subsequentReleasePercent <= 100, InvalidPercent());\r\n\r\n        _deployer = msg.sender;\r\n        \r\n        _owner = owner;\r\n        _token = tokenAddress;\r\n\r\n        // 50, 25\r\n        //30, 30\r\n        // 30, 35\r\n        uint subsequentCycles = subsequentReleasePercent==0?0: (100 -  firstReleasePercent)/ subsequentReleasePercent; \r\n        bool hasExtraCycle = 100 -  firstReleasePercent  - (subsequentCycles * subsequentReleasePercent) > 0; \r\n        uint cycles = 1 +  subsequentCycles + ( hasExtraCycle? 1: 0 );\r\n\r\n        _cycles = cycles;\r\n\r\n        // tokenVestSchedule = new VestSchedule[](cycles);\r\n\r\n        // tokenVestSchedule[0] = VestSchedule({\r\n        //     releaseDate: block.timestamp + (firstReleaseDays * 1 days),\r\n        //     releaseAmount: firstReleasePercent * totalTokens * 10000/1000000,\r\n        //     hasBeenClaimed: false\r\n        // });\r\n\r\n\r\n        // for (uint i=0; i < subsequentCycles ; i++) {\r\n        //     //first index is firstRelease\r\n        //     tokenVestSchedule[i+1] = VestSchedule({\r\n        //         releaseDate: tokenVestSchedule[0].releaseDate + ((i+1) * subsequentReleaseDays * 1 days),\r\n        //         releaseAmount: subsequentReleasePercent * totalTokens * 10000/1000000,\r\n        //         hasBeenClaimed: false\r\n        //     });\r\n        // }\r\n\r\n        // //any extra \r\n        // if(hasExtraCycle){\r\n        //     // extra cycle will account for frist cycle and the subsequentscyels hence s + 1\r\n        //     tokenVestSchedule[subsequentCycles + 1] = VestSchedule({\r\n        //         releaseDate: tokenVestSchedule[subsequentCycles].releaseDate + ( subsequentReleaseDays * 1 days), // add days to last vesting day\r\n        //         releaseAmount: (100 -  firstReleasePercent  - (subsequentCycles * subsequentReleasePercent)) * totalTokens * 10000/1000000,\r\n        //         hasBeenClaimed: false\r\n        //     });\r\n        // }\r\n\r\n\r\n        \r\n\r\n        tokenVestSchedule.push( VestSchedule({\r\n            releaseDate: block.timestamp + (firstReleaseDays * 1 days),\r\n            releaseAmount: firstReleasePercent * totalTokens * 10000/1000000,\r\n            hasBeenClaimed: false\r\n        }) );\r\n\r\n\r\n        for (uint i=0; i < subsequentCycles ; i++) {\r\n            //first index is firstRelease\r\n            tokenVestSchedule.push( VestSchedule({\r\n                releaseDate: tokenVestSchedule[0].releaseDate + ((i+1) * subsequentReleaseDays * 1 days),\r\n                releaseAmount: subsequentReleasePercent * totalTokens * 10000/1000000,\r\n                hasBeenClaimed: false\r\n            }) );\r\n        }\r\n\r\n        //any extra \r\n        if(hasExtraCycle){\r\n            // extra cycle will account for frist cycle and the subsequentscyels hence s + 1\r\n            tokenVestSchedule.push( VestSchedule({\r\n                releaseDate: tokenVestSchedule[subsequentCycles].releaseDate + ( subsequentReleaseDays * 1 days), // add days to last vesting day\r\n                releaseAmount: (100 -  firstReleasePercent  - (subsequentCycles * subsequentReleasePercent)) * totalTokens * 10000/1000000,\r\n                hasBeenClaimed: false\r\n            }) );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the owner of the locked funds\r\n     */\r\n    function getOwner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function getVestingCycle() public view returns (VestSchedule[] memory schedule) {\r\n\r\n        schedule = new VestSchedule[](_cycles);\r\n\r\n        for (uint i=0; i < _cycles ; i++) {\r\n            \r\n            schedule[i]= tokenVestSchedule[i];\r\n        }\r\n        return schedule;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @notice Transfers tokens held by Lock to owner.\r\n       @dev Able to withdraw tokens after release time \r\n     */\r\n    function release() public nonReentrant {\r\n        uint256 amountToReleaseThisTime =0;\r\n        uint i;\r\n        for (i=0; i < _cycles; i++) { \r\n            if(block.timestamp >= tokenVestSchedule[i].releaseDate && !tokenVestSchedule[i].hasBeenClaimed ) {\r\n                amountToReleaseThisTime += tokenVestSchedule[i].releaseAmount;\r\n                tokenVestSchedule[i].hasBeenClaimed = true;\r\n            }            \r\n        }\r\n        \r\n        uint256 balance = IERC20(_token).balanceOf(address(this));\r\n        //require(balance > 0, \"TokenLocker: no tokens to release\");\r\n        require(balance >= amountToReleaseThisTime, NotEnoughTokens());\r\n\r\n        IERC20(_token).safeTransfer(_owner, amountToReleaseThisTime);\r\n\r\n        emit TokenReleased(_token, amountToReleaseThisTime); \r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Transfers any ETH back to the owner, ETH is not locked\r\n       @dev Function used to transfer eth mistakenly sent here\r\n     */\r\n    function withdrawETH() public {\r\n        require(address(this).balance > 0, \"TokenLocker: no Eth to release\");\r\n\r\n        payable(getOwner()).transfer(address(this).balance);\r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Transfers any unrecognised token back to the owner, \r\n       @dev Function used to transfer Tokens mistakenly sent here\r\n     */\r\n    function withdrawToken(address tokenToSend) public {\r\n        require(_token!=tokenToSend, WrongToken());\r\n        require(IERC20(tokenToSend).balanceOf(address(this)) > 0, NotEnoughTokens());\r\n\r\n        IERC20(tokenToSend).safeTransfer(getOwner(), IERC20(tokenToSend).balanceOf(address(this))); \r\n        \r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the amount of releasable token tokens. token should be the address of an IERC20 contract.\r\n     */\r\n    function released() public view returns (uint ){\r\n        uint256 amount=0;\r\n        uint i;\r\n        for (i=0; i < _cycles; i++) { \r\n            if(tokenVestSchedule[i].hasBeenClaimed ) {\r\n                amount += tokenVestSchedule[i].releaseAmount;\r\n            }            \r\n        }\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the amount of releasable token tokens. token should be the address of an IERC20 contract.\r\n     */\r\n    function releasable() public view returns (uint ){\r\n        uint256 amount=0;\r\n        uint i;\r\n        for (i=0; i < _cycles; i++) { \r\n            if( block.timestamp >= tokenVestSchedule[i].releaseDate && !tokenVestSchedule[i].hasBeenClaimed) {\r\n                amount += tokenVestSchedule[i].releaseAmount;\r\n            }            \r\n        }\r\n        return amount;\r\n    }\r\n}"
    },
    "contracts/Lockers/VestSchedule.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nstruct VestSchedule{\r\n    uint256 releaseDate;\r\n    uint256 releaseAmount;\r\n    bool hasBeenClaimed;\r\n}"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000,
      "details": {
        "yul": true
      }
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}