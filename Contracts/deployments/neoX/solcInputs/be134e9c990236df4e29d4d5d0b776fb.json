{
  "language": "Solidity",
  "sources": {
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (access/Ownable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * The initial owner is set to the address provided by the deployer. This can\n * later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    /**\n     * @dev The caller account is not authorized to perform an operation.\n     */\n    error OwnableUnauthorizedAccount(address account);\n\n    /**\n     * @dev The owner is not a valid owner account. (eg. `address(0)`)\n     */\n    error OwnableInvalidOwner(address owner);\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the address provided by the deployer as the initial owner.\n     */\n    constructor(address initialOwner) {\n        if (initialOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(initialOwner);\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        if (owner() != _msgSender()) {\n            revert OwnableUnauthorizedAccount(_msgSender());\n        }\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby disabling any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        if (newOwner == address(0)) {\n            revert OwnableInvalidOwner(address(0));\n        }\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC6093.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/draft-IERC6093.sol)\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard ERC20 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC20 tokens.\n */\ninterface IERC20Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientBalance(address sender, uint256 balance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC20InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC20InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `spender`’s `allowance`. Used in transfers.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     * @param allowance Amount of tokens a `spender` is allowed to operate with.\n     * @param needed Minimum amount required to perform a transfer.\n     */\n    error ERC20InsufficientAllowance(address spender, uint256 allowance, uint256 needed);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC20InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `spender` to be approved. Used in approvals.\n     * @param spender Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC20InvalidSpender(address spender);\n}\n\n/**\n * @dev Standard ERC721 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC721 tokens.\n */\ninterface IERC721Errors {\n    /**\n     * @dev Indicates that an address can't be an owner. For example, `address(0)` is a forbidden owner in EIP-20.\n     * Used in balance queries.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721InvalidOwner(address owner);\n\n    /**\n     * @dev Indicates a `tokenId` whose `owner` is the zero address.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721NonexistentToken(uint256 tokenId);\n\n    /**\n     * @dev Indicates an error related to the ownership over a particular token. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param tokenId Identifier number of a token.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC721IncorrectOwner(address sender, uint256 tokenId, address owner);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC721InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC721InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC721InsufficientApproval(address operator, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC721InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC721InvalidOperator(address operator);\n}\n\n/**\n * @dev Standard ERC1155 Errors\n * Interface of the https://eips.ethereum.org/EIPS/eip-6093[ERC-6093] custom errors for ERC1155 tokens.\n */\ninterface IERC1155Errors {\n    /**\n     * @dev Indicates an error related to the current `balance` of a `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     * @param balance Current balance for the interacting account.\n     * @param needed Minimum amount required to perform a transfer.\n     * @param tokenId Identifier number of a token.\n     */\n    error ERC1155InsufficientBalance(address sender, uint256 balance, uint256 needed, uint256 tokenId);\n\n    /**\n     * @dev Indicates a failure with the token `sender`. Used in transfers.\n     * @param sender Address whose tokens are being transferred.\n     */\n    error ERC1155InvalidSender(address sender);\n\n    /**\n     * @dev Indicates a failure with the token `receiver`. Used in transfers.\n     * @param receiver Address to which tokens are being transferred.\n     */\n    error ERC1155InvalidReceiver(address receiver);\n\n    /**\n     * @dev Indicates a failure with the `operator`’s approval. Used in transfers.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     * @param owner Address of the current owner of a token.\n     */\n    error ERC1155MissingApprovalForAll(address operator, address owner);\n\n    /**\n     * @dev Indicates a failure with the `approver` of a token to be approved. Used in approvals.\n     * @param approver Address initiating an approval operation.\n     */\n    error ERC1155InvalidApprover(address approver);\n\n    /**\n     * @dev Indicates a failure with the `operator` to be approved. Used in approvals.\n     * @param operator Address that may be allowed to operate on tokens without being their owner.\n     */\n    error ERC1155InvalidOperator(address operator);\n\n    /**\n     * @dev Indicates an array length mismatch between ids and values in a safeBatchTransferFrom operation.\n     * Used in batch transfers.\n     * @param idsLength Length of the array of token identifiers\n     * @param valuesLength Length of the array of token amounts\n     */\n    error ERC1155InvalidArrayLength(uint256 idsLength, uint256 valuesLength);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../utils/introspection/IERC165.sol\";\n"
    },
    "@openzeppelin/contracts/interfaces/IERC4906.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC4906.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\nimport {IERC721} from \"./IERC721.sol\";\n\n/// @title EIP-721 Metadata Update Extension\ninterface IERC4906 is IERC165, IERC721 {\n    /// @dev This event emits when the metadata of a token is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFT.\n    event MetadataUpdate(uint256 _tokenId);\n\n    /// @dev This event emits when the metadata of a range of tokens is changed.\n    /// So that the third-party platforms such as NFT market could\n    /// timely update the images and related attributes of the NFTs.\n    event BatchMetadataUpdate(uint256 _fromTokenId, uint256 _toTokenId);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (interfaces/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../token/ERC721/IERC721.sol\";\n"
    },
    "@openzeppelin/contracts/proxy/Clones.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/Clones.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-1167[EIP 1167] is a standard for\n * deploying minimal proxy contracts, also known as \"clones\".\n *\n * > To simply and cheaply clone contract functionality in an immutable way, this standard specifies\n * > a minimal bytecode implementation that delegates all calls to a known, fixed address.\n *\n * The library includes functions to deploy a proxy using either `create` (traditional deployment) or `create2`\n * (salted deterministic deployment). It also includes functions to predict the addresses of clones deployed using the\n * deterministic method.\n */\nlibrary Clones {\n    /**\n     * @dev A clone instance deployment failed.\n     */\n    error ERC1167FailedCreateClone();\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create opcode, which should never revert.\n     */\n    function clone(address implementation) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create(0, 0x09, 0x37)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Deploys and returns the address of a clone that mimics the behaviour of `implementation`.\n     *\n     * This function uses the create2 opcode and a `salt` to deterministically deploy\n     * the clone. Using the same `implementation` and `salt` multiple time will revert, since\n     * the clones cannot be deployed twice at the same address.\n     */\n    function cloneDeterministic(address implementation, bytes32 salt) internal returns (address instance) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Cleans the upper 96 bits of the `implementation` word, then packs the first 3 bytes\n            // of the `implementation` address with the bytecode before the address.\n            mstore(0x00, or(shr(0xe8, shl(0x60, implementation)), 0x3d602d80600a3d3981f3363d3d373d3d3d363d73000000))\n            // Packs the remaining 17 bytes of `implementation` with the bytecode after the address.\n            mstore(0x20, or(shl(0x78, implementation), 0x5af43d82803e903d91602b57fd5bf3))\n            instance := create2(0, 0x09, 0x37, salt)\n        }\n        if (instance == address(0)) {\n            revert ERC1167FailedCreateClone();\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt,\n        address deployer\n    ) internal pure returns (address predicted) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x38), deployer)\n            mstore(add(ptr, 0x24), 0x5af43d82803e903d91602b57fd5bf3ff)\n            mstore(add(ptr, 0x14), implementation)\n            mstore(ptr, 0x3d602d80600a3d3981f3363d3d373d3d3d363d73)\n            mstore(add(ptr, 0x58), salt)\n            mstore(add(ptr, 0x78), keccak256(add(ptr, 0x0c), 0x37))\n            predicted := keccak256(add(ptr, 0x43), 0x55)\n        }\n    }\n\n    /**\n     * @dev Computes the address of a clone deployed using {Clones-cloneDeterministic}.\n     */\n    function predictDeterministicAddress(\n        address implementation,\n        bytes32 salt\n    ) internal view returns (address predicted) {\n        return predictDeterministicAddress(implementation, salt, address(this));\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```solidity\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n *\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Storage of the initializable contract.\n     *\n     * It's implemented on a custom ERC-7201 namespace to reduce the risk of storage collisions\n     * when using with upgradeable contracts.\n     *\n     * @custom:storage-location erc7201:openzeppelin.storage.Initializable\n     */\n    struct InitializableStorage {\n        /**\n         * @dev Indicates that the contract has been initialized.\n         */\n        uint64 _initialized;\n        /**\n         * @dev Indicates that the contract is in the process of being initialized.\n         */\n        bool _initializing;\n    }\n\n    // keccak256(abi.encode(uint256(keccak256(\"openzeppelin.storage.Initializable\")) - 1)) & ~bytes32(uint256(0xff))\n    bytes32 private constant INITIALIZABLE_STORAGE = 0xf0c57e16840df040f15088dc2f81fe391c3923bec73e23a9662efc9c229c6a00;\n\n    /**\n     * @dev The contract is already initialized.\n     */\n    error InvalidInitialization();\n\n    /**\n     * @dev The contract is not initializing.\n     */\n    error NotInitializing();\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint64 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts.\n     *\n     * Similar to `reinitializer(1)`, except that in the context of a constructor an `initializer` may be invoked any\n     * number of times. This behavior in the constructor can be useful during testing and is not expected to be used in\n     * production.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier initializer() {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        // Cache values to avoid duplicated sloads\n        bool isTopLevelCall = !$._initializing;\n        uint64 initialized = $._initialized;\n\n        // Allowed calls:\n        // - initialSetup: the contract is not in the initializing state and no previous version was\n        //                 initialized\n        // - construction: the contract is initialized at version 1 (no reininitialization) and the\n        //                 current contract is just being deployed\n        bool initialSetup = initialized == 0 && isTopLevelCall;\n        bool construction = initialized == 1 && address(this).code.length == 0;\n\n        if (!initialSetup && !construction) {\n            revert InvalidInitialization();\n        }\n        $._initialized = 1;\n        if (isTopLevelCall) {\n            $._initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            $._initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * A reinitializer may be used after the original initialization step. This is essential to configure modules that\n     * are added through upgrades and that require initialization.\n     *\n     * When `version` is 1, this modifier is similar to `initializer`, except that functions marked with `reinitializer`\n     * cannot be nested. If one is invoked in the context of another, execution will revert.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     *\n     * WARNING: Setting the version to 2**64 - 1 will prevent any future reinitialization.\n     *\n     * Emits an {Initialized} event.\n     */\n    modifier reinitializer(uint64 version) {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing || $._initialized >= version) {\n            revert InvalidInitialization();\n        }\n        $._initialized = version;\n        $._initializing = true;\n        _;\n        $._initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        _checkInitializing();\n        _;\n    }\n\n    /**\n     * @dev Reverts if the contract is not in an initializing state. See {onlyInitializing}.\n     */\n    function _checkInitializing() internal view virtual {\n        if (!_isInitializing()) {\n            revert NotInitializing();\n        }\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     *\n     * Emits an {Initialized} event the first time it is successfully executed.\n     */\n    function _disableInitializers() internal virtual {\n        // solhint-disable-next-line var-name-mixedcase\n        InitializableStorage storage $ = _getInitializableStorage();\n\n        if ($._initializing) {\n            revert InvalidInitialization();\n        }\n        if ($._initialized != type(uint64).max) {\n            $._initialized = type(uint64).max;\n            emit Initialized(type(uint64).max);\n        }\n    }\n\n    /**\n     * @dev Returns the highest version that has been initialized. See {reinitializer}.\n     */\n    function _getInitializedVersion() internal view returns (uint64) {\n        return _getInitializableStorage()._initialized;\n    }\n\n    /**\n     * @dev Returns `true` if the contract is currently initializing. See {onlyInitializing}.\n     */\n    function _isInitializing() internal view returns (bool) {\n        return _getInitializableStorage()._initializing;\n    }\n\n    /**\n     * @dev Returns a pointer to the storage namespace.\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    function _getInitializableStorage() private pure returns (InitializableStorage storage $) {\n        assembly {\n            $.slot := INITIALIZABLE_STORAGE\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"./IERC20.sol\";\nimport {IERC20Metadata} from \"./extensions/IERC20Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {IERC20Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.openzeppelin.com/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * The default value of {decimals} is 18. To change this, you should override\n * this function so it returns a different value.\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n */\nabstract contract ERC20 is Context, IERC20, IERC20Metadata, IERC20Errors {\n    mapping(address account => uint256) private _balances;\n\n    mapping(address account => mapping(address spender => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the default value returned by this function, unless\n     * it's overridden.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `value`.\n     */\n    function transfer(address to, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `value` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 value) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, value);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `value`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `value`.\n     */\n    function transferFrom(address from, address to, uint256 value) public virtual returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, value);\n        _transfer(from, to, value);\n        return true;\n    }\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _transfer(address from, address to, uint256 value) internal {\n        if (from == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        if (to == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(from, to, value);\n    }\n\n    /**\n     * @dev Transfers a `value` amount of tokens from `from` to `to`, or alternatively mints (or burns) if `from`\n     * (or `to`) is the zero address. All customizations to transfers, mints, and burns should be done by overriding\n     * this function.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _update(address from, address to, uint256 value) internal virtual {\n        if (from == address(0)) {\n            // Overflow check required: The rest of the code assumes that totalSupply never overflows\n            _totalSupply += value;\n        } else {\n            uint256 fromBalance = _balances[from];\n            if (fromBalance < value) {\n                revert ERC20InsufficientBalance(from, fromBalance, value);\n            }\n            unchecked {\n                // Overflow not possible: value <= fromBalance <= totalSupply.\n                _balances[from] = fromBalance - value;\n            }\n        }\n\n        if (to == address(0)) {\n            unchecked {\n                // Overflow not possible: value <= totalSupply or value <= fromBalance <= totalSupply.\n                _totalSupply -= value;\n            }\n        } else {\n            unchecked {\n                // Overflow not possible: balance + value is at most totalSupply, which we know fits into a uint256.\n                _balances[to] += value;\n            }\n        }\n\n        emit Transfer(from, to, value);\n    }\n\n    /**\n     * @dev Creates a `value` amount of tokens and assigns them to `account`, by transferring it from address(0).\n     * Relies on the `_update` mechanism\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead.\n     */\n    function _mint(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidReceiver(address(0));\n        }\n        _update(address(0), account, value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, lowering the total supply.\n     * Relies on the `_update` mechanism.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * NOTE: This function is not virtual, {_update} should be overridden instead\n     */\n    function _burn(address account, uint256 value) internal {\n        if (account == address(0)) {\n            revert ERC20InvalidSender(address(0));\n        }\n        _update(account, address(0), value);\n    }\n\n    /**\n     * @dev Sets `value` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address owner, address spender, uint256 value) internal {\n        _approve(owner, spender, value, true);\n    }\n\n    /**\n     * @dev Variant of {_approve} with an optional flag to enable or disable the {Approval} event.\n     *\n     * By default (when calling {_approve}) the flag is set to true. On the other hand, approval changes made by\n     * `_spendAllowance` during the `transferFrom` operation set the flag to false. This saves gas by not emitting any\n     * `Approval` event during `transferFrom` operations.\n     *\n     * Anyone who wishes to continue emitting `Approval` events on the`transferFrom` operation can force the flag to\n     * true using the following override:\n     * ```\n     * function _approve(address owner, address spender, uint256 value, bool) internal virtual override {\n     *     super._approve(owner, spender, value, true);\n     * }\n     * ```\n     *\n     * Requirements are the same as {_approve}.\n     */\n    function _approve(address owner, address spender, uint256 value, bool emitEvent) internal virtual {\n        if (owner == address(0)) {\n            revert ERC20InvalidApprover(address(0));\n        }\n        if (spender == address(0)) {\n            revert ERC20InvalidSpender(address(0));\n        }\n        _allowances[owner][spender] = value;\n        if (emitEvent) {\n            emit Approval(owner, spender, value);\n        }\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `value`.\n     *\n     * Does not update the allowance value in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Does not emit an {Approval} event.\n     */\n    function _spendAllowance(address owner, address spender, uint256 value) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            if (currentAllowance < value) {\n                revert ERC20InsufficientAllowance(spender, currentAllowance, value);\n            }\n            unchecked {\n                _approve(owner, spender, currentAllowance - value, false);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Burnable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Context} from \"../../../utils/Context.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to destroy both their own\n * tokens and those that they have an allowance for, in a way that can be\n * recognized off-chain (via event analysis).\n */\nabstract contract ERC20Burnable is Context, ERC20 {\n    /**\n     * @dev Destroys a `value` amount of tokens from the caller.\n     *\n     * See {ERC20-_burn}.\n     */\n    function burn(uint256 value) public virtual {\n        _burn(_msgSender(), value);\n    }\n\n    /**\n     * @dev Destroys a `value` amount of tokens from `account`, deducting from\n     * the caller's allowance.\n     *\n     * See {ERC20-_burn} and {ERC20-allowance}.\n     *\n     * Requirements:\n     *\n     * - the caller must have allowance for ``accounts``'s tokens of at least\n     * `value`.\n     */\n    function burnFrom(address account, uint256 value) public virtual {\n        _spendAllowance(account, _msgSender(), value);\n        _burn(account, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/ERC20Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC20} from \"../ERC20.sol\";\nimport {Pausable} from \"../../../utils/Pausable.sol\";\n\n/**\n * @dev ERC20 token with pausable token transfers, minting and burning.\n *\n * Useful for scenarios such as preventing trades until the end of an evaluation\n * period, or having an emergency switch for freezing all token transfers in the\n * event of a large bug.\n *\n * IMPORTANT: This contract does not include public pause and unpause functions. In\n * addition to inheriting this contract, you must define both functions, invoking the\n * {Pausable-_pause} and {Pausable-_unpause} internal functions, with appropriate\n * access control, e.g. using {AccessControl} or {Ownable}. Not doing so will\n * make the contract pause mechanism of the contract unreachable, and thus unusable.\n */\nabstract contract ERC20Pausable is ERC20, Pausable {\n    /**\n     * @dev See {ERC20-_update}.\n     *\n     * Requirements:\n     *\n     * - the contract must not be paused.\n     */\n    function _update(address from, address to, uint256 value) internal virtual override whenNotPaused {\n        super._update(from, to, value);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/extensions/IERC20Permit.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * ==== Security Considerations\n *\n * There are two important considerations concerning the use of `permit`. The first is that a valid permit signature\n * expresses an allowance, and it should not be assumed to convey additional meaning. In particular, it should not be\n * considered as an intention to spend the allowance in any specific way. The second is that because permits have\n * built-in replay protection and can be submitted by anyone, they can be frontrun. A protocol that uses permits should\n * take this into consideration and allow a `permit` call to fail. Combining these two aspects, a pattern that may be\n * generally recommended is:\n *\n * ```solidity\n * function doThingWithPermit(..., uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s) public {\n *     try token.permit(msg.sender, address(this), value, deadline, v, r, s) {} catch {}\n *     doThing(..., value);\n * }\n *\n * function doThing(..., uint256 value) public {\n *     token.safeTransferFrom(msg.sender, address(this), value);\n *     ...\n * }\n * ```\n *\n * Observe that: 1) `msg.sender` is used as the owner, leaving no ambiguity as to the signer intent, and 2) the use of\n * `try/catch` allows the permit to fail and makes the code tolerant to frontrunning. (See also\n * {SafeERC20-safeTransferFrom}).\n *\n * Additionally, note that smart contract wallets (such as Argent or Safe) are not able to produce permit signatures, so\n * contracts should have entry points that don't rely on permit.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     *\n     * CAUTION: See Security Considerations above.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the value of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the value of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves a `value` amount of tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 value) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets a `value` amount of tokens as the allowance of `spender` over the\n     * caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 value) external returns (bool);\n\n    /**\n     * @dev Moves a `value` amount of tokens from `from` to `to` using the\n     * allowance mechanism. `value` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 value) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC20} from \"../IERC20.sol\";\nimport {IERC20Permit} from \"../extensions/IERC20Permit.sol\";\nimport {Address} from \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    /**\n     * @dev An operation with an ERC20 token failed.\n     */\n    error SafeERC20FailedOperation(address token);\n\n    /**\n     * @dev Indicates a failed `decreaseAllowance` request.\n     */\n    error SafeERC20FailedDecreaseAllowance(address spender, uint256 currentAllowance, uint256 requestedDecrease);\n\n    /**\n     * @dev Transfer `value` amount of `token` from the calling contract to `to`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeTransfer(IERC20 token, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transfer, (to, value)));\n    }\n\n    /**\n     * @dev Transfer `value` amount of `token` from `from` to `to`, spending the approval given by `from` to the\n     * calling contract. If `token` returns no value, non-reverting calls are assumed to be successful.\n     */\n    function safeTransferFrom(IERC20 token, address from, address to, uint256 value) internal {\n        _callOptionalReturn(token, abi.encodeCall(token.transferFrom, (from, to, value)));\n    }\n\n    /**\n     * @dev Increase the calling contract's allowance toward `spender` by `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful.\n     */\n    function safeIncreaseAllowance(IERC20 token, address spender, uint256 value) internal {\n        uint256 oldAllowance = token.allowance(address(this), spender);\n        forceApprove(token, spender, oldAllowance + value);\n    }\n\n    /**\n     * @dev Decrease the calling contract's allowance toward `spender` by `requestedDecrease`. If `token` returns no\n     * value, non-reverting calls are assumed to be successful.\n     */\n    function safeDecreaseAllowance(IERC20 token, address spender, uint256 requestedDecrease) internal {\n        unchecked {\n            uint256 currentAllowance = token.allowance(address(this), spender);\n            if (currentAllowance < requestedDecrease) {\n                revert SafeERC20FailedDecreaseAllowance(spender, currentAllowance, requestedDecrease);\n            }\n            forceApprove(token, spender, currentAllowance - requestedDecrease);\n        }\n    }\n\n    /**\n     * @dev Set the calling contract's allowance toward `spender` to `value`. If `token` returns no value,\n     * non-reverting calls are assumed to be successful. Meant to be used with tokens that require the approval\n     * to be set to zero before setting it to a non-zero value, such as USDT.\n     */\n    function forceApprove(IERC20 token, address spender, uint256 value) internal {\n        bytes memory approvalCall = abi.encodeCall(token.approve, (spender, value));\n\n        if (!_callOptionalReturnBool(token, approvalCall)) {\n            _callOptionalReturn(token, abi.encodeCall(token.approve, (spender, 0)));\n            _callOptionalReturn(token, approvalCall);\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address-functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data);\n        if (returndata.length != 0 && !abi.decode(returndata, (bool))) {\n            revert SafeERC20FailedOperation(address(token));\n        }\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     *\n     * This is a variant of {_callOptionalReturn} that silents catches all reverts and returns a bool instead.\n     */\n    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We cannot use {Address-functionCall} here since this should return false\n        // and not revert is the subcall reverts.\n\n        (bool success, bytes memory returndata) = address(token).call(data);\n        return success && (returndata.length == 0 || abi.decode(returndata, (bool))) && address(token).code.length > 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"./IERC721.sol\";\nimport {IERC721Receiver} from \"./IERC721Receiver.sol\";\nimport {IERC721Metadata} from \"./extensions/IERC721Metadata.sol\";\nimport {Context} from \"../../utils/Context.sol\";\nimport {Strings} from \"../../utils/Strings.sol\";\nimport {IERC165, ERC165} from \"../../utils/introspection/ERC165.sol\";\nimport {IERC721Errors} from \"../../interfaces/draft-IERC6093.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\nabstract contract ERC721 is Context, ERC165, IERC721, IERC721Metadata, IERC721Errors {\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    mapping(uint256 tokenId => address) private _owners;\n\n    mapping(address owner => uint256) private _balances;\n\n    mapping(uint256 tokenId => address) private _tokenApprovals;\n\n    mapping(address owner => mapping(address operator => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual returns (uint256) {\n        if (owner == address(0)) {\n            revert ERC721InvalidOwner(address(0));\n        }\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual returns (address) {\n        return _requireOwned(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string.concat(baseURI, tokenId.toString()) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual {\n        _approve(to, tokenId, _msgSender());\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual returns (address) {\n        _requireOwned(tokenId);\n\n        return _getApproved(tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) public virtual {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        // Setting an \"auth\" arguments enables the `_isAuthorized` check which verifies that the token exists\n        // (from != 0). Therefore, it is not needed to verify that the return value is not 0 here.\n        address previousOwner = _update(to, tokenId, _msgSender());\n        if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) public {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes memory data) public virtual {\n        transferFrom(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Returns the owner of the `tokenId`. Does NOT revert if token doesn't exist\n     *\n     * IMPORTANT: Any overrides to this function that add ownership of tokens not tracked by the\n     * core ERC721 logic MUST be matched with the use of {_increaseBalance} to keep balances\n     * consistent with ownership. The invariant to preserve is that for any address `a` the value returned by\n     * `balanceOf(a)` must be equal to the number of tokens such that `_ownerOf(tokenId)` is `a`.\n     */\n    function _ownerOf(uint256 tokenId) internal view virtual returns (address) {\n        return _owners[tokenId];\n    }\n\n    /**\n     * @dev Returns the approved address for `tokenId`. Returns 0 if `tokenId` is not minted.\n     */\n    function _getApproved(uint256 tokenId) internal view virtual returns (address) {\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `owner`'s tokens, or `tokenId` in\n     * particular (ignoring whether it is owned by `owner`).\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _isAuthorized(address owner, address spender, uint256 tokenId) internal view virtual returns (bool) {\n        return\n            spender != address(0) &&\n            (owner == spender || isApprovedForAll(owner, spender) || _getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Checks if `spender` can operate on `tokenId`, assuming the provided `owner` is the actual owner.\n     * Reverts if `spender` does not have approval from the provided `owner` for the given token or for all its assets\n     * the `spender` for the specific `tokenId`.\n     *\n     * WARNING: This function assumes that `owner` is the actual owner of `tokenId` and does not verify this\n     * assumption.\n     */\n    function _checkAuthorized(address owner, address spender, uint256 tokenId) internal view virtual {\n        if (!_isAuthorized(owner, spender, tokenId)) {\n            if (owner == address(0)) {\n                revert ERC721NonexistentToken(tokenId);\n            } else {\n                revert ERC721InsufficientApproval(spender, tokenId);\n            }\n        }\n    }\n\n    /**\n     * @dev Unsafe write access to the balances, used by extensions that \"mint\" tokens using an {ownerOf} override.\n     *\n     * NOTE: the value is limited to type(uint128).max. This protect against _balance overflow. It is unrealistic that\n     * a uint256 would ever overflow from increments when these increments are bounded to uint128 values.\n     *\n     * WARNING: Increasing an account's balance using this function tends to be paired with an override of the\n     * {_ownerOf} function to resolve the ownership of the corresponding tokens so that balances and ownership\n     * remain consistent with one another.\n     */\n    function _increaseBalance(address account, uint128 value) internal virtual {\n        unchecked {\n            _balances[account] += value;\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from its current owner to `to`, or alternatively mints (or burns) if the current owner\n     * (or `to`) is the zero address. Returns the owner of the `tokenId` before the update.\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that\n     * `auth` is either the owner of the token, or approved to operate on the token (by the owner).\n     *\n     * Emits a {Transfer} event.\n     *\n     * NOTE: If overriding this function in a way that tracks balances, see also {_increaseBalance}.\n     */\n    function _update(address to, uint256 tokenId, address auth) internal virtual returns (address) {\n        address from = _ownerOf(tokenId);\n\n        // Perform (optional) operator check\n        if (auth != address(0)) {\n            _checkAuthorized(from, auth, tokenId);\n        }\n\n        // Execute the update\n        if (from != address(0)) {\n            // Clear approval. No need to re-authorize or emit the Approval event\n            _approve(address(0), tokenId, address(0), false);\n\n            unchecked {\n                _balances[from] -= 1;\n            }\n        }\n\n        if (to != address(0)) {\n            unchecked {\n                _balances[to] += 1;\n            }\n        }\n\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        return from;\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner != address(0)) {\n            revert ERC721InvalidSender(address(0));\n        }\n    }\n\n    /**\n     * @dev Mints `tokenId`, transfers it to `to` and checks for `to` acceptance.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(address to, uint256 tokenId, bytes memory data) internal virtual {\n        _mint(to, tokenId);\n        _checkOnERC721Received(address(0), to, tokenId, data);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     * This is an internal function that does not check if the sender is authorized to operate on the token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal {\n        address previousOwner = _update(address(0), tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(address from, address to, uint256 tokenId) internal {\n        if (to == address(0)) {\n            revert ERC721InvalidReceiver(address(0));\n        }\n        address previousOwner = _update(to, tokenId, address(0));\n        if (previousOwner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        } else if (previousOwner != from) {\n            revert ERC721IncorrectOwner(from, tokenId, previousOwner);\n        }\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking that contract recipients\n     * are aware of the ERC721 standard to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is like {safeTransferFrom} in the sense that it invokes\n     * {IERC721Receiver-onERC721Received} on the receiver, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `tokenId` token must exist and be owned by `from`.\n     * - `to` cannot be the zero address.\n     * - `from` cannot be the zero address.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId) internal {\n        _safeTransfer(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeTransfer-address-address-uint256-}[`_safeTransfer`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeTransfer(address from, address to, uint256 tokenId, bytes memory data) internal virtual {\n        _transfer(from, to, tokenId);\n        _checkOnERC721Received(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * The `auth` argument is optional. If the value passed is non 0, then this function will check that `auth` is\n     * either the owner of the token, or approved to operate on all tokens held by this owner.\n     *\n     * Emits an {Approval} event.\n     *\n     * Overrides to this logic should be done to the variant with an additional `bool emitEvent` argument.\n     */\n    function _approve(address to, uint256 tokenId, address auth) internal {\n        _approve(to, tokenId, auth, true);\n    }\n\n    /**\n     * @dev Variant of `_approve` with an optional flag to enable or disable the {Approval} event. The event is not\n     * emitted in the context of transfers.\n     */\n    function _approve(address to, uint256 tokenId, address auth, bool emitEvent) internal virtual {\n        // Avoid reading the owner unless necessary\n        if (emitEvent || auth != address(0)) {\n            address owner = _requireOwned(tokenId);\n\n            // We do not use _isAuthorized because single-token approvals should not be able to call approve\n            if (auth != address(0) && owner != auth && !isApprovedForAll(owner, auth)) {\n                revert ERC721InvalidApprover(auth);\n            }\n\n            if (emitEvent) {\n                emit Approval(owner, to, tokenId);\n            }\n        }\n\n        _tokenApprovals[tokenId] = to;\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Requirements:\n     * - operator can't be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(address owner, address operator, bool approved) internal virtual {\n        if (operator == address(0)) {\n            revert ERC721InvalidOperator(operator);\n        }\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` doesn't have a current owner (it hasn't been minted, or it has been burned).\n     * Returns the owner.\n     *\n     * Overrides to ownership logic should be done to {_ownerOf}.\n     */\n    function _requireOwned(uint256 tokenId) internal view returns (address) {\n        address owner = _ownerOf(tokenId);\n        if (owner == address(0)) {\n            revert ERC721NonexistentToken(tokenId);\n        }\n        return owner;\n    }\n\n    /**\n     * @dev Private function to invoke {IERC721Receiver-onERC721Received} on a target address. This will revert if the\n     * recipient doesn't accept the token transfer. The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     */\n    function _checkOnERC721Received(address from, address to, uint256 tokenId, bytes memory data) private {\n        if (to.code.length > 0) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                if (retval != IERC721Receiver.onERC721Received.selector) {\n                    revert ERC721InvalidReceiver(to);\n                }\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert ERC721InvalidReceiver(to);\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.20;\n\nimport {ERC721} from \"../ERC721.sol\";\nimport {Strings} from \"../../../utils/Strings.sol\";\nimport {IERC4906} from \"../../../interfaces/IERC4906.sol\";\nimport {IERC165} from \"../../../interfaces/IERC165.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is IERC4906, ERC721 {\n    using Strings for uint256;\n\n    // Interface ID as defined in ERC-4906. This does not correspond to a traditional interface ID as ERC-4906 only\n    // defines events and does not include any external function.\n    bytes4 private constant ERC4906_INTERFACE_ID = bytes4(0x49064906);\n\n    // Optional mapping for token URIs\n    mapping(uint256 tokenId => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC165-supportsInterface}\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC721, IERC165) returns (bool) {\n        return interfaceId == ERC4906_INTERFACE_ID || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireOwned(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via string.concat).\n        if (bytes(_tokenURI).length > 0) {\n            return string.concat(base, _tokenURI);\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Emits {MetadataUpdate}.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        _tokenURIs[tokenId] = _tokenURI;\n        emit MetadataUpdate(tokenId);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC721} from \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId, bytes calldata data) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or\n     *   {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon\n     *   a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Note that the caller is responsible to confirm that the recipient is capable of receiving ERC721\n     * or else they may be permanently lost. Usage of {safeTransferFrom} prevents loss, though the caller must\n     * understand this adds an external call which potentially creates a reentrancy vulnerability.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address from, address to, uint256 tokenId) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the address zero.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be\n     * reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error AddressInsufficientBalance(address account);\n\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedInnerCall();\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert AddressInsufficientBalance(address(this));\n        }\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            revert FailedInnerCall();\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {FailedInnerCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert AddressInsufficientBalance(address(this));\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {FailedInnerCall}) in case of an\n     * unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {FailedInnerCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {FailedInnerCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            /// @solidity memory-safe-assembly\n            assembly {\n                let returndata_size := mload(returndata)\n                revert(add(32, returndata), returndata_size)\n            }\n        } else {\n            revert FailedInnerCall();\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.1) (utils/Context.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    function _contextSuffixLength() internal view virtual returns (uint256) {\n        return 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/MerkleProof.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/cryptography/MerkleProof.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev These functions deal with verification of Merkle Tree proofs.\n *\n * The tree and the proofs can be generated using our\n * https://github.com/OpenZeppelin/merkle-tree[JavaScript library].\n * You will find a quickstart guide in the readme.\n *\n * WARNING: You should avoid using leaf values that are 64 bytes long prior to\n * hashing, or use a hash function other than keccak256 for hashing leaves.\n * This is because the concatenation of a sorted pair of internal nodes in\n * the Merkle tree could be reinterpreted as a leaf value.\n * OpenZeppelin's JavaScript library generates Merkle trees that are safe\n * against this attack out of the box.\n */\nlibrary MerkleProof {\n    /**\n     *@dev The multiproof provided is not valid.\n     */\n    error MerkleProofInvalidMultiproof();\n\n    /**\n     * @dev Returns true if a `leaf` can be proved to be a part of a Merkle tree\n     * defined by `root`. For this, a `proof` must be provided, containing\n     * sibling hashes on the branch from the leaf to the root of the tree. Each\n     * pair of leaves and each pair of pre-images are assumed to be sorted.\n     */\n    function verify(bytes32[] memory proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProof(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Calldata version of {verify}\n     */\n    function verifyCalldata(bytes32[] calldata proof, bytes32 root, bytes32 leaf) internal pure returns (bool) {\n        return processProofCalldata(proof, leaf) == root;\n    }\n\n    /**\n     * @dev Returns the rebuilt hash obtained by traversing a Merkle tree up\n     * from `leaf` using `proof`. A `proof` is valid if and only if the rebuilt\n     * hash matches the root of the tree. When processing the proof, the pairs\n     * of leafs & pre-images are assumed to be sorted.\n     */\n    function processProof(bytes32[] memory proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Calldata version of {processProof}\n     */\n    function processProofCalldata(bytes32[] calldata proof, bytes32 leaf) internal pure returns (bytes32) {\n        bytes32 computedHash = leaf;\n        for (uint256 i = 0; i < proof.length; i++) {\n            computedHash = _hashPair(computedHash, proof[i]);\n        }\n        return computedHash;\n    }\n\n    /**\n     * @dev Returns true if the `leaves` can be simultaneously proven to be a part of a Merkle tree defined by\n     * `root`, according to `proof` and `proofFlags` as described in {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerify(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProof(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Calldata version of {multiProofVerify}\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function multiProofVerifyCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32 root,\n        bytes32[] memory leaves\n    ) internal pure returns (bool) {\n        return processMultiProofCalldata(proof, proofFlags, leaves) == root;\n    }\n\n    /**\n     * @dev Returns the root of a tree reconstructed from `leaves` and sibling nodes in `proof`. The reconstruction\n     * proceeds by incrementally reconstructing all inner nodes by combining a leaf/inner node with either another\n     * leaf/inner node or a proof sibling node, depending on whether each `proofFlags` item is true or false\n     * respectively.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. To use multiproofs, it is sufficient to ensure that: 1) the tree\n     * is complete (but not necessarily perfect), 2) the leaves to be proven are in the opposite order they are in the\n     * tree (i.e., as seen from right to left starting at the deepest layer and continuing at the next layer).\n     */\n    function processMultiProof(\n        bytes32[] memory proof,\n        bool[] memory proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Calldata version of {processMultiProof}.\n     *\n     * CAUTION: Not all Merkle trees admit multiproofs. See {processMultiProof} for details.\n     */\n    function processMultiProofCalldata(\n        bytes32[] calldata proof,\n        bool[] calldata proofFlags,\n        bytes32[] memory leaves\n    ) internal pure returns (bytes32 merkleRoot) {\n        // This function rebuilds the root hash by traversing the tree up from the leaves. The root is rebuilt by\n        // consuming and producing values on a queue. The queue starts with the `leaves` array, then goes onto the\n        // `hashes` array. At the end of the process, the last hash in the `hashes` array should contain the root of\n        // the Merkle tree.\n        uint256 leavesLen = leaves.length;\n        uint256 proofLen = proof.length;\n        uint256 totalHashes = proofFlags.length;\n\n        // Check proof validity.\n        if (leavesLen + proofLen != totalHashes + 1) {\n            revert MerkleProofInvalidMultiproof();\n        }\n\n        // The xxxPos values are \"pointers\" to the next value to consume in each array. All accesses are done using\n        // `xxx[xxxPos++]`, which return the current value and increment the pointer, thus mimicking a queue's \"pop\".\n        bytes32[] memory hashes = new bytes32[](totalHashes);\n        uint256 leafPos = 0;\n        uint256 hashPos = 0;\n        uint256 proofPos = 0;\n        // At each step, we compute the next hash using two values:\n        // - a value from the \"main queue\". If not all leaves have been consumed, we get the next leaf, otherwise we\n        //   get the next hash.\n        // - depending on the flag, either another value from the \"main queue\" (merging branches) or an element from the\n        //   `proof` array.\n        for (uint256 i = 0; i < totalHashes; i++) {\n            bytes32 a = leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++];\n            bytes32 b = proofFlags[i]\n                ? (leafPos < leavesLen ? leaves[leafPos++] : hashes[hashPos++])\n                : proof[proofPos++];\n            hashes[i] = _hashPair(a, b);\n        }\n\n        if (totalHashes > 0) {\n            if (proofPos != proofLen) {\n                revert MerkleProofInvalidMultiproof();\n            }\n            unchecked {\n                return hashes[totalHashes - 1];\n            }\n        } else if (leavesLen > 0) {\n            return leaves[0];\n        } else {\n            return proof[0];\n        }\n    }\n\n    /**\n     * @dev Sorts the pair (a, b) and hashes the result.\n     */\n    function _hashPair(bytes32 a, bytes32 b) private pure returns (bytes32) {\n        return a < b ? _efficientHash(a, b) : _efficientHash(b, a);\n    }\n\n    /**\n     * @dev Implementation of keccak256(abi.encode(a, b)) that doesn't allocate or expand memory.\n     */\n    function _efficientHash(bytes32 a, bytes32 b) private pure returns (bytes32 value) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            mstore(0x00, a)\n            mstore(0x20, b)\n            value := keccak256(0x00, 0x40)\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.20;\n\nimport {IERC165} from \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/utils/math/Math.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary Math {\n    /**\n     * @dev Muldiv operation overflow.\n     */\n    error MathOverflowedMulDiv();\n\n    enum Rounding {\n        Floor, // Toward negative infinity\n        Ceil, // Toward positive infinity\n        Trunc, // Toward zero\n        Expand // Away from zero\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds towards infinity instead\n     * of rounding towards zero.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (b == 0) {\n            // Guarantee the same behavior as in a regular Solidity division.\n            return a / b;\n        }\n\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or\n     * denominator == 0.\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv) with further edits by\n     * Uniswap Labs also under MIT license.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0 = x * y; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                // Solidity will revert if denominator == 0, unlike the div opcode on its own.\n                // The surrounding unchecked block does not change this fact.\n                // See https://docs.soliditylang.org/en/latest/control-structures.html#checked-or-unchecked-arithmetic.\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            if (denominator <= prod1) {\n                revert MathOverflowedMulDiv();\n            }\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator.\n            // Always >= 1. See https://cs.stackexchange.com/q/138556/92363.\n\n            uint256 twos = denominator & (0 - denominator);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also\n            // works in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(uint256 x, uint256 y, uint256 denominator, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (unsignedRoundsUp(rounding) && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. If the number is not a perfect square, the value is rounded\n     * towards zero.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        //\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`. This value can be written `msb(a)=2**k` with `k=log2(a)`.\n        //\n        // This can be rewritten `2**log2(a) <= a < 2**(log2(a) + 1)`\n        // → `sqrt(2**k) <= sqrt(a) < sqrt(2**(k+1))`\n        // → `2**(k/2) <= sqrt(a) < 2**((k+1)/2) <= 2**(k/2 + 1)`\n        //\n        // Consequently, `2**(log2(a) / 2)` is a good first approximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1 << (log2(a) >> 1);\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = sqrt(a);\n            return result + (unsignedRoundsUp(rounding) && result * result < a ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 2 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 128;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 64;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 32;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 16;\n            }\n            if (value >> 8 > 0) {\n                value >>= 8;\n                result += 8;\n            }\n            if (value >> 4 > 0) {\n                value >>= 4;\n                result += 4;\n            }\n            if (value >> 2 > 0) {\n                value >>= 2;\n                result += 2;\n            }\n            if (value >> 1 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 2, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log2(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log2(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 10 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >= 10 ** 64) {\n                value /= 10 ** 64;\n                result += 64;\n            }\n            if (value >= 10 ** 32) {\n                value /= 10 ** 32;\n                result += 32;\n            }\n            if (value >= 10 ** 16) {\n                value /= 10 ** 16;\n                result += 16;\n            }\n            if (value >= 10 ** 8) {\n                value /= 10 ** 8;\n                result += 8;\n            }\n            if (value >= 10 ** 4) {\n                value /= 10 ** 4;\n                result += 4;\n            }\n            if (value >= 10 ** 2) {\n                value /= 10 ** 2;\n                result += 2;\n            }\n            if (value >= 10 ** 1) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 10, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log10(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log10(value);\n            return result + (unsignedRoundsUp(rounding) && 10 ** result < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Return the log in base 256 of a positive value rounded towards zero.\n     * Returns 0 if given 0.\n     *\n     * Adding one to the result gives the number of pairs of hex symbols needed to represent `value` as a hex string.\n     */\n    function log256(uint256 value) internal pure returns (uint256) {\n        uint256 result = 0;\n        unchecked {\n            if (value >> 128 > 0) {\n                value >>= 128;\n                result += 16;\n            }\n            if (value >> 64 > 0) {\n                value >>= 64;\n                result += 8;\n            }\n            if (value >> 32 > 0) {\n                value >>= 32;\n                result += 4;\n            }\n            if (value >> 16 > 0) {\n                value >>= 16;\n                result += 2;\n            }\n            if (value >> 8 > 0) {\n                result += 1;\n            }\n        }\n        return result;\n    }\n\n    /**\n     * @dev Return the log in base 256, following the selected rounding direction, of a positive value.\n     * Returns 0 if given 0.\n     */\n    function log256(uint256 value, Rounding rounding) internal pure returns (uint256) {\n        unchecked {\n            uint256 result = log256(value);\n            return result + (unsignedRoundsUp(rounding) && 1 << (result << 3) < value ? 1 : 0);\n        }\n    }\n\n    /**\n     * @dev Returns whether a provided rounding mode is considered rounding up for unsigned integers.\n     */\n    function unsignedRoundsUp(Rounding rounding) internal pure returns (bool) {\n        return uint8(rounding) % 2 == 1;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SignedMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/math/SignedMath.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Standard signed math utilities missing in the Solidity language.\n */\nlibrary SignedMath {\n    /**\n     * @dev Returns the largest of two signed numbers.\n     */\n    function max(int256 a, int256 b) internal pure returns (int256) {\n        return a > b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two signed numbers.\n     */\n    function min(int256 a, int256 b) internal pure returns (int256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two signed numbers without overflow.\n     * The result is rounded towards zero.\n     */\n    function average(int256 a, int256 b) internal pure returns (int256) {\n        // Formula from the book \"Hacker's Delight\"\n        int256 x = (a & b) + ((a ^ b) >> 1);\n        return x + (int256(uint256(x) >> 255) & (a ^ b));\n    }\n\n    /**\n     * @dev Returns the absolute unsigned value of a signed value.\n     */\n    function abs(int256 n) internal pure returns (uint256) {\n        unchecked {\n            // must be unchecked in order to support `n = type(int256).min`\n            return uint256(n >= 0 ? n : -n);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Pausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Pausable.sol)\n\npragma solidity ^0.8.20;\n\nimport {Context} from \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract Pausable is Context {\n    bool private _paused;\n\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    /**\n     * @dev The operation failed because the contract is paused.\n     */\n    error EnforcedPause();\n\n    /**\n     * @dev The operation failed because the contract is not paused.\n     */\n    error ExpectedPause();\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    constructor() {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        if (paused()) {\n            revert EnforcedPause();\n        }\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        if (!paused()) {\n            revert ExpectedPause();\n        }\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/Strings.sol)\n\npragma solidity ^0.8.20;\n\nimport {Math} from \"./math/Math.sol\";\nimport {SignedMath} from \"./math/SignedMath.sol\";\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant HEX_DIGITS = \"0123456789abcdef\";\n    uint8 private constant ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev The `value` string doesn't fit in the specified `length`.\n     */\n    error StringsInsufficientHexLength(uint256 value, uint256 length);\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            uint256 length = Math.log10(value) + 1;\n            string memory buffer = new string(length);\n            uint256 ptr;\n            /// @solidity memory-safe-assembly\n            assembly {\n                ptr := add(buffer, add(32, length))\n            }\n            while (true) {\n                ptr--;\n                /// @solidity memory-safe-assembly\n                assembly {\n                    mstore8(ptr, byte(mod(value, 10), HEX_DIGITS))\n                }\n                value /= 10;\n                if (value == 0) break;\n            }\n            return buffer;\n        }\n    }\n\n    /**\n     * @dev Converts a `int256` to its ASCII `string` decimal representation.\n     */\n    function toStringSigned(int256 value) internal pure returns (string memory) {\n        return string.concat(value < 0 ? \"-\" : \"\", toString(SignedMath.abs(value)));\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        unchecked {\n            return toHexString(value, Math.log256(value) + 1);\n        }\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        uint256 localValue = value;\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = HEX_DIGITS[localValue & 0xf];\n            localValue >>= 4;\n        }\n        if (localValue != 0) {\n            revert StringsInsufficientHexLength(value, length);\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal\n     * representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), ADDRESS_LENGTH);\n    }\n\n    /**\n     * @dev Returns true if the two strings are equal.\n     */\n    function equal(string memory a, string memory b) internal pure returns (bool) {\n        return bytes(a).length == bytes(b).length && keccak256(bytes(a)) == keccak256(bytes(b));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableMap.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableMap.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableMap.js.\n\npragma solidity ^0.8.20;\n\nimport {EnumerableSet} from \"./EnumerableSet.sol\";\n\n/**\n * @dev Library for managing an enumerable variant of Solidity's\n * https://solidity.readthedocs.io/en/latest/types.html#mapping-types[`mapping`]\n * type.\n *\n * Maps have the following properties:\n *\n * - Entries are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Entries are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableMap for EnumerableMap.UintToAddressMap;\n *\n *     // Declare a set state variable\n *     EnumerableMap.UintToAddressMap private myMap;\n * }\n * ```\n *\n * The following map types are supported:\n *\n * - `uint256 -> address` (`UintToAddressMap`) since v3.0.0\n * - `address -> uint256` (`AddressToUintMap`) since v4.6.0\n * - `bytes32 -> bytes32` (`Bytes32ToBytes32Map`) since v4.6.0\n * - `uint256 -> uint256` (`UintToUintMap`) since v4.7.0\n * - `bytes32 -> uint256` (`Bytes32ToUintMap`) since v4.7.0\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableMap, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableMap.\n * ====\n */\nlibrary EnumerableMap {\n    using EnumerableSet for EnumerableSet.Bytes32Set;\n\n    // To implement this library for multiple types with as little code repetition as possible, we write it in\n    // terms of a generic Map type with bytes32 keys and values. The Map implementation uses private functions,\n    // and user-facing implementations such as `UintToAddressMap` are just wrappers around the underlying Map.\n    // This means that we can only create new EnumerableMaps for types that fit in bytes32.\n\n    /**\n     * @dev Query for a nonexistent map key.\n     */\n    error EnumerableMapNonexistentKey(bytes32 key);\n\n    struct Bytes32ToBytes32Map {\n        // Storage of keys\n        EnumerableSet.Bytes32Set _keys;\n        mapping(bytes32 key => bytes32) _values;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToBytes32Map storage map, bytes32 key, bytes32 value) internal returns (bool) {\n        map._values[key] = value;\n        return map._keys.add(key);\n    }\n\n    /**\n     * @dev Removes a key-value pair from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToBytes32Map storage map, bytes32 key) internal returns (bool) {\n        delete map._values[key];\n        return map._keys.remove(key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool) {\n        return map._keys.contains(key);\n    }\n\n    /**\n     * @dev Returns the number of key-value pairs in the map. O(1).\n     */\n    function length(Bytes32ToBytes32Map storage map) internal view returns (uint256) {\n        return map._keys.length();\n    }\n\n    /**\n     * @dev Returns the key-value pair stored at position `index` in the map. O(1).\n     *\n     * Note that there are no guarantees on the ordering of entries inside the\n     * array, and it may change when more entries are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToBytes32Map storage map, uint256 index) internal view returns (bytes32, bytes32) {\n        bytes32 key = map._keys.at(index);\n        return (key, map._values[key]);\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bool, bytes32) {\n        bytes32 value = map._values[key];\n        if (value == bytes32(0)) {\n            return (contains(map, key), bytes32(0));\n        } else {\n            return (true, value);\n        }\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToBytes32Map storage map, bytes32 key) internal view returns (bytes32) {\n        bytes32 value = map._values[key];\n        if (value == 0 && !contains(map, key)) {\n            revert EnumerableMapNonexistentKey(key);\n        }\n        return value;\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToBytes32Map storage map) internal view returns (bytes32[] memory) {\n        return map._keys.values();\n    }\n\n    // UintToUintMap\n\n    struct UintToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToUintMap storage map, uint256 key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToUintMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToUintMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToUintMap storage map, uint256 index) internal view returns (uint256, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToUintMap storage map, uint256 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToUintMap storage map, uint256 key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(key)));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToUintMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintToAddressMap\n\n    struct UintToAddressMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(UintToAddressMap storage map, uint256 key, address value) internal returns (bool) {\n        return set(map._inner, bytes32(key), bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(UintToAddressMap storage map, uint256 key) internal returns (bool) {\n        return remove(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(UintToAddressMap storage map, uint256 key) internal view returns (bool) {\n        return contains(map._inner, bytes32(key));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(UintToAddressMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintToAddressMap storage map, uint256 index) internal view returns (uint256, address) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (uint256(key), address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(UintToAddressMap storage map, uint256 key) internal view returns (bool, address) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(key));\n        return (success, address(uint160(uint256(value))));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(UintToAddressMap storage map, uint256 key) internal view returns (address) {\n        return address(uint160(uint256(get(map._inner, bytes32(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(UintToAddressMap storage map) internal view returns (uint256[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressToUintMap\n\n    struct AddressToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(AddressToUintMap storage map, address key, uint256 value) internal returns (bool) {\n        return set(map._inner, bytes32(uint256(uint160(key))), bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(AddressToUintMap storage map, address key) internal returns (bool) {\n        return remove(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(AddressToUintMap storage map, address key) internal view returns (bool) {\n        return contains(map._inner, bytes32(uint256(uint160(key))));\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(AddressToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressToUintMap storage map, uint256 index) internal view returns (address, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (address(uint160(uint256(key))), uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(AddressToUintMap storage map, address key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, bytes32(uint256(uint160(key))));\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(AddressToUintMap storage map, address key) internal view returns (uint256) {\n        return uint256(get(map._inner, bytes32(uint256(uint160(key)))));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(AddressToUintMap storage map) internal view returns (address[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // Bytes32ToUintMap\n\n    struct Bytes32ToUintMap {\n        Bytes32ToBytes32Map _inner;\n    }\n\n    /**\n     * @dev Adds a key-value pair to a map, or updates the value for an existing\n     * key. O(1).\n     *\n     * Returns true if the key was added to the map, that is if it was not\n     * already present.\n     */\n    function set(Bytes32ToUintMap storage map, bytes32 key, uint256 value) internal returns (bool) {\n        return set(map._inner, key, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a map. O(1).\n     *\n     * Returns true if the key was removed from the map, that is if it was present.\n     */\n    function remove(Bytes32ToUintMap storage map, bytes32 key) internal returns (bool) {\n        return remove(map._inner, key);\n    }\n\n    /**\n     * @dev Returns true if the key is in the map. O(1).\n     */\n    function contains(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool) {\n        return contains(map._inner, key);\n    }\n\n    /**\n     * @dev Returns the number of elements in the map. O(1).\n     */\n    function length(Bytes32ToUintMap storage map) internal view returns (uint256) {\n        return length(map._inner);\n    }\n\n    /**\n     * @dev Returns the element stored at position `index` in the map. O(1).\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32ToUintMap storage map, uint256 index) internal view returns (bytes32, uint256) {\n        (bytes32 key, bytes32 value) = at(map._inner, index);\n        return (key, uint256(value));\n    }\n\n    /**\n     * @dev Tries to returns the value associated with `key`. O(1).\n     * Does not revert if `key` is not in the map.\n     */\n    function tryGet(Bytes32ToUintMap storage map, bytes32 key) internal view returns (bool, uint256) {\n        (bool success, bytes32 value) = tryGet(map._inner, key);\n        return (success, uint256(value));\n    }\n\n    /**\n     * @dev Returns the value associated with `key`. O(1).\n     *\n     * Requirements:\n     *\n     * - `key` must be in the map.\n     */\n    function get(Bytes32ToUintMap storage map, bytes32 key) internal view returns (uint256) {\n        return uint256(get(map._inner, key));\n    }\n\n    /**\n     * @dev Return the an array containing all the keys\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the map grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function keys(Bytes32ToUintMap storage map) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = keys(map._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/structs/EnumerableSet.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.0.0) (utils/structs/EnumerableSet.sol)\n// This file was procedurally generated from scripts/generate/templates/EnumerableSet.js.\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Library for managing\n * https://en.wikipedia.org/wiki/Set_(abstract_data_type)[sets] of primitive\n * types.\n *\n * Sets have the following properties:\n *\n * - Elements are added, removed, and checked for existence in constant time\n * (O(1)).\n * - Elements are enumerated in O(n). No guarantees are made on the ordering.\n *\n * ```solidity\n * contract Example {\n *     // Add the library methods\n *     using EnumerableSet for EnumerableSet.AddressSet;\n *\n *     // Declare a set state variable\n *     EnumerableSet.AddressSet private mySet;\n * }\n * ```\n *\n * As of v3.3.0, sets of type `bytes32` (`Bytes32Set`), `address` (`AddressSet`)\n * and `uint256` (`UintSet`) are supported.\n *\n * [WARNING]\n * ====\n * Trying to delete such a structure from storage will likely result in data corruption, rendering the structure\n * unusable.\n * See https://github.com/ethereum/solidity/pull/11843[ethereum/solidity#11843] for more info.\n *\n * In order to clean an EnumerableSet, you can either remove all elements one by one or create a fresh instance using an\n * array of EnumerableSet.\n * ====\n */\nlibrary EnumerableSet {\n    // To implement this library for multiple types with as little code\n    // repetition as possible, we write it in terms of a generic Set type with\n    // bytes32 values.\n    // The Set implementation uses private functions, and user-facing\n    // implementations (such as AddressSet) are just wrappers around the\n    // underlying Set.\n    // This means that we can only create new EnumerableSets for types that fit\n    // in bytes32.\n\n    struct Set {\n        // Storage of set values\n        bytes32[] _values;\n        // Position is the index of the value in the `values` array plus 1.\n        // Position 0 is used to mean a value is not in the set.\n        mapping(bytes32 value => uint256) _positions;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function _add(Set storage set, bytes32 value) private returns (bool) {\n        if (!_contains(set, value)) {\n            set._values.push(value);\n            // The value is stored at length-1, but we add 1 to all indexes\n            // and use 0 as a sentinel value\n            set._positions[value] = set._values.length;\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function _remove(Set storage set, bytes32 value) private returns (bool) {\n        // We cache the value's position to prevent multiple reads from the same storage slot\n        uint256 position = set._positions[value];\n\n        if (position != 0) {\n            // Equivalent to contains(set, value)\n            // To delete an element from the _values array in O(1), we swap the element to delete with the last one in\n            // the array, and then remove the last element (sometimes called as 'swap and pop').\n            // This modifies the order of the array, as noted in {at}.\n\n            uint256 valueIndex = position - 1;\n            uint256 lastIndex = set._values.length - 1;\n\n            if (valueIndex != lastIndex) {\n                bytes32 lastValue = set._values[lastIndex];\n\n                // Move the lastValue to the index where the value to delete is\n                set._values[valueIndex] = lastValue;\n                // Update the tracked position of the lastValue (that was just moved)\n                set._positions[lastValue] = position;\n            }\n\n            // Delete the slot where the moved value was stored\n            set._values.pop();\n\n            // Delete the tracked position for the deleted slot\n            delete set._positions[value];\n\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function _contains(Set storage set, bytes32 value) private view returns (bool) {\n        return set._positions[value] != 0;\n    }\n\n    /**\n     * @dev Returns the number of values on the set. O(1).\n     */\n    function _length(Set storage set) private view returns (uint256) {\n        return set._values.length;\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function _at(Set storage set, uint256 index) private view returns (bytes32) {\n        return set._values[index];\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function _values(Set storage set) private view returns (bytes32[] memory) {\n        return set._values;\n    }\n\n    // Bytes32Set\n\n    struct Bytes32Set {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _add(set._inner, value);\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(Bytes32Set storage set, bytes32 value) internal returns (bool) {\n        return _remove(set._inner, value);\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(Bytes32Set storage set, bytes32 value) internal view returns (bool) {\n        return _contains(set._inner, value);\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(Bytes32Set storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(Bytes32Set storage set, uint256 index) internal view returns (bytes32) {\n        return _at(set._inner, index);\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(Bytes32Set storage set) internal view returns (bytes32[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        bytes32[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // AddressSet\n\n    struct AddressSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(AddressSet storage set, address value) internal returns (bool) {\n        return _add(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(AddressSet storage set, address value) internal returns (bool) {\n        return _remove(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(AddressSet storage set, address value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(uint256(uint160(value))));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(AddressSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(AddressSet storage set, uint256 index) internal view returns (address) {\n        return address(uint160(uint256(_at(set._inner, index))));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(AddressSet storage set) internal view returns (address[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        address[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n\n    // UintSet\n\n    struct UintSet {\n        Set _inner;\n    }\n\n    /**\n     * @dev Add a value to a set. O(1).\n     *\n     * Returns true if the value was added to the set, that is if it was not\n     * already present.\n     */\n    function add(UintSet storage set, uint256 value) internal returns (bool) {\n        return _add(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Removes a value from a set. O(1).\n     *\n     * Returns true if the value was removed from the set, that is if it was\n     * present.\n     */\n    function remove(UintSet storage set, uint256 value) internal returns (bool) {\n        return _remove(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns true if the value is in the set. O(1).\n     */\n    function contains(UintSet storage set, uint256 value) internal view returns (bool) {\n        return _contains(set._inner, bytes32(value));\n    }\n\n    /**\n     * @dev Returns the number of values in the set. O(1).\n     */\n    function length(UintSet storage set) internal view returns (uint256) {\n        return _length(set._inner);\n    }\n\n    /**\n     * @dev Returns the value stored at position `index` in the set. O(1).\n     *\n     * Note that there are no guarantees on the ordering of values inside the\n     * array, and it may change when more values are added or removed.\n     *\n     * Requirements:\n     *\n     * - `index` must be strictly less than {length}.\n     */\n    function at(UintSet storage set, uint256 index) internal view returns (uint256) {\n        return uint256(_at(set._inner, index));\n    }\n\n    /**\n     * @dev Return the entire set in an array\n     *\n     * WARNING: This operation will copy the entire storage to memory, which can be quite expensive. This is designed\n     * to mostly be used by view accessors that are queried without any gas fees. Developers should keep in mind that\n     * this function has an unbounded cost, and using it as part of a state-changing function may render the function\n     * uncallable if the set grows to a point where copying to memory consumes too much gas to fit in a block.\n     */\n    function values(UintSet storage set) internal view returns (uint256[] memory) {\n        bytes32[] memory store = _values(set._inner);\n        uint256[] memory result;\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            result := store\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/Campaign.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\n// import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/IERC721.sol\";\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\n// import \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport './Lockers/DexLockerFactory.sol';\r\nimport {IDexLocker} from './Lockers/DexLocker.sol';\r\nimport \"./Lockers/VestSchedule.sol\";\r\nimport \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\r\nimport \"hardhat/console.sol\";\r\nimport {IDexRouter} from \"./IDexRouter.sol\";\r\nimport {ICampaignList} from \"./CampaignList.sol\";\r\nimport \"./Errors.sol\";\r\n\r\n\r\ncontract Campaign is Initializable,Ownable, ReentrancyGuard {\r\n  using SafeERC20 for IERC20;\r\n\r\n  uint256 constant private MAX_INT = 2**256 - 1;\r\n\r\n  event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);\r\n  event ValueReceived(address user, uint amount);\r\n  event Withdrawn(address user, uint amount);\r\n  event Refunded(address user, uint amount);\r\n  event SoldOut();\r\n  event LiquidityAddedToRouter(address indexed router, address indexed token1,address indexed token2, uint amountToken1, uint amountToken2);\r\n\r\n  struct CampaignSaleInfo {\r\n      //token attributes\r\n      address   tokenAddress; \r\n      uint256  softCap; // Soft cap in coin\r\n      uint256  hardCap; // Max cap in coin\r\n      uint256  saleStartTime; // start sale time\r\n      uint256  saleEndTime; // end sale time\r\n      uint   liquidityPercent; // multiplied by 100 e.g 45% is 4500\r\n      uint   listRate; \r\n      uint   dexListRate;\r\n      RefundType  refundType;\r\n      string logoUrl;\r\n      string desc;\r\n      string website;\r\n      string twitter;\r\n      string telegram;\r\n      string discord;\r\n      // string bannerImage;\r\n      \r\n  }\r\n  enum CampaignStatus{ \r\n    CREATED,\r\n    TOKENS_SUBMITTED,//Owner has transferred the correct no of tokens and campaign is ready to receive\r\n    CANCELLED, // Cancelled before the start date\r\n    \r\n    FAILED, // WIll need refund\r\n    LIQUIDITY_SETUP\r\n\r\n  }\r\n\r\n  bool   public useWhiteList;//Use in only Tier 2\r\n  bool   public hasKYC;\r\n  uint public totalTeamTokensToBeVested=0;\r\n  bool _isAudited; \r\n  string public auditUrl;\r\n  CampaignStatus public  status = CampaignStatus.CREATED;\r\n\r\n  address private _admin= 0xB7e16f5fa9941B84baCd1601F277B00911Aed339; //zsales admin - can setkyc and audited\r\n  \r\n  \r\n  CampaignSaleInfo public  saleInfo;\r\n  \r\n  \r\n  address public dexRouterAddress;\r\n  uint256 public totalCoinReceived; // total  received\r\n  uint256 public totalCoinInTierZero;\r\n  uint256 public totalCoinInTierOne; // total coin for tier one\r\n  uint256 public totalCoinInTierTwo; // total coin for tier Tier\r\n\r\n  address public purchaseTokenAddress=address(0); // Token address for Purchases for this campaign - address 0 is native currency\r\n  \r\n\r\n  uint public totalParticipants; // total participants in ido\r\n  \r\n\r\n  address public zsalesTokenAddress = 0x97CEe927A48dc119Fd0b0b1047a879153975e893;\r\n  uint zsaleFee = 200;  //2%   - percent of native currency to take\r\n  uint zsaleTokenFee = 200;  //2% - percent fee of token to take\r\n\r\n  address public zsalesNFTTokenAddress = 0x97CEe927A48dc119Fd0b0b1047a879153975e893;\r\n\r\n\r\n  address zsalesWalletAddress = 0xB7e16f5fa9941B84baCd1601F277B00911Aed339 ; // receives commissions\r\n  address public _campaignFactoryAddress ;\r\n\r\n  uint private tier1TimeLineInHours = 2; // e.g 2 hours before startime\r\n  uint private tier0TimeLineInHours = 3;\r\n\r\n  bool private ownerHasWithdrawnTokens=false;\r\n  \r\n  // max cap per tier\r\n  uint public tierZerohardCap;\r\n  uint public tierOnehardCap;\r\n  uint public tierTwohardCap;\r\n    \r\n  //total users per tier\r\n  // uint public totalUserInTierZero;\r\n  // uint public totalUserInTierOne;\r\n  // uint public totalUserInTierTwo;\r\n  \r\n  bool public useTokenVesting;\r\n  bool public useRaisedFundsVesting;\r\n\r\n\r\n    //Tier 0 - holders of our NFT\r\n    //Tier 1 - holders of our coin\r\n    //Tier 2 - Whitelisted or public\r\n   \r\n  uint public minAllocationPerUser;\r\n  //max allocations per user in a tier\r\n  uint public maxAllocationPerUserTierZero;\r\n  uint public maxAllocationPerUserTierOne;\r\n  uint public maxAllocationPerUserTierTwo; \r\n  \r\n \r\n  // // address array for tier one whitelist\r\n  // address[] private whitelistTierOne;  // every tokenholder is automatically whitelisted\r\n  \r\n  // // address array for tier two whitelist\r\n  // address[] private whitelistTierTwo; \r\n\r\n  bytes32 private _whitelistTierTwoMerkleRoot;\r\n  \r\n\r\n  uint public campaignKey;\r\n  enum RefundType{ BURN, REFUND }\r\n  \r\n  uint256 public liquidityReleaseTime; // time to relesase Lp tokens to owner\r\n\r\n  //mapping the user purchase per tier\r\n  mapping(address => uint) public buyInZeroTier;\r\n  mapping(address => uint) public buyInOneTier;\r\n  mapping(address => uint) public buyInTwoTier;\r\n  mapping(address => uint) public buyInAllTiers;\r\n  DexLockerFactory private _dexLockerFactory;\r\n  address payable public _dexLockerAddress;\r\n  uint private tokenDecimals;\r\n  uint private purchaseCoinDecimals;\r\n  \r\n\r\n  ///Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be taken over by an attacker, which may impact the proxy. \r\n  /// To prevent the implementation contract from being used, you should invoke the _disableInitializers function in the constructor to automatically lock it when it is deployed\r\n  /// @custom:oz-upgrades-unsafe-allow constructor\r\n  constructor() Ownable(msg.sender) {\r\n      _disableInitializers();\r\n  }\r\n\r\n  function initialize(\r\n    \r\n    /** address campaignOwner,\r\n    /* address campaignFactory,\r\n    /* address  _saletokenAddress, */\r\n    /* address  _purchaseTokenAddress, */\r\n    address[4] memory addresses,\r\n\r\n    /** uint256 _normalizedTo18DecimalsSoftCap,\r\n     * uint256 __normalizedTo18DecimalsHardCap,\r\n     * uint256 _saleStartTime,\r\n     * uint256 _saleEndTime, \r\n     * uint256 _nomrlaizedTierOneHardCap, \r\n     * uint256 _nomrlaizedTierTwoHardCap, \r\n     * uint256 _maxAllocationPerUserTierOne, \r\n     * uint256 _maxAllocationPerUserTierTwo ,\r\n     * uint _campaignKey,*/\r\n    uint256[10] memory capAndDate,  \r\n    \r\n    RefundType _refundType, \r\n    address _dexRouterAddress,\r\n\r\n    /**uint _liquidityPercent, \r\n    /* uint liquidityReleaseTime,\r\n    /* uint _listRate, \r\n    /* uint _dexListRate,**/\r\n    uint[4] memory liquidityAllocationAndRates,\r\n\r\n    /**uint totalTeamTokensToBeVested, \r\n    /* uint firstReleasePercent,  \r\n    /* uint firstReleaseDays,\r\n    /* uint subsequentReleasePercent, \r\n    /* uint subsequentReleaseDays,,**/\r\n    uint256[5] memory teamTokenVestingDetails,\r\n\r\n    uint256[3] memory raisedFundVestingDetails,\r\n    \r\n    // UseTeamTokenVesting,\r\n    // UseRaisedFundVesting\r\n    bool[2] memory _useTokenOrRaisedFundVesting,\r\n    // VestSchedule[8] memory teamTokenVestingDetails, \r\n\r\n    \r\n    string[6] memory founderInfo,\r\n    DexLockerFactory dexLockerFactory \r\n  ) public payable initializer {\r\n\r\n    {\r\n      // require(capAndDate[3] > capAndDate[2], \"Sale End time needs to be above start time\");\r\n      // require(liquidityAllocationAndRates[0] >= 5100, \"Liquidity allowed is > 51 %\");\r\n      if (capAndDate[3] <= capAndDate[2]) revert SaleEndTimeBeforeStartTime();\r\n      if (liquidityAllocationAndRates[0] < 5100) revert LiquidityAboveLimit(5100);\r\n\r\n      _campaignFactoryAddress= addresses[1];\r\n      _setDefaultValues();\r\n      campaignKey=capAndDate[9];\r\n      \r\n      _dexLockerFactory=dexLockerFactory;\r\n      purchaseTokenAddress=addresses[3]; \r\n    }\r\n    \r\n      \r\n    // //block scopin to avoid stack too deep \r\n    {\r\n      \r\n      saleInfo = CampaignSaleInfo({\r\n        tokenAddress: addresses[2],\r\n        softCap: capAndDate[0],\r\n        hardCap: capAndDate[1],\r\n        saleStartTime: capAndDate[2], \r\n        saleEndTime: capAndDate[3],   \r\n        liquidityPercent: liquidityAllocationAndRates[0],\r\n        listRate: liquidityAllocationAndRates[2],\r\n        dexListRate: liquidityAllocationAndRates[3],\r\n        refundType: _refundType, \r\n        logoUrl: founderInfo[0],\r\n        desc: founderInfo[1],\r\n        website: founderInfo[2],\r\n        twitter: founderInfo[3],\r\n        telegram: founderInfo[4],\r\n        discord: founderInfo[5]\r\n      });\r\n\r\n      dexRouterAddress=_dexRouterAddress; \r\n    }        \r\n    \r\n    \r\n    \r\n    { \r\n          // _updateTierDetails(capAndDate[4], capAndDate[5], capAndDate[6],capAndDate[7], capAndDate[8]);\r\n      _updateTierDetails(capAndDate);\r\n    \r\n\r\n      _transferOwnership(addresses[0]);\r\n      \r\n\r\n      _updateLockDetails(liquidityAllocationAndRates[1], _useTokenOrRaisedFundVesting[0], teamTokenVestingDetails,_useTokenOrRaisedFundVesting[1], raisedFundVestingDetails );\r\n    }\r\n    \r\n  }\r\n\r\n  //needed since initializable contracts do not have constructors\r\n  function _setDefaultValues() private {\r\n    //status = CampaignStatus.CREATED;\r\n    tier1TimeLineInHours = 2; // e.g 2 hours before startime\r\n\r\n    \r\n    ICampaignList cList = ICampaignList(_campaignFactoryAddress);\r\n    _admin= cList.zsalesAdmin(); //zsales admin - can setkyc and audited\r\n    zsalesTokenAddress = cList.zsalesTokenAddress();\r\n    zsaleFee = cList.zsaleFee();  //2%   - percent of native currency to take\r\n    zsaleTokenFee = cList.zsaleTokenFee();  //2% - percent fee of token to take\r\n    zsalesWalletAddress = cList.zsalesWalletAddress() ; // receives commissions\r\n    \r\n    zsalesNFTTokenAddress= cList.zsalesNFTTokenAddress();\r\n  }\r\n  \r\n  // function to update other details not initialized in constructor - this is bcos solidity limits how many variables u can pass in at once\r\n  function _updateLockDetails(\r\n    uint liquidityReleaseTimeDays, //Time to add to startTime in days\r\n    bool _useTokenVesting,\r\n    uint256[5] memory teamTokenVestingDetails,\r\n    bool _useRaisedFundsVesting, \r\n    uint256[3] memory raisedFundVestingDetails\r\n      \r\n  ) private /*public onlyOwner*/ {\r\n    liquidityReleaseTime  = saleInfo.saleEndTime + (liquidityReleaseTimeDays * 1 days);\r\n    useTokenVesting=_useTokenVesting;\r\n    useRaisedFundsVesting=_useRaisedFundsVesting;\r\n\r\n    \r\n    //Set dexLock\r\n    IDexLocker dexLocker = IDexLocker(payable(_dexLockerFactory.createDexLocker(dexRouterAddress,saleInfo.tokenAddress, purchaseTokenAddress, address(this), msg.sender) ) );\r\n    \r\n    \r\n    dexLocker.setupLock([saleInfo.liquidityPercent,liquidityReleaseTime],[saleInfo.softCap,saleInfo.hardCap],  [saleInfo.listRate,  saleInfo.dexListRate],useTokenVesting, teamTokenVestingDetails, _useRaisedFundsVesting,  raisedFundVestingDetails);\r\n\r\n    \r\n    _dexLockerAddress= payable(address(dexLocker) );\r\n    \r\n    status = CampaignStatus.CREATED;\r\n    totalTeamTokensToBeVested = teamTokenVestingDetails[0];\r\n    \r\n\r\n    // //if doesnt use tokenvesting , _startReceivingBids();\r\n    // if(!useTokenVesting){\r\n    //   _startReceivingBids();\r\n    // }\r\n\r\n    \r\n\r\n  }\r\n  \r\n  function _updateCampaignFounderDetails(\r\n    string memory logoUrl,\r\n    string memory desc,\r\n    string memory website,\r\n    string memory twitter,\r\n    string memory telegram,\r\n    string memory discord\r\n  ) private {\r\n    saleInfo.logoUrl= logoUrl;\r\n    saleInfo.desc= desc;\r\n    saleInfo.website= website;\r\n    saleInfo.twitter= twitter;\r\n    saleInfo.telegram= telegram;\r\n    saleInfo.discord= discord;\r\n  }\r\n\r\n  function updateCampaignFounderDetails(\r\n    string memory logoUrl,\r\n    string memory desc,\r\n    string memory website,\r\n    string memory twitter,\r\n    string memory telegram,\r\n    string memory discord\r\n  ) external onlyOwner {\r\n\r\n        \r\n    if (block.timestamp > saleInfo.saleStartTime) revert UpdateAfterSaleStartTime();\r\n    _updateCampaignFounderDetails(logoUrl,desc,website,twitter,telegram,discord);\r\n  }\r\n\r\n  function _updateTierDetails(uint256[10] memory capAndDate) private {\r\n    \r\n    _updateTierDetails(capAndDate[4], capAndDate[5], capAndDate[6],capAndDate[7], capAndDate[8]);\r\n  }\r\n    \r\n  // function to update the tiers users value manually\r\n  function _updateTierDetails(uint256 _tierOneHardCap, uint256 _tierTwoHardCap, uint256 _minAllocationPerUser, uint256 _maxAllocationPerUserTierOne, uint256 _maxAllocationPerUserTierTwo) private {\r\n    \r\n    tokenDecimals = IERC20Metadata(saleInfo.tokenAddress).decimals();\r\n    purchaseCoinDecimals=18;\r\n    if(purchaseTokenAddress!=address(0)){\r\n      purchaseCoinDecimals = IERC20Metadata(purchaseTokenAddress).decimals();\r\n    }\r\n    \r\n    if (_tierOneHardCap <= saleInfo.hardCap * 3000 / 10000) revert TierCapTooLow(30);\r\n    // if (_tierOneHardCap + _tierTwoHardCap != saleInfo.hardCap) revert TierCapsExceedHardCap();\r\n    if (_tierOneHardCap > saleInfo.hardCap) revert TierOneCapExceedsHardCap();\r\n    if (_tierTwoHardCap > saleInfo.hardCap) revert TierTwoCapExceedsHardCap();\r\n\r\n    if (_minAllocationPerUser < 0) revert MinAllocationOutOfRange();\r\n    if (_maxAllocationPerUserTierOne <= 0) revert TierOneMaxAllocationOutOfRange();\r\n    if (_maxAllocationPerUserTierTwo <= 0) revert TierTwoMaxAllocationOutOfRange();\r\n    \r\n    \r\n    tierZerohardCap = _tierOneHardCap;\r\n    tierOnehardCap =_tierOneHardCap;\r\n    tierTwohardCap = _tierTwoHardCap;    \r\n    \r\n    minAllocationPerUser=_minAllocationPerUser; \r\n    maxAllocationPerUserTierZero = _maxAllocationPerUserTierOne;//same alloc for tier 0 and 1\r\n    maxAllocationPerUserTierOne = _maxAllocationPerUserTierOne;\r\n    maxAllocationPerUserTierTwo = _maxAllocationPerUserTierTwo;\r\n  }\r\n\r\n  function updateTierDetails(uint256 _tierOneHardCap, uint256 _tierTwoHardCap, uint256 _minAllocationPerUser, uint256 _maxAllocationPerUserTierOne, uint256 _maxAllocationPerUserTierTwo) public onlyOwner {\r\n    \r\n    if(block.timestamp > saleInfo.saleStartTime){\r\n      revert UpdateAfterSaleStartTime();\r\n    }\r\n    _updateTierDetails(_tierOneHardCap, _tierTwoHardCap, _minAllocationPerUser, _maxAllocationPerUserTierOne, _maxAllocationPerUserTierTwo);    \r\n  }\r\n\r\n  function _startReceivingBids() private \r\n  {    \r\n    status = CampaignStatus.TOKENS_SUBMITTED;\r\n  }\r\n\r\n  function startReceivingBids() public {\r\n    if (_campaignFactoryAddress != _msgSender()) revert NotOwner();\r\n    _startReceivingBids();\r\n  }\r\n\r\n  function cancelCampaign() public onlyOwner {\r\n      if (block.timestamp >= saleInfo.saleStartTime) revert CannotCancelAfterSaleStartTime();\r\n      status = CampaignStatus.CANCELLED;\r\n  }\r\n\r\n  function postponeSale(uint newDate, uint newEndDate) public onlyOwner {\r\n      if (block.timestamp >= saleInfo.saleStartTime) revert PostponeBeforeSaleStartTime();\r\n      if (newDate <= saleInfo.saleStartTime) revert NewDateLessThanOldDate();\r\n      if (newEndDate <= newDate) revert EndDateLessThanStartTime();\r\n\r\n      saleInfo.saleStartTime = newDate;\r\n      saleInfo.saleEndTime = newEndDate;\r\n  }\r\n\r\n  function getDexListRate() public view returns (uint256) {\r\n    return saleInfo.dexListRate;\r\n  }\r\n\r\n  function getEndDate() public view returns (uint256) {\r\n    return saleInfo.saleEndTime;\r\n  }\r\n\r\n  function totalTokensExpectedToBeLocked() public view returns (uint256) {\r\n    return IDexLocker(_dexLockerAddress).totalTokensExpectedToBeLocked();\r\n  }\r\n\r\n \r\n  function setZSalesTokenAddress(address _tokenAddress) public onlyAdmin {\r\n    zsalesTokenAddress = _tokenAddress;\r\n  }\r\n\r\n\r\n  /**************************|\r\n  |          Tier Info       |\r\n  |_________________________*/\r\n  //add the address in Whitelist tier two to invest\r\n  function disableTier2Whitelist() public onlyOwner {    \r\n    useWhiteList= false;\r\n  }\r\n\r\n  //add the address in Whitelist tier two to invest\r\n  function submitTier2Whitelist(bytes32 whitelistMerkleRoot) public onlyOwner {\r\n    \r\n    if (block.timestamp >= saleInfo.saleStartTime) revert AlterWhitelistingAfterSaleStartTime();\r\n    useWhiteList= true;\r\n    _whitelistTierTwoMerkleRoot=whitelistMerkleRoot;\r\n  }\r\n\r\n  // check the address is a Token Holder\r\n  function isAllowedInTier1(address _address) public view returns(bool) {\r\n\r\n    IERC20 token = IERC20(zsalesTokenAddress);\r\n    return token.balanceOf(_address) > 0;\r\n  }\r\n\r\n  // check the address is a NFT Token Holder\r\n  function isAllowedInTier0(address _address) public view returns(bool) {\r\n\r\n    IERC721 token = IERC721(zsalesNFTTokenAddress);\r\n    return token.balanceOf(_address) > 0;\r\n  }\r\n\r\n\r\n  // check the address in whitelist tier two\r\n  function isInTier2WhiteList(bytes32[] memory proof, address claimer) public view returns(bool) {\r\n    \r\n    bytes32 _leaf = keccak256(abi.encodePacked(claimer));\r\n    return MerkleProof.verify(proof, _whitelistTierTwoMerkleRoot, _leaf);\r\n    \r\n  }\r\n\r\n  /**\r\n    * @dev Throws if called by any account other than the owner.\r\n  */\r\n  modifier onlyAdmin() {\r\n      require(_admin == _msgSender(), \"NotADMIN\");\r\n      _;\r\n  }\r\n\r\n  function changeAdmin(address newAdmin) public onlyAdmin  {\r\n      // require(_msgSender() == _admin, 'ADMIN: Only Admin can change');\r\n      if(_msgSender() != _admin) revert NotAdmin();\r\n      address oldOwner = _admin;\r\n      _admin=newAdmin;\r\n\r\n      emit AdminOwnershipTransferred(oldOwner, newAdmin);\r\n  }\r\n\r\n  \r\n  function getHardCap() public view returns (uint) {\r\n    return saleInfo.hardCap;\r\n  }\r\n\r\n  /**************************|\r\n  |          Setters         |\r\n  |_________________________*/\r\n  \r\n  function setKYC(bool kyc) public onlyAdmin {\r\n    if (block.timestamp >= saleInfo.saleStartTime) revert KYCAfterSaleStartTime();\r\n    hasKYC = kyc;\r\n  } \r\n\r\n  function setAudited(bool audit) public onlyAdmin {\r\n      if (block.timestamp >= saleInfo.saleStartTime) revert AuditAfterSaleStartTime();\r\n      _isAudited = audit;\r\n  }\r\n  function setTier1TimeLineInHours (uint newValue) public onlyAdmin {\r\n    tier1TimeLineInHours=newValue;\r\n  }\r\n  function isAudited() public view returns (bool, string memory ) {\r\n    return (_isAudited, auditUrl);\r\n  }\r\n\r\n\r\n  /**\r\n    * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n    * `recipient`, forwarding all available gas and reverting on errors.\r\n    *\r\n    * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n    * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n    * imposed by `transfer`, making them unable to receive funds via\r\n    * `transfer`. {sendValue} removes this limitation.\r\n    *\r\n    * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n    *\r\n    * IMPORTANT: because control is transferred to `recipient`, care must be\r\n    * taken to not create reentrancy vulnerabilities. Consider using\r\n    * {ReentrancyGuard} or the\r\n    * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n    */\r\n  function sendValue(address recipient, uint256 amount) internal {\r\n      require(address(this).balance >= amount, \"InsufficientBalance\");\r\n\r\n      // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n      (bool success, ) = recipient.call{ value: amount }(\"\");\r\n      require(success, \"NoSendValue\");//Address: unable to send value, recipient may have reverted\r\n  }\r\n\r\n  \r\n  // send coin to the contract address\r\n  function submitBid(bytes32[] calldata proof, uint256 purchasedAmount) public payable nonReentrant  {\r\n    \r\n    uint256 normalizedBid ;\r\n    if(purchaseTokenAddress==address(0)){\r\n      normalizedBid= msg.value;\r\n    }else{\r\n      normalizedBid= purchasedAmount * 10**(18-purchaseCoinDecimals);//normalize\r\n      IERC20(purchaseTokenAddress).safeTransferFrom(msg.sender, address(this), purchasedAmount);\r\n    }\r\n    \r\n\r\n    if (status == CampaignStatus.CANCELLED) revert SaleCancelled();\r\n    if (status == CampaignStatus.FAILED) revert SaleFailed();\r\n    if (status != CampaignStatus.TOKENS_SUBMITTED) revert NotTokenSubmitted();\r\n    if (totalCoinReceived >= saleInfo.hardCap) revert SoldOutError();\r\n    if (block.timestamp > saleInfo.saleEndTime) revert ClosedSale();\r\n    if (totalCoinReceived + normalizedBid > saleInfo.hardCap) revert ExceedMaxCap();\r\n    if (normalizedBid < minAllocationPerUser) revert LessThanMinBuy();\r\n    \r\n          \r\n    address sender = _msgSender();\r\n\r\n    if (block.timestamp >= saleInfo.saleStartTime) {\r\n        if (useWhiteList) {\r\n            if (!isInTier2WhiteList(proof, sender)) revert NotInTier2Whitelist();\r\n        }\r\n        if (totalCoinInTierTwo + normalizedBid > tierTwohardCap) revert ExceedTierTwoMaxCap();\r\n        if (buyInTwoTier[sender] + normalizedBid > maxAllocationPerUserTierTwo) revert ExceedTierTwoUserLimit();\r\n        buyInTwoTier[sender] += normalizedBid;\r\n        buyInAllTiers[sender] += normalizedBid;\r\n        totalCoinReceived += normalizedBid;\r\n        totalCoinInTierTwo += normalizedBid;\r\n        totalParticipants++;\r\n\r\n        emit ValueReceived(sender, purchasedAmount);\r\n    } else if (ICampaignList(_campaignFactoryAddress).getTierStatus(0) && block.timestamp >= saleInfo.saleStartTime - (tier0TimeLineInHours * 1 hours)) {  \r\n        if (!isAllowedInTier0(sender)) revert NotInTier0();\r\n        if (totalCoinInTierZero + normalizedBid > tierZerohardCap) revert ExceedTierZeroMaxCap();\r\n        if (buyInZeroTier[sender] + normalizedBid > maxAllocationPerUserTierZero) revert ExceedTierZeroUserLimit();\r\n        buyInZeroTier[sender] += normalizedBid;\r\n        buyInAllTiers[sender] += normalizedBid;\r\n        totalCoinReceived += normalizedBid;\r\n        totalCoinInTierZero += normalizedBid;\r\n        totalParticipants++;\r\n\r\n        emit ValueReceived(sender, purchasedAmount);\r\n    } else if (ICampaignList(_campaignFactoryAddress).getTierStatus(1) && block.timestamp >= saleInfo.saleStartTime - (tier1TimeLineInHours * 1 hours)) {  \r\n        if (!isAllowedInTier1(sender)) revert NotInTier1();\r\n        if (totalCoinInTierOne + normalizedBid > tierOnehardCap) revert ExceedTierOneMaxCap();\r\n        if (buyInOneTier[sender] + normalizedBid > maxAllocationPerUserTierOne) revert ExceedTierOneUserLimit();\r\n        buyInOneTier[sender] += normalizedBid;\r\n        buyInAllTiers[sender] += normalizedBid;\r\n        totalCoinReceived += normalizedBid;\r\n        totalCoinInTierOne += normalizedBid;\r\n        totalParticipants++;\r\n\r\n        emit ValueReceived(sender, purchasedAmount);\r\n    } else {\r\n        revert SaleNotStarted();\r\n    }\r\n\r\n    \r\n\r\n    // return '';\r\n  }\r\n\r\n  /**\r\n  * @dev Withdraw tokens or coin by user after end time\r\n  * If this project does not reach softcap, return their funds otherwise get tokens \r\n  */\r\n  function withdrawFunds() public {\r\n    address usr = _msgSender();\r\n\r\n    if (usr == owner()) revert OwnersCannotWithdraw();\r\n    \r\n    // if campaign is sold out no need to wait for endtime finalize and setup liquidity\r\n    if (block.timestamp < saleInfo.saleEndTime && totalCoinReceived < saleInfo.hardCap) revert OngoingSales();\r\n    \r\n    if (buyInAllTiers[usr] == 0) revert NoCoinsToClaim();\r\n\r\n    if (totalCoinReceived < saleInfo.softCap) {\r\n        status = CampaignStatus.FAILED;\r\n    }\r\n\r\n    uint256 amount = buyInAllTiers[usr];\r\n    buyInAllTiers[usr] = 0;\r\n    uint256 amountTokens = amount * saleInfo.listRate;\r\n\r\n    if (status == CampaignStatus.FAILED) {\r\n      // return back funds\r\n      if(purchaseTokenAddress==address(0)){\r\n        payable(usr).transfer(amount);\r\n      }else{\r\n        IERC20(purchaseTokenAddress).safeTransfer(usr, amount/10**(18-purchaseCoinDecimals));\r\n      }          \r\n      emit Refunded(usr, amount/10**(18-purchaseCoinDecimals));\r\n    } else {\r\n        IERC20 _token = IERC20(saleInfo.tokenAddress);\r\n        // Transfer Tokens to User\r\n        _token.safeTransfer(usr, amountTokens/10**(18-tokenDecimals));\r\n\r\n        emit Withdrawn(usr, amountTokens/10**(18-tokenDecimals));\r\n    }    \r\n  }\r\n\r\n  /**\r\n  * @dev Withdraw owner tokens If this project does not reach softcap\r\n  */\r\n \r\n\r\n  function withdrawOwnerTokens() public onlyOwner {\r\n      if (status != CampaignStatus.FAILED && status != CampaignStatus.CANCELLED && status != CampaignStatus.LIQUIDITY_SETUP) revert RequireCancelorFail();\r\n      if (block.timestamp < saleInfo.saleEndTime) revert NotEndDate();\r\n      if(ownerHasWithdrawnTokens) revert OwnerHasWithdrawnAlready();\r\n\r\n      if(totalCoinReceived < saleInfo.softCap){\r\n        status= CampaignStatus.FAILED;\r\n      }\r\n\r\n      IERC20 _token = IERC20(saleInfo.tokenAddress);\r\n      //if (totalCoinReceived >= saleInfo.softCap ) revert AlreadyReachedSoftCap(saleInfo.softCap);\r\n      if(status == CampaignStatus.FAILED || status == CampaignStatus.CANCELLED){\r\n        \r\n        uint256 tokensAmount = _token.balanceOf(address(this));\r\n\r\n        if (tokensAmount == 0) revert NoTokens();\r\n        ownerHasWithdrawnTokens=true;\r\n        _token.safeTransfer(msg.sender, tokensAmount);\r\n\r\n\r\n      }else if(status == CampaignStatus.LIQUIDITY_SETUP){\r\n        // Todo\r\n        uint tokensForUsers = totalCoinReceived * saleInfo.listRate ;\r\n        uint tokensForLiquidity = totalCoinReceived * saleInfo.dexListRate *  saleInfo.liquidityPercent/10000;\r\n        uint tokensForFees = zsaleTokenFee * totalCoinReceived / 10000;\r\n\r\n        uint withdrawableTokens  = (tokensForLiquidity + tokensForUsers + tokensForFees )/ 10**(18-tokenDecimals);\r\n        ownerHasWithdrawnTokens=true;\r\n\r\n        _token.safeTransfer(msg.sender, withdrawableTokens);\r\n      }\r\n      \r\n  }\r\n\r\n  \r\n  \r\n\r\n  /**\r\n    * Setup liquidity and transfer all amounts according to defined percents, if softcap not reached set Refunded flag\r\n    */\r\n  function finalizeAndSetupLiquidity() public nonReentrant {\r\n    \r\n    require (totalCoinReceived >= saleInfo.hardCap || block.timestamp > saleInfo.saleEndTime, NoSoldOutOrEndDate());\r\n    if (status == CampaignStatus.FAILED) revert CampaignFailed();\r\n    if (status == CampaignStatus.CANCELLED) revert CampaignCancelled();\r\n    if (status == CampaignStatus.LIQUIDITY_SETUP) revert LiquiditySetupAlreadyDone();\r\n    //\r\n    if(totalCoinReceived < saleInfo.softCap){ // set to failed and stop\r\n        status= CampaignStatus.FAILED ;\r\n        return;\r\n    }\r\n\r\n    \r\n    IERC20 tokenOnSale = IERC20(saleInfo.tokenAddress);\r\n\r\n    // Total amount invested\r\n    uint256 currentCoinBalance = address(this).balance;\r\n    if(purchaseTokenAddress!=address(0)){\r\n      currentCoinBalance = IERC20(purchaseTokenAddress).balanceOf(address(this));\r\n    }\r\n\r\n    if(currentCoinBalance<=0 || (totalCoinReceived/ 10**(18-purchaseCoinDecimals)) > currentCoinBalance ){\r\n       revert NoCoin();\r\n    }\r\n    \r\n    \r\n\r\n    \r\n\r\n    uint256 zsaleFeeAmount = (totalCoinReceived * zsaleFee / 10000) / 10**(18-purchaseCoinDecimals);\r\n    uint256 zsaleTokenFeeAmount = (saleInfo.listRate * totalCoinReceived * zsaleTokenFee/ 10000) /10**(18 -tokenDecimals);\r\n    \r\n    //Fees charged in Purchase coin\r\n    if(purchaseTokenAddress==address(0)){\r\n      payable(zsalesWalletAddress).transfer(zsaleFeeAmount);\r\n    }else{\r\n      IERC20(purchaseTokenAddress).safeTransfer(zsalesWalletAddress, zsaleFeeAmount);\r\n    }\r\n    // //Fee charged in Token listed, \r\n    tokenOnSale.safeTransfer(zsalesWalletAddress, zsaleTokenFeeAmount);\r\n\r\n\r\n    uint256 supplyAfterFees = purchaseTokenAddress==address(0) ? address(this).balance : IERC20(purchaseTokenAddress).balanceOf(address(this));\r\n    //Amount of Token to be sent to dex\r\n    \r\n    uint256 tokensBalance =  tokenOnSale.balanceOf(address(this)) * (10 ** (18 - tokenDecimals));\r\n    // Amount to be sent to dex\r\n    uint256 liquidityAmount = (supplyAfterFees * saleInfo.liquidityPercent) / 10000;\r\n    if(tokensBalance < liquidityAmount * saleInfo.dexListRate ) revert NoTokensForLiquidity();\r\n    \r\n\r\n    uint256 tokensForLiquidity = liquidityAmount * saleInfo.dexListRate / (10 ** (18 - tokenDecimals)); \r\n\r\n\r\n    bool approvalSucess = tokenOnSale.approve(dexRouterAddress, tokensForLiquidity);\r\n    require(approvalSucess == true, RouterApprovalFailed());\r\n\r\n    IDexRouter _dexRouter=IDexRouter(dexRouterAddress);\r\n\r\n    //liquidity pair\r\n    //Liquidity Pair A Balance sent\r\n    if(purchaseTokenAddress==address(0)){\r\n      _dexRouter.addLiquidityETH{value: liquidityAmount}(\r\n            saleInfo.tokenAddress,\r\n            tokensForLiquidity,\r\n            tokensForLiquidity,\r\n            liquidityAmount,\r\n            address(this),\r\n            block.timestamp + 100\r\n      );\r\n      emit LiquidityAddedToRouter(dexRouterAddress, address(0),saleInfo.tokenAddress,liquidityAmount,tokensForLiquidity  );\r\n\r\n      // (bool success,) = _dexLockerAddress.call{ value: liquidityAmount }(\"\");\r\n      // if(!success) revert TransferDExLockerFailed();//use call , since dexlocker is a proxy\r\n    }else{\r\n      tokenOnSale.approve(dexRouterAddress, MAX_INT);\r\n      IERC20(purchaseTokenAddress).approve(dexRouterAddress, MAX_INT);\r\n      // IERC20(_token).approve(lpTokenPairAddress, MAX_INT);\r\n      // IERC20(purchaseTokenAddress).approve(lpTokenPairAddress, MAX_INT);\r\n\r\n\r\n      _dexRouter.addLiquidity(\r\n          address(tokenOnSale),\r\n          purchaseTokenAddress,\r\n          tokensForLiquidity,\r\n          liquidityAmount,\r\n          0,\r\n          0,            \r\n          address(this),\r\n          block.timestamp + 100\r\n      );\r\n      \r\n      emit LiquidityAddedToRouter(dexRouterAddress, purchaseTokenAddress,address(tokenOnSale),liquidityAmount,tokensForLiquidity  );\r\n\r\n      //IERC20(purchaseTokenAddress).safeTransfer(_dexLockerAddress, liquidityAmount/10 ** (18 - purchaseCoinDecimals));\r\n    }\r\n    \r\n    //Liquidity Pair B Balance sent        \r\n    tokenOnSale.safeTransfer(_dexLockerAddress, liquidityAmount * saleInfo.dexListRate/10**(18 -tokenDecimals) );\r\n    \r\n\r\n\r\n    IDexLocker locker = IDexLocker(_dexLockerAddress); \r\n    \r\n    locker.addLiquidity(totalCoinReceived); \r\n    \r\n    if(useRaisedFundsVesting){\r\n      //send raised funds to Lock\r\n      // Remainder after all dedeuctions and liquidity\r\n\r\n      uint amountRaised = totalCoinReceived/ 10 ** (18-purchaseCoinDecimals);\r\n      // uint256 remainingCoinBalance = address(this).balance;\r\n      if(purchaseTokenAddress==address(0)){\r\n        locker.startRaisedFundsLock{value: amountRaised}( amountRaised );\r\n      }else{\r\n        locker.startRaisedFundsLock( amountRaised );\r\n      }\r\n\r\n    }    \r\n    \r\n    status=CampaignStatus.LIQUIDITY_SETUP;\r\n  }\r\n\r\n  \r\n  function getCampaignInfo() public view returns( uint256 softcap, uint256 hardcap,uint256 saleStartTime, uint256 saleEndTime,uint256 listRate, uint256 dexListRate, uint liquidity,uint _liquidityReleaseTime ,uint256 totalCoins, uint256 totalParticipant, bool useWhiteList, bool hasKyc, bool isAuditd, string memory _auditUrl ){\r\n      return ( saleInfo.softCap, saleInfo.hardCap,saleInfo.saleStartTime, saleInfo.saleEndTime, saleInfo.listRate, saleInfo.dexListRate, saleInfo.liquidityPercent, liquidityReleaseTime, totalCoinReceived,totalParticipants, useWhiteList,hasKYC, _isAudited, auditUrl );\r\n  }\r\n\r\n  \r\n\r\n  function getCampaignStatus() public view returns(CampaignStatus ){\r\n      return status ;\r\n  }\r\n\r\n  function getCampaignPeriod() public view returns(uint256 saleStartTime, uint256 saleEndTime ){\r\n      return (saleInfo.saleStartTime, saleInfo.saleEndTime );\r\n  }\r\n\r\n  function getCampaignSalePriceInfo() public view returns(uint256 , uint256,uint256 , uint256,uint256 , uint256,uint256 ){\r\n      return (saleInfo.listRate, saleInfo.dexListRate, saleInfo.softCap, saleInfo.hardCap, tierOnehardCap,tierTwohardCap, maxAllocationPerUserTierTwo  );\r\n  }\r\n\r\n  /**\r\n    * \r\n    */\r\n  function isSoldOut() public view returns (bool) {\r\n      return totalCoinReceived>= saleInfo.hardCap;\r\n  }\r\n\r\n    /**\r\n    * \r\n    */\r\n  function hasFailed() public view returns (bool) {\r\n      return status == CampaignStatus.FAILED;\r\n  }\r\n\r\n  \r\n  function dexLockerAddress() public view onlyAdmin returns (address) {\r\n      return _dexLockerAddress;\r\n  }\r\n\r\n  function tokenAddress() public view returns (address) {\r\n      return saleInfo.tokenAddress;\r\n  }\r\n\r\n  // Refund any mistakenly sent in ERC20\r\n  function refundERC20(IERC20 _token, address recipient, uint256 amount) public onlyAdmin {\r\n      \r\n    _token.safeTransfer(recipient, amount);\r\n  }\r\n\r\n}"
    },
    "contracts/CampaignList.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n// import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n\r\n// import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport \"./Campaign.sol\";\r\nimport \"./Confirmations/ConfirmAddress.sol\";\r\nimport './Lockers/DexLockerFactory.sol';\r\nimport './Lockers/VestSchedule.sol';\r\nimport \"hardhat/console.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\n\r\nimport './Interfaces/Turnstile.sol';\r\nimport \"./Errors.sol\";\r\n\r\nerror NotEnoughBalance(uint balance);\r\n\r\ninterface ICampaignList{\r\n    function zsaleFee() external view returns (uint);// 2%   - percent of purchase currency to take\r\n    function zsaleTokenFee() external view returns (uint);// percent fee of token to take\r\n    function campaignCreationPrice() external view returns (uint);// \r\n    function zsalesWalletAddress() external view returns (address); //receives commissions\r\n\r\n    function zsalesAdmin() external view returns (address);\r\n    function zsalesTokenAddress() external view returns (address);\r\n    function zsalesNFTTokenAddress() external view returns (address);\r\n    function getTierStatus(uint tier) external view returns (bool);\r\n}\r\n\r\n\r\ncontract CampaignList is Context,Ownable, ICampaignList  {\r\n    using SafeERC20 for IERC20;\r\n  // Add the library methods\r\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\r\n    \r\n    // Declare a set state variable\r\n    EnumerableMap.UintToAddressMap private _campaigns;\r\n\r\n    uint private _counter;\r\n\r\n    DexLockerFactory private _dexLockerFactory;\r\n\r\n    ConfirmAddress addressConfirmer;\r\n\r\n    /**\r\n    * @dev percent of native currency to take multiplied by 100 i.e 200 for 2%.\r\n    */\r\n    uint public zsaleFee = 200;  //2%   - percent of native currency to take\r\n    uint public zsaleTokenFee = 200;  //2% - percent fee of token to take\r\n    uint public campaignCreationPrice = 0.00001 ether; \r\n    address public zsalesWalletAddress = 0xB7e16f5fa9941B84baCd1601F277B00911Aed339 ; // receives commissions\r\n\r\n    address public zsalesAdmin  ;\r\n\r\n    address public zsalesTokenAddress = 0x97CEe927A48dc119Fd0b0b1047a879153975e893 ;\r\n\r\n    address public zsalesNFTTokenAddress = 0x97CEe927A48dc119Fd0b0b1047a879153975e893 ;\r\n\r\n    mapping(address => uint256[]) private ownersCampaign; //owneraddress -> campaignIndex\r\n\r\n    mapping(uint256 => bool) private _tierStatuses; //tier -> enable/disable\r\n    \r\n\r\n    mapping(address => address payable ) public _tokenCampaigns; //tokenAddress=>Campaign\r\n\r\n    event CampaignCreated(address indexed creator,uint256 indexed index, address createdCampaignAddress);\r\n    \r\n    \r\n    \r\n    address  _campaignImplementationAddress;\r\n\r\n    address public turnstileAddress = address(0);\r\n    Turnstile private turnstile;\r\n\r\n    constructor(DexLockerFactory dexLockerFactory,address zsalesToken,address zsalesNFTToken, address campaignImplementationAddress) Ownable(msg.sender)  {      \r\n       _dexLockerFactory=dexLockerFactory;\r\n       _campaignImplementationAddress = campaignImplementationAddress;\r\n       zsalesTokenAddress=zsalesToken;\r\n       zsalesNFTTokenAddress=zsalesNFTToken;\r\n       addressConfirmer=new ConfirmAddress();\r\n       zsalesAdmin= _msgSender();\r\n    }\r\n\r\n    function updateTurnstileAddress(address newAddress) public onlyOwner{\r\n        \r\n        turnstileAddress=newAddress;\r\n        turnstile = Turnstile(turnstileAddress);\r\n        //Registers the smart contract with Turnstile\r\n        //Mints the CSR NFT to the contract creator\r\n        turnstile.register(tx.origin);\r\n\r\n    }\r\n\r\n    /**************************|\r\n    |          Setters         |\r\n    |_________________________*/\r\n    function setCampaignImplementation(address campaignImplementationAddress) public onlyOwner  {   \r\n       _campaignImplementationAddress = campaignImplementationAddress;\r\n    }\r\n\r\n    function setCampaignCreationPrice(uint256 newPrice) public onlyOwner{\r\n        campaignCreationPrice=newPrice;\r\n    }\r\n\r\n    function setCampaignFee(uint256 saleFee, uint256 saleTokenFee) public onlyOwner{\r\n        zsaleFee=saleFee;\r\n        zsaleTokenFee=saleTokenFee;\r\n    }\r\n\r\n    function setFeeWallet(address salesWalletAddress) public onlyOwner{\r\n        zsalesWalletAddress=salesWalletAddress;\r\n    }\r\n\r\n    function setAdmin(address newAdmin) public onlyOwner{\r\n        zsalesAdmin=newAdmin;\r\n    }\r\n\r\n    function setZSalesTokenAddress(address newAddress) public onlyOwner{\r\n        zsalesTokenAddress=newAddress;\r\n    }\r\n\r\n    function setZSalesNFTTokenAddress(address newAddress) public onlyOwner{\r\n        zsalesNFTTokenAddress=newAddress;\r\n    }\r\n\r\n    function setTierStatus(uint tier,bool status) public onlyOwner{\r\n        _tierStatuses[tier]=status;\r\n    }\r\n\r\n    function getTierStatus(uint tier) public view returns (bool){\r\n        return _tierStatuses[tier];\r\n    }\r\n\r\n    /**\r\n    * @dev Create A new Campaign. Throws if Campaign for token already exists.\r\n    */\r\n    function createNewCampaign(address _tokenAddress, address _purchaseTokenAddress, \r\n        uint256[10] memory capAndDate,\r\n        Campaign.RefundType _refundType, address _dexRouterAddress,uint[4] memory liquidityAllocationAndRates,\r\n        string[6] memory founderInfo,bool[2] memory _useTokenOrRaisedFundsVesting,\r\n        // VestSchedule[8] memory teamTokenVestingDetails,\r\n        uint256[5] memory teamTokenVestingDetails,\r\n        uint256[3] memory raisedFundVestingDetails\r\n    ) public payable  {\r\n        \r\n        require(msg.value >= campaignCreationPrice, 'NoCmpgnCreatePrice' );\r\n\r\n        require(addressConfirmer.isContract(_tokenAddress), 'RequiresTokenContract ');\r\n        \r\n        if(_tokenCampaigns[_tokenAddress] != address(0)){\r\n            Campaign ct = Campaign(_tokenCampaigns[_tokenAddress]);\r\n            if( !(ct.status() == Campaign.CampaignStatus.CANCELLED || ct.status()== Campaign.CampaignStatus.FAILED) ){\r\n                revert('ExistingCampaign');\r\n            }\r\n        }\r\n        \r\n        {     \r\n            _counter++; \r\n            capAndDate[9] = _counter;\r\n\r\n            \r\n            if(_purchaseTokenAddress!= address(0)){\r\n                uint purchaseDecimals = IERC20Metadata(_purchaseTokenAddress).decimals();\r\n                if( purchaseDecimals !=18){\r\n                    capAndDate[0]=normalizeTokenAmount(capAndDate[0], purchaseDecimals); //Softcap\r\n                    capAndDate[1]=normalizeTokenAmount(capAndDate[1], purchaseDecimals);\r\n\r\n                    capAndDate[4]=normalizeTokenAmount(capAndDate[4], purchaseDecimals); \r\n                    capAndDate[5]=normalizeTokenAmount(capAndDate[5], purchaseDecimals);\r\n\r\n                    capAndDate[6]=normalizeTokenAmount(capAndDate[6], purchaseDecimals); \r\n                    capAndDate[7]=normalizeTokenAmount(capAndDate[7], purchaseDecimals);\r\n                    capAndDate[8]=normalizeTokenAmount(capAndDate[8], purchaseDecimals);\r\n                }else if(purchaseDecimals >18){\r\n                    revert OnlyDecimals18AndBelow();\r\n                }\r\n            }\r\n\r\n            address payable newCampaignCloneAddress = payable(Clones.clone(_campaignImplementationAddress) );\r\n            Campaign(newCampaignCloneAddress).initialize([msg.sender, address(this) , _tokenAddress, _purchaseTokenAddress], \r\n                capAndDate,    _refundType, _dexRouterAddress,liquidityAllocationAndRates,teamTokenVestingDetails, raisedFundVestingDetails,\r\n                 _useTokenOrRaisedFundsVesting, founderInfo, _dexLockerFactory);\r\n\r\n             _campaigns.set(_counter, newCampaignCloneAddress);\r\n            ownersCampaign[msg.sender].push( _counter);        \r\n            _tokenCampaigns[_tokenAddress]= payable(newCampaignCloneAddress);\r\n\r\n\r\n            emit CampaignCreated(msg.sender, _counter,newCampaignCloneAddress);\r\n\r\n            _transferTokensRequired(Campaign(newCampaignCloneAddress));\r\n\r\n        }\r\n    }\r\n\r\n    function _transferTokensRequired(Campaign ct) private \r\n    {               \r\n        uint256 amount = ct.totalTokensExpectedToBeLocked(); // in 18 digits\r\n\r\n        // add zsale fee\r\n        uint256 feeAmount = ((zsaleTokenFee *  ct.getHardCap() )/10000) * ct.getDexListRate();\r\n\r\n        uint total = ((amount+feeAmount) / (10**(18 - IERC20Metadata(ct.tokenAddress()).decimals() )) );\r\n\r\n        IERC20 _token = IERC20(ct.tokenAddress());\r\n        _token.safeTransferFrom(_msgSender(), address(this), total);\r\n\r\n        _token.safeTransfer( address(ct), total);\r\n        ct.startReceivingBids();\r\n    }\r\n\r\n    \r\n\r\n    function hasExistingCampaign(address _tokenAddress) external view returns (bool){\r\n        return _tokenCampaigns[_tokenAddress] != address(0);\r\n    }\r\n\r\n    function allOwnersCampaignsSize() public view returns (uint256) {\r\n        return ownersCampaign[msg.sender].length;\r\n    }\r\n    function allOwnersCampaignsSize(address owner) public view returns (uint256) {\r\n        return ownersCampaign[owner].length;\r\n    }\r\n\r\n    //offset \r\n    function allOwnersCampaigns( uint256 start, uint256 offset) public view returns (uint256[] memory) {\r\n        uint256[] memory list = new uint256[](offset) ;\r\n        for (uint256 i=start; i < start + offset ; i++) {\r\n            list[i-start] = ownersCampaign[msg.sender][i]; \r\n        }\r\n        return list;\r\n    }\r\n\r\n    function allOwnersCampaigns(address owner, uint256 start, uint256 offset) public view returns (uint256[] memory) {\r\n        uint256[] memory list = new uint256[](offset) ;\r\n        for (uint256 i=start; i < start + offset ; i++) {\r\n            list[i-start] = ownersCampaign[owner][i]; \r\n        }\r\n        return list;\r\n    }\r\n\r\n    \r\n    function campaignSize() public view returns (uint256) {\r\n        return _campaigns.length();\r\n    }\r\n\r\n    \r\n\r\n        \r\n\r\n    function contains(uint256 key) public view returns (bool) {\r\n        return _campaigns.contains(key);\r\n    }\r\n\r\n        \r\n\r\n    function campaignAt(uint256 index) public view returns (uint256 key, address value) {\r\n        return _campaigns.at(index);\r\n    }\r\n\r\n    function tryGetCampaignByKey(uint256 key) public view returns (bool, address) {\r\n        return _campaigns.tryGet(key);\r\n    }\r\n\r\n    function tryGetCampaignByTokenAddress(address _tokenAddress) public view returns ( address) {\r\n        return _tokenCampaigns[_tokenAddress];\r\n    }\r\n\r\n    receive() external payable {\r\n        \r\n    }\r\n\r\n    // //abi.encodePacked(x)\r\n    // function concatenate(string memory s1, string memory s2) public pure returns (string memory) {\r\n    //     return string(abi.encodePacked(s1, s2));\r\n    // }\r\n\r\n    // function concatenate(string memory s1, address s2) public pure returns (string memory) {\r\n    //     return string(abi.encodePacked(s1, s2));\r\n    // }\r\n\r\n\r\n    /**\r\n     * Normalization function that adjusts token amounts to a common decimal base (18 decimals in this case). \r\n     * This function either scales up or scales down the token amount based on the number of decimals the token uses,\r\n     * ensuring the final amount will be always displayed with 18 decimals. \r\n     * Of course this can result in a minor truncation if tokens >18 decimals are being used, this must be considered\r\n     */\r\n    function normalizeTokenAmount(uint tokenAmount, uint tokenDecimals) public pure returns (uint) {\r\n        uint standardDecimal = 18;\r\n        if(tokenDecimals>standardDecimal){\r\n            return tokenAmount / (10 ** (tokenDecimals-standardDecimal));\r\n        }\r\n        else if(tokenDecimals< standardDecimal){\r\n            return tokenAmount * (10 ** (standardDecimal - tokenDecimals));\r\n        }\r\n        else{\r\n            return tokenAmount;\r\n        }\r\n    }\r\n    \r\n    // Sends to th 'to' address or the zsalesWalletAddress if to address is zeroAddress\r\n    function  withdrawFee(address to, uint amount) public onlyOwner  {\r\n        \r\n        uint balance = address(this).balance;\r\n        if(amount>=balance){\r\n            if(to==address(0)){\r\n                to=zsalesWalletAddress;\r\n            }\r\n\r\n            payable(to).transfer(amount);\r\n        }else {\r\n            revert NotEnoughBalance(balance);\r\n        }\r\n    }\r\n\r\n}"
    },
    "contracts/Confirmations/ConfirmAddress.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\n\r\ncontract ConfirmAddress{\r\n    \r\n    address private  _account;\r\n    \r\n    \r\n    // to dectect if the address is a contract or not\r\n   /**\r\n     * @dev Returns true if `account` is a contract.\r\n     *\r\n     * [IMPORTANT]\r\n     * ====\r\n     * It is unsafe to assume that an address for which this function returns\r\n     * false is an externally-owned account (EOA) and not a contract.\r\n     *\r\n     * Among others, `isContract` will return false for the following\r\n     * types of addresses:\r\n     *\r\n     *  - an externally-owned account\r\n     *  - a contract in construction\r\n     *  - an address where a contract will be created\r\n     *  - an address where a contract lived, but was destroyed\r\n     * ====\r\n     */\r\n    function isContract(address account) public view returns (bool) {\r\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\r\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\r\n        // for accounts without code, i.e. `keccak256('')`\r\n        bytes32 codehash;\r\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\r\n        // bytes32 tokenaddress= 0xDf8681e9bF215076c1661Cbb5cd10F0d4902D662;\r\n        // solhint-disable-next-line no-inline-assembly\r\n        assembly { codehash := extcodehash(account) }\r\n        return (codehash != accountHash && codehash != 0x0);\r\n    }\r\n}"
    },
    "contracts/DecimalToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract DecimalToken is ERC20 {\r\n\r\n    uint8 private _decimals;\r\n    constructor(uint8 decimals) ERC20(\"Test\", \"TST\") {\r\n        _decimals=decimals;\r\n        _mint(msg.sender, 1000000  ether);\r\n        _mint(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 1000000  ether);\r\n        _mint(0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199, 1000000  ether);\r\n    }\r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}"
    },
    "contracts/ERC20Sale/CampaignWithErc20.sol": {
      "content": "// // SPDX-License-Identifier: MIT\r\n// pragma solidity ^0.8.8;\r\n\r\n// import \"@openzeppelin/contracts/utils/Context.sol\";\r\n// // import \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n// import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n\r\n// import \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\n// // import \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\r\n\r\n// import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n// import '../Lockers/DexLockerFactory.sol';\r\n// import '../Lockers/DexLocker.sol';\r\n// import \"../Lockers/VestSchedule.sol\";\r\n// import \"@openzeppelin/contracts/utils/cryptography/MerkleProof.sol\";\r\n// import \"hardhat/console.sol\";\r\n// import {ICampaignList} from \"../CampaignList.sol\";\r\n\r\n// contract CampaignWithErc20 is Initializable,Ownable, ReentrancyGuard {\r\n//   using SafeERC20 for IERC20;\r\n\r\n//   event AdminOwnershipTransferred(address indexed previousAdmin, address indexed newAdmin);\r\n//   event ValueReceived(address user, uint amount);\r\n//   event Withdrawn(address user, uint amount);\r\n//   event Refunded(address user, uint amount);\r\n//   event SoldOut();\r\n\r\n//   struct CampaignSaleInfo {\r\n//       //token attributes\r\n//       address   tokenAddress; \r\n//       uint256  softCap; // Soft cap in coin\r\n//       uint256  hardCap; // Max cap in coin\r\n//       uint256  saleStartTime; // start sale time\r\n//       uint256  saleEndTime; // end sale time\r\n//       uint   liquidityPercent; // multiplied by 100 e.g 45% is 4500\r\n//       uint   listRate; \r\n//       uint   dexListRate;\r\n//       RefundType  refundType;\r\n//       string logoUrl;\r\n//       string desc;\r\n//       string website;\r\n//       string twitter;\r\n//       string telegram;\r\n//       string discord;\r\n      \r\n//   }\r\n//   enum CampaignStatus{ \r\n//     CREATED,\r\n//     TOKENS_SUBMITTED,//Owner has transferred the correct no of tokens and campaign is ready to receive\r\n//     CANCELLED, // Cancelled before the start date\r\n    \r\n//     FAILED, // WIll need refund\r\n//     LIQUIDITY_SETUP\r\n\r\n//   }\r\n\r\n//   bool   useWhiteList;//Use in only Tier 2\r\n//   bool   public hasKYC;\r\n//   bool _isAudited; \r\n//   string public auditUrl;\r\n//   CampaignStatus public  status = CampaignStatus.CREATED;\r\n\r\n//   address private _admin= 0xB7e16f5fa9941B84baCd1601F277B00911Aed339; //zsales admin - can setkyc and audited\r\n    \r\n//   CampaignSaleInfo public  saleInfo; \r\n  \r\n//   address public dexRouterAddress;\r\n//   uint256 public totalCoinReceived; // total  received\r\n//   uint256 public totalCoinInTierOne; // total coin for tier one\r\n//   uint256 public totalCoinInTierTwo; // total coin for tier Tier\r\n\r\n//   address public purchaseTokenAddress=address(0); // Token address for Purchases for this campaign - address 0 is native currency\r\n  \r\n//   uint public totalParticipants; // total participants in ido\r\n  \r\n\r\n//   address public zsalesTokenAddress = 0x97CEe927A48dc119Fd0b0b1047a879153975e893;\r\n//   uint zsaleFee;  // percent of native currency to take\r\n//   uint zsaleTokenFee;  //percent fee of token to take\r\n\r\n\r\n//   address zsalesWalletAddress; // receives commissions\r\n//   address public _campaignFactory ;\r\n\r\n//   uint private tier1TimeLineInHours = 2; // e.g 2 hours before startime\r\n  \r\n//   // max cap per tier\r\n//   uint public tierOnehardCap;\r\n//   uint public tierTwohardCap;\r\n    \r\n//   //total users per tier\r\n//   uint public totalUserInTierOne;\r\n//   uint public totalUserInTierTwo;\r\n  \r\n//   bool public useTokenVesting;\r\n//   bool public useRaisedFundsVesting;\r\n\r\n//     //Tier 1 - holders of our coin\r\n//     //Tier 2 - Whitelisted or public\r\n   \r\n//   uint public minAllocationPerUser;\r\n//   //max allocations per user in a tier\r\n//   uint public maxAllocationPerUserTierOne;\r\n//   uint public maxAllocationPerUserTierTwo; \r\n  \r\n \r\n//   // // address array for tier one whitelist\r\n//   // address[] private whitelistTierOne;  // every tokenholder is automatically whitelisted\r\n  \r\n//   // // address array for tier two whitelist\r\n//   // address[] private whitelistTierTwo; \r\n\r\n//   bytes32 private _whitelistTierTwoMerkleRoot;\r\n  \r\n\r\n//   uint public campaignKey;\r\n//   enum RefundType{ BURN, REFUND }\r\n  \r\n//   uint256 public liquidityReleaseTime; // time to relesase Lp tokens to owner\r\n\r\n//   //mapping the user purchase per tier\r\n//   mapping(address => uint) public buyInOneTier;\r\n//   mapping(address => uint) public buyInTwoTier;\r\n//   mapping(address => uint) public buyInAllTiers;\r\n//   DexLockerFactory private _dexLockerFactory;\r\n//   address payable private _dexLockerAddress;\r\n  \r\n\r\n//   ///Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be taken over by an attacker, which may impact the proxy. \r\n//   /// To prevent the implementation contract from being used, you should invoke the _disableInitializers function in the constructor to automatically lock it when it is deployed\r\n//   /// @custom:oz-upgrades-unsafe-allow constructor\r\n//   constructor() {\r\n//       _disableInitializers();\r\n//   }\r\n\r\n//   function initialize(\r\n    \r\n//     /** address campaignOwner,\r\n//     /* address campaignFactory,\r\n//     /* address  _saletokenAddress, */\r\n//     /* address  _purchaseTokenAddress, */\r\n//     address[4] memory addresses,\r\n\r\n//     /** uint256 _softCap,uint256 _hardCap,uint256 _saleStartTime,uint256 _saleEndTime, uint256 _tierOneHardCap, uint256 _tierTwoHardCap, uint256 _maxAllocationPerUserTierOne, uint256 _maxAllocationPerUserTierTwo ,uint _campaignKey,*/\r\n//     uint256[10] memory capAndDate,  \r\n    \r\n//     RefundType _refundType, \r\n//     address _dexRouterAddress,\r\n\r\n//     /**uint _liquidityPercent, \r\n//     /* uint liquidityReleaseTime,\r\n//     /* uint _listRate, \r\n//     /* uint _dexListRate,**/\r\n//     uint[4] memory liquidityAllocationAndRates,\r\n    \r\n//     bool[2] memory _useTokenOrRaisedFundVesting,\r\n//     VestSchedule[8] memory teamTokenVestingDetails, \r\n//     uint256[3] memory raisedFundVestingDetails,\r\n//     string[6] memory founderInfo,\r\n//     DexLockerFactory dexLockerFactory \r\n//   ) public payable initializer {\r\n//     _setDefaultValues();\r\n//     campaignKey=capAndDate[9];\r\n//     _campaignFactory= addresses[1];\r\n//     _dexLockerFactory=dexLockerFactory;\r\n//     purchaseTokenAddress=addresses[3];\r\n    \r\n//     // require(releaseTime > block.timestamp, \"CAMPAIGN: release time above current time\");\r\n//     require(capAndDate[3] > capAndDate[2], \"CAMPAIGN: Sale End time above start time\");\r\n//     require(liquidityAllocationAndRates[0] >= 5100, \"CAMPAIGN: Liquidity allowed is > 51 %\");\r\n      \r\n//      /* console.log(\r\n//         \"Transferring from %s to %s %s tokens\",\r\n//         msg.sender,\r\n//         to,\r\n//         amount\r\n//     ); */\r\n\r\n    \r\n      \r\n//     // //block scopin to avoid stack too deep \r\n//     {\r\n      \r\n//       // saleInfo= CampaignSaleInfo();\r\n//       saleInfo.tokenAddress=addresses[2];\r\n//       saleInfo.softCap=capAndDate[0];\r\n//       saleInfo.hardCap=capAndDate[1];\r\n//       // if(capAndDate[2] <= block.timestamp){\r\n//       //   saleInfo.saleStartTime=block.timestamp;\r\n//       // }else{\r\n//       //   saleInfo.saleStartTime=capAndDate[2];\r\n//       // }\r\n//       saleInfo.saleStartTime=capAndDate[2];\r\n      \r\n//       saleInfo.saleEndTime=capAndDate[3];\r\n//       saleInfo.liquidityPercent=liquidityAllocationAndRates[0];\r\n//       saleInfo.listRate=liquidityAllocationAndRates[2];\r\n//       saleInfo.dexListRate=liquidityAllocationAndRates[3];\r\n//       saleInfo.refundType=_refundType;\r\n//     }        \r\n    \r\n//     {    \r\n//       dexRouterAddress=_dexRouterAddress; \r\n        \r\n//     }\r\n    \r\n      \r\n//     _updateCampaignFounderDetails(founderInfo[0],founderInfo[1],founderInfo[2],founderInfo[3],founderInfo[4], founderInfo[5]);\r\n    \r\n    \r\n//     _updateTierDetails (capAndDate[4], capAndDate[5], capAndDate[6],capAndDate[7], capAndDate[8]);\r\n\r\n    \r\n\r\n//     _transferOwnership(addresses[0]);\r\n    \r\n\r\n//     _updateLockDetails(liquidityAllocationAndRates[1], _useTokenOrRaisedFundVesting[0], teamTokenVestingDetails,_useTokenOrRaisedFundVesting[1], raisedFundVestingDetails );\r\n\r\n    \r\n//   }\r\n\r\n//   //needed since initializable contracts do not have constructors\r\n//   function _setDefaultValues() private {\r\n//     status = CampaignStatus.CREATED;\r\n\r\n//     _admin= 0xB7e16f5fa9941B84baCd1601F277B00911Aed339; //zsales admin - can setkyc and audited\r\n//     ICampaignList cList = ICampaignList(_campaignFactory);\r\n\r\n//     zsalesTokenAddress = cList.zsalesTokenAddress();\r\n//     zsaleFee = cList.zsaleFee();  //2%   - percent of native currency to take\r\n//     zsaleTokenFee = cList.zsaleTokenFee();  //2% - percent fee of token to take\r\n//     zsalesWalletAddress = cList.zsalesWalletAddress() ; // receives commissions\r\n//     tier1TimeLineInHours = 2; // e.g 2 hours before startime\r\n//   }\r\n  \r\n//   // function to update other details not initialized in constructor - this is bcos solidity limits how many variables u can pass in at once\r\n//   function _updateLockDetails(uint liquidityReleaseTimeDays, //Time to add to startTime in days\r\n//     bool _useTokenVesting,\r\n//     VestSchedule[8] memory teamTokenVestingDetails,\r\n//     bool _useRaisedFundsVesting, \r\n//     uint256[3] memory raisedFundVestingDetails\r\n      \r\n//   ) private /*public onlyOwner*/ {\r\n//     liquidityReleaseTime  = saleInfo.saleEndTime + (liquidityReleaseTimeDays * 1 days);\r\n//     useTokenVesting=_useTokenVesting;\r\n//     useRaisedFundsVesting=_useRaisedFundsVesting;\r\n\r\n    \r\n//     //Set dexLock\r\n//     DexLocker dexLocker = DexLocker(payable(_dexLockerFactory.createDexLocker(dexRouterAddress,saleInfo.tokenAddress,address(this), msg.sender) ) );\r\n    \r\n    \r\n//     dexLocker.setupLock(saleInfo.liquidityPercent,saleInfo.softCap,saleInfo.hardCap, liquidityReleaseTime,  saleInfo.dexListRate,useTokenVesting, teamTokenVestingDetails, _useRaisedFundsVesting,  raisedFundVestingDetails);\r\n\r\n    \r\n//     _dexLockerAddress= payable(dexLocker);\r\n    \r\n//     status = CampaignStatus.CREATED;\r\n\r\n    \r\n\r\n//     //if doesnt use tokenvesting , _startReceivingBids();\r\n//     if(!useTokenVesting){\r\n//       _startReceivingBids();\r\n//     }\r\n\r\n    \r\n\r\n//   }\r\n\r\n//   function _updateCampaignFounderDetails(\r\n//     string memory logoUrl,\r\n//     string memory desc,\r\n//     string memory website,\r\n//     string memory twitter,\r\n//     string memory telegram,\r\n//     string memory discord\r\n//   ) private {\r\n//     saleInfo.logoUrl= logoUrl;\r\n//     saleInfo.desc= desc;\r\n//     saleInfo.website= website;\r\n//     saleInfo.twitter= twitter;\r\n//     saleInfo.telegram= telegram;\r\n//     saleInfo.discord= discord;\r\n//   }\r\n\r\n//   function updateCampaignFounderDetails(\r\n//     string memory logoUrl,\r\n//     string memory desc,\r\n//     string memory website,\r\n//     string memory twitter,\r\n//     string memory telegram,\r\n//     string memory discord\r\n//   ) external onlyOwner {\r\n\r\n//     require(block.timestamp <= saleInfo.saleStartTime, 'CAMPAIGN: Can only updateTierDetails before Sale StartTime');\r\n//     _updateCampaignFounderDetails(logoUrl,desc,website,twitter,telegram,discord);\r\n//   }\r\n    \r\n//   // function to update the tiers users value manually\r\n//   function _updateTierDetails(uint256 _tierOneHardCap, uint256 _tierTwoHardCap, uint256 _minAllocationPerUser, uint256 _maxAllocationPerUserTierOne, uint256 _maxAllocationPerUserTierTwo) private {\r\n    \r\n//     require(_tierOneHardCap > (saleInfo.hardCap * 3000 / 10000), \"CAMPAIGN: Tier Caps must be greater than 30 %\" );\r\n//     // require(_tierOneHardCap + _tierTwoHardCap == saleInfo.hardCap, \"CAMPAIGN: Tier 1 & 2 Caps must be equal to hard cap\" );\r\n//     require(_tierOneHardCap <= saleInfo.hardCap, \"CAMPAIGN: Tier 1 Caps must be Less than or equal to hard cap\" );\r\n//     require(_tierTwoHardCap <= saleInfo.hardCap, \"CAMPAIGN: Tier 2 Caps must be Less than or  equal to hard cap\" );\r\n    \r\n//     require(_minAllocationPerUser > 0, \"CAMPAIGN: Min Allocation must be greater than 0\" );\r\n//     require(_maxAllocationPerUserTierOne > 0, \"CAMPAIGN: Tier 1 Max Allocation must be greater than 0\" );\r\n//     require(_maxAllocationPerUserTierTwo > 0, \"CAMPAIGN: Tier 2 Max Allocation must be greater than 0\" );\r\n    \r\n    \r\n//     tierOnehardCap =_tierOneHardCap;\r\n//     tierTwohardCap = _tierTwoHardCap;    \r\n    \r\n//     minAllocationPerUser=_minAllocationPerUser; \r\n//     maxAllocationPerUserTierOne = _maxAllocationPerUserTierOne;\r\n//     maxAllocationPerUserTierTwo = _maxAllocationPerUserTierTwo;\r\n//   }\r\n\r\n//   function updateTierDetails(uint256 _tierOneHardCap, uint256 _tierTwoHardCap, uint256 _minAllocationPerUser, uint256 _maxAllocationPerUserTierOne, uint256 _maxAllocationPerUserTierTwo) public onlyOwner {\r\n//     require(block.timestamp <= saleInfo.saleStartTime, 'Can only updateTierDetails before Sale StartTime');\r\n//     _updateTierDetails(_tierOneHardCap, _tierTwoHardCap, _minAllocationPerUser, _maxAllocationPerUserTierOne, _maxAllocationPerUserTierTwo);    \r\n//   }\r\n\r\n//   function _startReceivingBids() private \r\n//   {    \r\n//     status = CampaignStatus.TOKENS_SUBMITTED;\r\n//   }\r\n\r\n//   function startReceivingBids() public \r\n//   {\r\n//     //can only be called by _campaignFactory\r\n//     require(_campaignFactory== _msgSender(), 'CAMPAIGNList: startReceivingBids - Not Owner');\r\n//     _startReceivingBids();\r\n//   }\r\n\r\n\r\n//   function cancelCampaign() public onlyOwner{\r\n//     require(block.timestamp < saleInfo.saleStartTime, 'Can only cancel before Sale StartTime');\r\n//     status=CampaignStatus.CANCELLED;\r\n//   }\r\n\r\n//   function postponeSale(uint newDate, uint newEndDate) public onlyOwner  {\r\n//       require(block.timestamp< saleInfo.saleStartTime, 'CAMPAIGN: Can only postpone before Sale StartTime');\r\n//       require(newDate > saleInfo.saleStartTime , 'CAMPAIGN: New date must be grt than oldDate');\r\n//       require(newEndDate > newDate, 'CAMPAIGN: End Date must be grt than Sale StartTime');\r\n//       saleInfo.saleStartTime = newDate;\r\n//       saleInfo.saleEndTime = newEndDate;\r\n//   }\r\n\r\n//   function getEndDate() public view returns (uint256) {\r\n//     return saleInfo.saleEndTime;\r\n//   }\r\n\r\n//   function totalTokensExpectedToBeLocked() public view returns (uint256) {\r\n//     return DexLocker(_dexLockerAddress).totalTokensExpectedToBeLocked();\r\n//   }\r\n\r\n \r\n//   function setZSalesTokenAddress(address _tokenAddress) public onlyAdmin {\r\n//     zsalesTokenAddress = _tokenAddress;\r\n//   }\r\n\r\n\r\n//   /**************************|\r\n//   |          Tier Info       |\r\n//   |_________________________*/\r\n//   //add the address in Whitelist tier two to invest\r\n//   function disableTier2Whitelist() public onlyOwner {    \r\n//     useWhiteList= false;\r\n//   }\r\n\r\n//   //add the address in Whitelist tier two to invest\r\n//   function submitTier2Whitelist(bytes32 whitelistMerkleRoot) public onlyOwner {\r\n//     require(block.timestamp < saleInfo.saleStartTime, 'CAMPAIGN: Can only alter whitelisting before Sale StartTime');\r\n//     useWhiteList= true;\r\n//     _whitelistTierTwoMerkleRoot=whitelistMerkleRoot;\r\n//   }\r\n\r\n//   // check the address is a Token Holder\r\n//   function isAllowedInTier1(address _address) public view returns(bool) {\r\n\r\n//     IERC20 token = IERC20(zsalesTokenAddress);\r\n//     return token.balanceOf(_address) > 0;\r\n//   }\r\n\r\n\r\n//   // check the address in whitelist tier two\r\n//   function isInTier2WhiteList(bytes32[] memory proof, address claimer) public view returns(bool) {\r\n    \r\n//     bytes32 _leaf = keccak256(abi.encodePacked(claimer));\r\n//     return MerkleProof.verify(proof, _whitelistTierTwoMerkleRoot, _leaf);\r\n    \r\n//   }\r\n\r\n//   /**\r\n//     * @dev Throws if called by any account other than the owner.\r\n//   */\r\n//   modifier onlyAdmin() {\r\n//       require(_admin == _msgSender(), \"ADMIN: caller is not the admin\");\r\n//       _;\r\n//   }\r\n\r\n//   function changeAdmin(address newAdmin) public onlyAdmin  {\r\n//       require(_msgSender() == _admin, 'ADMIN: Only Admin can change');\r\n//       address oldOwner = _admin;\r\n//       _admin=newAdmin;\r\n\r\n//       emit AdminOwnershipTransferred(oldOwner, newAdmin);\r\n//   }\r\n\r\n  \r\n//   function getHardCap() public view returns (uint) {\r\n//     return saleInfo.hardCap;\r\n//   }\r\n\r\n//   /**************************|\r\n//   |          Setters         |\r\n//   |_________________________*/\r\n//   function setKYC(bool kyc) public onlyAdmin  {\r\n//       require(block.timestamp< saleInfo.saleStartTime, 'CAMPAIGN: Can only change KYC before Sale StartTime');\r\n//       hasKYC= kyc;\r\n//   } \r\n\r\n//   function setTier1TimeLineInHours (uint newValue) public onlyAdmin {\r\n//     tier1TimeLineInHours=newValue;\r\n//   }\r\n\r\n  \r\n//   function setAudited(bool audit) public onlyAdmin  {\r\n//     require(block.timestamp< saleInfo.saleStartTime, 'CAMPAIGN: Can only change Audit state before Sale StartTime');\r\n//       _isAudited= audit;\r\n//   }\r\n//   function isAudited() public view returns (bool, string memory ) {\r\n//     return (_isAudited, auditUrl);\r\n//   }\r\n\r\n\r\n//   /**\r\n//     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\r\n//     * `recipient`, forwarding all available gas and reverting on errors.\r\n//     *\r\n//     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\r\n//     * of certain opcodes, possibly making contracts go over the 2300 gas limit\r\n//     * imposed by `transfer`, making them unable to receive funds via\r\n//     * `transfer`. {sendValue} removes this limitation.\r\n//     *\r\n//     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\r\n//     *\r\n//     * IMPORTANT: because control is transferred to `recipient`, care must be\r\n//     * taken to not create reentrancy vulnerabilities. Consider using\r\n//     * {ReentrancyGuard} or the\r\n//     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\r\n//     */\r\n//   function sendValue(address payable recipient, uint256 amount) internal {\r\n//       require(address(this).balance >= amount, \"Address: insufficient balance\");\r\n\r\n//       // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\r\n//       (bool success, ) = recipient.call{ value: amount }(\"\");\r\n//       require(success, \"Address: unable to send value, recipient may have reverted\");\r\n//   }\r\n\r\n  \r\n//   // send coin to the contract address\r\n//   function submitBid(bytes32[] calldata proof) public payable  {\r\n//     uint256 bid = msg.value;\r\n//     require(status != CampaignStatus.CANCELLED, 'Campaign: Sale Cancelled');\r\n//     require(status != CampaignStatus.FAILED , \"Campaign: Failed, Refunded is activated\");\r\n//     require(status == CampaignStatus.TOKENS_SUBMITTED , \"Campaign: Tokens not submitted\");\r\n//     require(totalCoinReceived < saleInfo.hardCap, 'Campaign: Sale Sold out');\r\n\r\n//     //require(block.timestamp >= saleInfo.saleStartTime, \"Campaign:The sale is not started yet \"); // solhint-disable\r\n//     require(block.timestamp <= saleInfo.saleEndTime, \"Campaign:The sale is closed\"); // solhint-disable\r\n//     require(totalCoinReceived + bid <= saleInfo.hardCap, \"Campaign: purchase would exceed max cap\");\r\n//     // minAllocationPerUser\r\n    \r\n//     require( bid >= minAllocationPerUser ,\"Campaign:You are investing less than Min Buy limit!\");\r\n          \r\n//     address sender = _msgSender();\r\n\r\n//     if(block.timestamp >= saleInfo.saleStartTime) {\r\n//         if(useWhiteList){          \r\n//           require(isInTier2WhiteList(proof,sender ), \"Campaign: You are not in whitelist\");\r\n//         }\r\n//         require(totalCoinInTierTwo + bid <= tierTwohardCap, \"Campaign: purchase would exceed Tier two max cap\");\r\n//         require(buyInTwoTier[sender] + bid <= maxAllocationPerUserTierTwo ,\"Campaign:You are investing more than your tier-2 limit!\");\r\n//         buyInTwoTier[sender] += bid;\r\n//         buyInAllTiers[sender] += bid;\r\n//         totalCoinReceived += bid;\r\n//         totalCoinInTierTwo += bid;\r\n//         totalParticipants++;\r\n    \r\n//         emit ValueReceived(sender, bid);\r\n\r\n        \r\n//     }\r\n//     else if (block.timestamp >= saleInfo.saleStartTime - (tier1TimeLineInHours * 1 hours ) ) {  // istokenholder and isstill in tokenholder sales part  //  isInTier1WhiteList(msg.sender)\r\n//         require(isAllowedInTier1(msg.sender) , \"Campaign: Only Tokenholders are allowed to buy in Tier 1 window\");\r\n//         require(totalCoinInTierOne + bid <= tierOnehardCap, \"Campaign: purchase would exceed Tier one max cap\");\r\n//         require(buyInOneTier[msg.sender] + bid <= maxAllocationPerUserTierOne ,\"Campaign:You are investing more than your tier-1 limit!\");\r\n//         buyInOneTier[msg.sender] += bid;\r\n//         buyInAllTiers[msg.sender] += bid;\r\n//         totalCoinReceived += bid;\r\n//         totalCoinInTierOne += bid;\r\n//         totalParticipants++;\r\n\r\n//         emit ValueReceived(msg.sender, bid);\r\n\r\n    \r\n//     }    \r\n//     else{\r\n//       revert(\"Campaign:The sale is not started yet\");\r\n//     }\r\n\r\n//     // return '';\r\n//   }\r\n\r\n//   /**\r\n//   * @dev Withdraw tokens or coin by user after end time\r\n//   * If this project does not reach softcap, return their funds otherwise get tokens \r\n//   */\r\n//   function withdrawFunds () public   {\r\n    \r\n//     address usr = _msgSender();\r\n\r\n//     require(usr!= owner(), 'CAMPAIGN: Owners cannot withdraw' );\r\n//     // require(status.isCancelled, 'Campaign: Can only withdraw if Campaign Cancelled');\r\n\r\n//     // if campaign is sold out no need to wait for endtime finalize and setup liquidity\r\n//     require(block.timestamp >= saleInfo.saleEndTime || totalCoinReceived>= saleInfo.hardCap  , \"CAMPAIGN: ongoing sales\");\r\n\r\n//     require(buyInAllTiers[usr] > 0, \"CAMPAIGN: No COIN to claim\");\r\n\r\n//     if(totalCoinReceived < saleInfo.softCap){\r\n//       status= CampaignStatus.FAILED ;\r\n//     }\r\n    \r\n    \r\n//     uint256 amount =  buyInAllTiers[usr];\r\n//     buyInAllTiers[usr] = 0;\r\n//     uint256 amountTokens =  amount * saleInfo.listRate;\r\n    \r\n//     if(status== CampaignStatus.FAILED){\r\n//         // return back funds\r\n//         payable(usr).transfer(amount);\r\n//         emit Refunded(usr, amount);\r\n        \r\n//     }else{\r\n//       IERC20 _token = IERC20(saleInfo.tokenAddress);\r\n//       // Transfer Tokens to User\r\n//       _token.safeTransfer(usr, amountTokens);\r\n      \r\n//       emit Withdrawn(usr, amountTokens);\r\n//     }    \r\n//   }\r\n\r\n//   /**\r\n//   * @dev Withdraw owner tokens If this project does not reach softcap\r\n//   */\r\n//   function withdrawOwnerTokens () public   onlyOwner {\r\n    \r\n    \r\n//     require(status== CampaignStatus.FAILED || status== CampaignStatus.CANCELLED, 'Campaign: Can only withdraw if Campaign Cancelled or Failed');\r\n\r\n    \r\n//     require(block.timestamp >= saleInfo.saleEndTime , \"CAMPAIGN: Can only withdraw after End date\");\r\n\r\n    \r\n    \r\n//     IERC20 _token = IERC20(saleInfo.tokenAddress);\r\n//     uint256 tokensAmount = _token.balanceOf(address(this));\r\n    \r\n//     require(tokensAmount > 0, \"CAMPAIGN: No Tokens to claim\");\r\n//     _token.safeTransfer(msg.sender, tokensAmount);\r\n//   }\r\n\r\n//   /**\r\n//     * Setup liquidity and transfer all amounts according to defined percents, if softcap not reached set Refunded flag\r\n//     */\r\n//   function finalizeAndSetupLiquidity() public nonReentrant {\r\n//     require(totalCoinReceived>= saleInfo.hardCap || block.timestamp > saleInfo.saleEndTime , \"Campaign: not sold out or time not elapsed yet\" );\r\n//     require(status != CampaignStatus.FAILED, \"CAMPAIGN: campaign will be refunded\");\r\n//     require(status != CampaignStatus.CANCELLED, \"CAMPAIGN: campaign was cancelled\");\r\n//     //\r\n//     if(totalCoinReceived < saleInfo.softCap){ // set to failed and stop\r\n//         status= CampaignStatus.FAILED ;\r\n//         return;\r\n//     }\r\n\r\n    \r\n//     IERC20 _token = IERC20(saleInfo.tokenAddress);\r\n\r\n    \r\n//     uint256 currentCoinBalance = address(this).balance;\r\n//     require(currentCoinBalance > 0, \"CAMPAIGN: Coin balance needs to be above zero\" );\r\n//     uint256 liquidityAmount = (currentCoinBalance * saleInfo.liquidityPercent) / 10000;\r\n//     uint256 tokensAmount = _token.balanceOf(address(this));\r\n//     require(tokensAmount >= liquidityAmount * saleInfo.dexListRate  , \"CAMPAIGN: Not sufficient tokens amount\");\r\n    \r\n\r\n//     uint256 zsaleFeeAmount = currentCoinBalance * zsaleFee / 10000;\r\n//     uint256 zsaleTokenFeeAmount = currentCoinBalance * zsaleTokenFee/ 10000;\r\n    \r\n//     //Fees\r\n//     payable(zsalesWalletAddress).transfer(zsaleFeeAmount);\r\n//     _token.safeTransfer(zsalesWalletAddress, zsaleTokenFeeAmount);\r\n//     // payable(_teamWallet).transfer(teamAmount);\r\n\r\n    \r\n//     //liquidity pair\r\n//     // payable(_dexLockerAddress).transfer(liquidityAmount);\r\n//     (bool success,) = _dexLockerAddress.call{ value: liquidityAmount }(\"\");\r\n//     require(success, \"CAMPAIGN: Transfer to DExLocker failed\");//use call , since dexlocker is a proxy\r\n    \r\n//     _token.safeTransfer(_dexLockerAddress, liquidityAmount * saleInfo.dexListRate );\r\n\r\n//     DexLocker locker = DexLocker(_dexLockerAddress);    \r\n//     if(useRaisedFundsVesting){\r\n//       locker.startRaisedFundsLock( totalCoinReceived );\r\n//     }\r\n//     locker.addLiquidity(currentCoinBalance);\r\n    \r\n//     status=CampaignStatus.LIQUIDITY_SETUP;\r\n//   }\r\n\r\n  \r\n//   function getCampaignInfo() public view returns( uint256 softcap, uint256 hardcap,uint256 saleStartTime, uint256 saleEndTime,uint256 listRate, uint256 dexListRate, uint liquidity,uint _liquidityReleaseTime ,uint256 totalCoins, uint256 totalParticipant, bool useWhiteList, bool hasKyc, bool isAuditd ){\r\n//       return ( saleInfo.softCap, saleInfo.hardCap,saleInfo.saleStartTime, saleInfo.saleEndTime, saleInfo.listRate, saleInfo.dexListRate, saleInfo.liquidityPercent, liquidityReleaseTime, totalCoinReceived,totalParticipants, useWhiteList,hasKYC, _isAudited );\r\n//   }\r\n\r\n  \r\n\r\n//   function getCampaignStatus() public view returns(CampaignStatus ){\r\n//       return status ;\r\n//   }\r\n\r\n//   function getCampaignPeriod() public view returns(uint256 saleStartTime, uint256 saleEndTime ){\r\n//       return (saleInfo.saleStartTime, saleInfo.saleEndTime );\r\n//   }\r\n\r\n//   function getCampaignSalePriceInfo() public view returns(uint256 , uint256,uint256 , uint256,uint256 , uint256,uint256 ){\r\n//       return (saleInfo.listRate, saleInfo.dexListRate, saleInfo.softCap, saleInfo.hardCap, tierOnehardCap,tierTwohardCap, maxAllocationPerUserTierTwo  );\r\n//   }\r\n\r\n//   /**\r\n//     * \r\n//     */\r\n//   function isSoldOut() public view returns (bool) {\r\n//       return totalCoinReceived>= saleInfo.hardCap;\r\n//   }\r\n\r\n//     /**\r\n//     * \r\n//     */\r\n//   function hasFailed() public view returns (bool) {\r\n//       return status == CampaignStatus.FAILED;\r\n//   }\r\n\r\n  \r\n//   function dexLockerAddress() public view onlyAdmin returns (address) {\r\n//       return _dexLockerAddress;\r\n//   }\r\n\r\n//   function tokenAddress() public view returns (address) {\r\n//       return saleInfo.tokenAddress;\r\n//   }\r\n\r\n//   // Refund any mistakenly sent in ERC20\r\n//   function refundERC20(IERC20 _token, address recipient, uint256 amount) public onlyAdmin {\r\n      \r\n//     _token.safeTransfer(recipient, amount);\r\n//   }\r\n\r\n// }"
    },
    "contracts/Errors.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.27;\r\n\r\nerror OnlyDeployer();\r\nerror NoToken();\r\nerror NoZeroTokenAddress();\r\nerror NoEthForLiquidity();\r\nerror NoTokenBalanceForLiquidity();\r\nerror NoPurchaseTokensForLiquidity();\r\nerror NoTokensForLiquidity();\r\nerror RouterApprovalFailed();\r\n\r\nerror AlreadyReachedSoftCap(uint cap);\r\n\r\nerror LiquiditySetupAlreadyDone();\r\n\r\nerror AddLiquidityNotCalledYet();\r\nerror NoLPTokensToRelease();\r\nerror NoTokensToRelease();\r\nerror NoPurchaseTokensToRelease();\r\nerror CurrentTimeIsBeforeRelease();\r\n\r\nerror SaleEndTimeBeforeStartTime();\r\nerror LiquidityAboveLimit(uint limit);\r\n\r\nerror UpdateAfterSaleStartTime();\r\n\r\nerror TierCapTooLow(uint limit);\r\nerror TierCapsExceedHardCap();\r\nerror TierOneCapExceedsHardCap();\r\nerror TierTwoCapExceedsHardCap();\r\nerror MinAllocationOutOfRange();\r\nerror TierOneMaxAllocationOutOfRange();\r\nerror TierTwoMaxAllocationOutOfRange();\r\n\r\nerror NotOwner();\r\nerror NotAdmin();\r\nerror CannotCancelAfterSaleStartTime();\r\nerror PostponeBeforeSaleStartTime();\r\nerror NewDateLessThanOldDate();\r\nerror EndDateLessThanStartTime();\r\n\r\nerror AlterWhitelistingAfterSaleStartTime();\r\n\r\nerror KYCAfterSaleStartTime();\r\nerror AuditAfterSaleStartTime();\r\n\r\nerror SaleCancelled();\r\nerror SaleFailed();\r\nerror NotTokenSubmitted();\r\nerror SoldOutError();\r\nerror ClosedSale();\r\nerror ExceedMaxCap();\r\nerror LessThanMinBuy();\r\n\r\n\r\nerror NotInTier2Whitelist();\r\nerror ExceedTierTwoMaxCap();\r\nerror ExceedTierTwoUserLimit();\r\nerror NotInTier0();\r\nerror ExceedTierZeroMaxCap();\r\nerror ExceedTierZeroUserLimit();\r\nerror NotInTier1();\r\nerror ExceedTierOneMaxCap();\r\nerror ExceedTierOneUserLimit();\r\nerror SaleNotStarted();\r\n\r\nerror OwnersCannotWithdraw();\r\nerror OngoingSales();\r\nerror NoCoinsToClaim();\r\nerror NoCoin();\r\n\r\nerror CampaignFailed();\r\nerror CampaignCancelled();\r\n\r\nerror NotEndDate();\r\nerror NoReachSoftCap();\r\n\r\nerror RequireCancelorFail();\r\nerror NoTokens();\r\n\r\nerror NoSoldOutOrEndDate();\r\n\r\nerror OnlyDecimals18AndBelow();\r\n\r\nerror TransferDExLockerFailed();\r\n\r\nerror OwnerHasWithdrawnAlready();\r\n\r\n\r\nerror InvalidDexRouterAddress(address addr);\r\nerror InvalidSalesTokenAddress(address addr);\r\nerror InvalidPurchaseTokenAddress(address addr);\r\nerror InvalidOwnerAddress(address addr);\r\nerror InvalidDeployerAddress(address addr);"
    },
    "contracts/IDexRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface IDexRouter {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n\r\n    \r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external  returns (uint amountA, uint amountB, uint liquidity) ;\r\n\r\n\r\n\t\r\n    \r\n\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\t\r\n\t\r\n\tfunction swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\t\r\n\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n\r\n\t// Identical to swapExactTokensForTokens, but succeeds for tokens that take a fee on transfer.\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    \r\n}\r\n\r\ninterface IDexFactory {\r\n    function getPair(address token0, address token1) external view returns (address);\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n}\r\n"
    },
    "contracts/Interfaces/Turnstile.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\ninterface Turnstile {\r\n    function register(address) external returns(uint256);\r\n}"
    },
    "contracts/Lock.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\npragma solidity ^0.8.9;\n\n// Import this file to use console.log\nimport \"hardhat/console.sol\";\n\ncontract Lock {\n    uint public unlockTime;\n    address payable public owner;\n\n    event Withdrawal(uint amount, uint when);\n\n    constructor(uint _unlockTime) payable {\n        require(\n            block.timestamp < _unlockTime,\n            \"Unlock time should be in the future\"\n        );\n\n        unlockTime = _unlockTime;\n        owner = payable(msg.sender);\n    }\n\n    function withdraw() public {\n        // Uncomment this line to print a log in your terminal\n        // console.log(\"Unlock time is %o and block timestamp is %o\", unlockTime, block.timestamp);\n\n        require(block.timestamp >= unlockTime, \"You can't withdraw yet\");\n        require(msg.sender == owner, \"You aren't the owner\");\n\n        emit Withdrawal(address(this).balance, block.timestamp);\n\n        owner.transfer(address(this).balance);\n    }\n}\n"
    },
    "contracts/Lockers/DexLocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport {IDexRouter} from \"../IDexRouter.sol\";\r\nimport \"./VestSchedule.sol\";\r\nimport \"./TokenLocker.sol\";\r\n\r\nimport \"./PurchasedCoinVestingVault.sol\";\r\nimport \"./LiquidityLocker.sol\";\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"hardhat/console.sol\";\r\n\r\nerror NotEnoughCoinsForRaisedFundsLock();\r\n\r\n/// @title IDexLocker\r\n/// @notice Manages liquidity and vesting for tokens raised in sales campaigns\r\ninterface IDexLocker {\r\n    function initialize(\r\n        address dexRouterAddress,\r\n        address token,\r\n        address purchaseToken,\r\n        address deployer,\r\n        address owner,\r\n        address purchasedCoinVestingVaultImplementationAddress\r\n    ) external;\r\n\r\n    function setupLock(\r\n        // uint liquidityPercentOfRaisedFunds,uint256 lpReleaseTime,\r\n        uint[2] calldata lpDetails,\r\n\r\n        // uint minRaisedFunds,uint maxRaisedFunds, \r\n        uint[2] calldata raisedFunds,\r\n        \r\n        // uint256 saleListPrice,  uint256 dexListPrice, \r\n        uint256[2] calldata saleAndDexRates,\r\n\r\n        bool useTeamTokenVesting, \r\n        uint256[5] calldata teamTokenVestingDetails, \r\n        bool useRaisedFundsVesting, \r\n        uint256[3] calldata raisedFundVestingDetails \r\n    ) external;\r\n\r\n     \r\n     /// @dev If campaign Locks raised fund, lock the calculated amount\r\n     ///\r\n    function startRaisedFundsLock(uint256 raisedAmount) external payable;\r\n\r\n    // function receiveCoinVaultCoins(uint amount) external payable;\r\n\r\n    function addLiquidity(uint256 raisedFunds) external;\r\n\r\n    function getLiquidityReleaseTime() external view returns (uint256);\r\n\r\n    function getOwner() external view returns (address);\r\n\r\n    function releaseLPTokens() external;\r\n\r\n    function releaseTeamTokens() external;\r\n\r\n    function releaseCoinVaultETH() external;\r\n\r\n    function coinVaultAddress() external view returns (address);\r\n\r\n    function tokenLockerAddress() external view returns (address);\r\n\r\n    function liquidityLockerAddress() external view returns (address);\r\n\r\n    function totalTokensExpectedToBeLocked() external view returns(uint);\r\n}\r\n\r\n/// @title DexLocker\r\n/// @notice Manages liquidity and vesting for tokens raised in sales campaigns, LP TOkens and Team Vesting tokens\r\ncontract DexLocker is Initializable, IDexLocker{\r\n    error DLOnlyDeployer();\r\n    error DLReleaseBeforeTime();\r\n    using SafeERC20 for IERC20;\r\n\r\n     // timestamp when token release is enabled\r\n    uint256 private _lpReleaseTime;\r\n\r\n    uint256 private _dexListPrice;\r\n\r\n    \r\n    address private _owner;\r\n\r\n    address private _deployer;\r\n\r\n    uint256 constant private MAX_INT = 2**256 - 1;\r\n\r\n    uint public totalTokensExpectedToBeLocked;\r\n\r\n    address private _token;\r\n    address private _purchaseToken;\r\n    address private _lpTokenPairAddress;\r\n\r\n    IDexRouter private _dexRouter;\r\n\r\n    TokenLocker private _tokenLocker;\r\n    PurchasedCoinVestingVault private _purchasedCoinVestingVault;\r\n    LiquidityLocker private _liquidityLocker;\r\n    uint private _liquidityPercentOfRaisedFunds;\r\n\r\n    /**\r\n    Maps to \r\n    \r\n        uint256 _percentOfRaisedFundsToLock,\r\n        uint256 _vestingDurationInDays,\r\n        uint256 _vestingCliffInDays\r\n     */\r\n    uint256[3] _raisedFundVestingDetails;\r\n    bool _useRaisedFundsVesting;\r\n\r\n    address  _purchasedCoinVestingVaultImplementationAddress;\r\n\r\n    ///Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be taken over by an attacker, which may impact the proxy. \r\n    /// To prevent the implementation contract from being used, you should invoke the _disableInitializers function in the constructor to automatically lock it when it is deployed\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    function initialize(address dexRouterAddress, address token, address purchaseToken,address deployer,address owner, address purchasedCoinVestingVaultImplementationAddress ) public initializer  {\r\n        \r\n        require(dexRouterAddress != address(0), InvalidDexRouterAddress(dexRouterAddress));\r\n        require(token != address(0), InvalidSalesTokenAddress(token));\r\n        require(purchaseToken != address(0), InvalidPurchaseTokenAddress(purchaseToken));\r\n        require(deployer != address(0), InvalidDeployerAddress(deployer));\r\n        require(owner != address(0), InvalidOwnerAddress(owner));\r\n\r\n        _dexRouter = IDexRouter(dexRouterAddress);\r\n        _deployer = deployer; //msg.sender;\r\n        \r\n        _owner = owner;\r\n        _token = token; \r\n        _purchaseToken=purchaseToken;\r\n        _purchasedCoinVestingVaultImplementationAddress=purchasedCoinVestingVaultImplementationAddress;       \r\n    }\r\n\r\n    \r\n    function setupLock(\r\n        // uint liquidityPercentOfRaisedFunds,uint256 lpReleaseTime,\r\n        uint[2] calldata lpDetails,\r\n\r\n        // uint minRaisedFunds,uint maxRaisedFunds, \r\n        uint[2] calldata raisedFunds,\r\n        \r\n        // uint256 saleListPrice,  uint256 dexListPrice, \r\n        uint256[2] calldata saleAndDexRates,\r\n\r\n        bool useTeamTokenVesting, \r\n        uint256[5] calldata teamTokenVestingDetails, \r\n        bool useRaisedFundsVesting, \r\n        uint256[3] calldata raisedFundVestingDetails \r\n    ) public {\r\n        \r\n        require(msg.sender == _deployer, DLOnlyDeployer());\r\n\r\n        require(lpDetails[1] > block.timestamp, DLReleaseBeforeTime());\r\n        \r\n\r\n        {\r\n            _lpReleaseTime = lpDetails[1];\r\n            _dexListPrice = saleAndDexRates[1];\r\n            _liquidityPercentOfRaisedFunds = lpDetails[0];\r\n\r\n            // _teamTokenVestingDetails=teamTokenVestingDetails; \r\n\r\n            totalTokensExpectedToBeLocked = 0;\r\n            \r\n            //Liquidty tokens\r\n            _liquidityLocker = new LiquidityLocker(address(_dexRouter),_token,_purchaseToken, _owner, saleAndDexRates[1], lpDetails[1], lpDetails[0], raisedFunds[0],raisedFunds[1]);\r\n            totalTokensExpectedToBeLocked =  _liquidityLocker.maxTokensExpected();\r\n\r\n            //Sold tokens\r\n            totalTokensExpectedToBeLocked += saleAndDexRates[0] * raisedFunds[1];\r\n        }\r\n\r\n        if(useTeamTokenVesting){\r\n            \r\n            _tokenLocker = new TokenLocker(_token, _owner,teamTokenVestingDetails[0],teamTokenVestingDetails[1],teamTokenVestingDetails[2],teamTokenVestingDetails[3],teamTokenVestingDetails[4] );\r\n            totalTokensExpectedToBeLocked += normalizeTokenAmount(teamTokenVestingDetails[0], IERC20Metadata(_token).decimals());\r\n        }\r\n        \r\n\r\n        _useRaisedFundsVesting=useRaisedFundsVesting;\r\n        if(_useRaisedFundsVesting){\r\n            for (uint8 i=0; i < 3 ; i++) {\r\n                _raisedFundVestingDetails[i] = raisedFundVestingDetails[i]; \r\n            }\r\n        }\r\n        \r\n    }\r\n\r\n    /**\r\n     * Raised funds\r\n     */\r\n    function startRaisedFundsLock(uint256 _raisedAmount) public payable {\r\n        require(msg.sender == _deployer, DLOnlyDeployer());\r\n\r\n        if(_useRaisedFundsVesting){\r\n\r\n            if(msg.value< _raisedFundVestingDetails[0] * _raisedAmount /10000 ) revert NotEnoughCoinsForRaisedFundsLock();\r\n            address newCoinVaultCloneAddress = Clones.clone(_purchasedCoinVestingVaultImplementationAddress);\r\n            _purchasedCoinVestingVault = PurchasedCoinVestingVault(payable(newCoinVaultCloneAddress) );\r\n            // _purchasedCoinVestingVault.initialize(_owner, _startTime,_amount, _vestingDurationInDays,_vestingCliffInDays);\r\n\r\n            _purchasedCoinVestingVault.initialize(_owner,block.timestamp, _raisedFundVestingDetails[0] * _raisedAmount /10000, _raisedFundVestingDetails[1],_raisedFundVestingDetails[2], _purchaseToken);\r\n            \r\n            //Send coins\r\n            if(_purchaseToken==address(0)){\r\n                payable(_purchasedCoinVestingVault).transfer(_raisedFundVestingDetails[0] * _raisedAmount /10000);\r\n            }else{\r\n                _purchasedCoinVestingVault.receiveTokens(_raisedFundVestingDetails[0] * _raisedAmount /10000 );\r\n            }\r\n            \r\n        }\r\n        \r\n    }\r\n\r\n    receive() external payable {\r\n        // payable(_coinLocker).transfer(msg.value);\r\n    }\r\n\r\n    /**\r\n     * Normalization function that adjusts token amounts to a common decimal base (18 decimals in this case). \r\n     * This function either scales up or scales down the token amount based on the number of decimals the token uses,\r\n     * ensuring the final amount will be always displayed with 18 decimals. \r\n     * Of course this can result in a minor truncation if tokens >18 decimals are being used, this must be considered\r\n     */\r\n    function normalizeTokenAmount(uint tokenAmount, uint tokenDecimals) public pure returns (uint) {\r\n        uint standardDecimal = 18;\r\n        if(tokenDecimals>standardDecimal){\r\n            return tokenAmount / (10 ** (tokenDecimals-standardDecimal));\r\n        }\r\n        else if(tokenDecimals< standardDecimal){\r\n            return tokenAmount * (10 ** (standardDecimal - tokenDecimals));\r\n        }\r\n        else{\r\n            return tokenAmount;\r\n        }\r\n    }\r\n\r\n    // function receiveCoinVaultCoins(uint amount) public payable {\r\n    //     require(msg.sender == _deployer, \"DL:OnlyDeployer\");\r\n    //     if(_purchaseToken==address(0)){\r\n    //         payable(_purchasedCoinVestingVault).transfer(msg.value);\r\n    //     }else{\r\n    //         _purchasedCoinVestingVault.receiveTokens(amount);\r\n    //     }\r\n    // }\r\n\r\n    /**\r\n    * @dev Add Liquidity to Dex at defined price, if no pool exists it will create one.\r\n    *  Approve token for router, require contract to have the necessary tokens\r\n    *\r\n     */\r\n    function addLiquidity(uint256 normalizedRaisedFunds) public {\r\n        \r\n        uint tokenDecimals = IERC20Metadata(_token).decimals();\r\n        uint purchaseCoinDecimals = 18;\r\n        if(address(0)!= _purchaseToken){\r\n            purchaseCoinDecimals = IERC20Metadata(_token).decimals();\r\n        }\r\n        \r\n        uint liquidityAmount = (normalizedRaisedFunds * _liquidityPercentOfRaisedFunds / 10000) / 10**(18-purchaseCoinDecimals);\r\n        // (bool success,) = liquidityLockerAddress().call{ value: liquidityAmount }(\"\");\r\n        // require(success, \"DL: Transfer to liquidityLocker failed\");//use call , since dexlocker is a proxy\r\n        \r\n        if(_purchaseToken==address(0)){//Native coin\r\n            payable(liquidityLockerAddress()).transfer(liquidityAmount);\r\n        }else{\r\n            // _liquidityLocker.receivePurchaseTokens(liquidityAmount);\r\n            IERC20(_purchaseToken).safeTransfer(liquidityLockerAddress(), liquidityAmount  );\r\n        }\r\n\r\n              \r\n        IERC20(_token).safeTransfer(liquidityLockerAddress(), (normalizedRaisedFunds * _liquidityPercentOfRaisedFunds * _dexListPrice /10000)/ 10**(18-tokenDecimals) );\r\n        \r\n        _liquidityLocker.setCampaignSucceded(true);\r\n        \r\n        _liquidityLocker.addLiquidity();\r\n        \r\n    }\r\n\r\n  \r\n\r\n   /**\r\n     * @return the time when the LP tokens are released.\r\n     */\r\n    function getLiquidityReleaseTime() public view returns (uint256) {\r\n        return _lpReleaseTime;\r\n    }\r\n\r\n      /**\r\n     * @return the owner of the locked funds\r\n     */\r\n    function getOwner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    /**\r\n     * @notice Transfers tokens held by Lock to owner.\r\n       @dev Able to withdraw LP funds after release time \r\n     */\r\n    function releaseLPTokens() public {\r\n        _liquidityLocker.releaseLPTokens(); \r\n    }\r\n\r\n    /**\r\n     * @notice Transfers tokens held by Lock to owner.\r\n     */\r\n    function releaseTeamTokens() public {\r\n        _tokenLocker.release();\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ETH back to the owner\r\n     */\r\n    function releaseCoinVaultETH() public {\r\n        _purchasedCoinVestingVault.claimVestedCoins();\r\n    }\r\n\r\n    function coinVaultAddress() public view returns (address) {\r\n        return address(_purchasedCoinVestingVault);\r\n    }\r\n\r\n    function tokenLockerAddress() public view returns (address) {\r\n        return address(_tokenLocker);\r\n    }\r\n\r\n    function liquidityLockerAddress() public view returns (address) {\r\n        return address(_liquidityLocker);\r\n    }\r\n}"
    },
    "contracts/Lockers/DexLockerFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\nimport \"@openzeppelin/contracts/proxy/Clones.sol\";\r\nimport {DexLocker} from \"./DexLocker.sol\";\r\nimport \"../Errors.sol\";\r\n\r\n\r\n/// @title DexLockerFactory\r\n/// @notice Factory contract for creating DexLocker instances using Clones - Used to avoid contract size becoming too large\r\ncontract DexLockerFactory {\r\n    /// @notice Address of the DexLocker implementation contract\r\n    address   _dexLockerImplementationAddress;\r\n    address  _coinVaultImplementationAddress;\r\n\r\n    \r\n\r\n    constructor(address  dexLockerImplementationAddress,address  coinVaultImplementationAddress){\r\n        _dexLockerImplementationAddress=dexLockerImplementationAddress;\r\n        _coinVaultImplementationAddress=coinVaultImplementationAddress;\r\n    }\r\n    \r\n\r\n    /// @notice Creates a new DexLocker instance\r\n    /// @param dexRouterAddress Address of the DEX router\r\n    /// @param salesTokenAddress Address of the sales token\r\n    /// @param purchaseTokenAddress Address of the purchase token\r\n    /// @param deployer Address of the deployer\r\n    /// @param owner Address of the locker owner\r\n    /// @return Address of the newly created DexLocker instance\r\n    function createDexLocker(address dexRouterAddress, address salesTokenAddress, address purchaseTokenAddress,address deployer,address owner)  public returns(address) {\r\n        require(dexRouterAddress != address(0), InvalidDexRouterAddress(dexRouterAddress));\r\n        require(salesTokenAddress != address(0), InvalidSalesTokenAddress(salesTokenAddress));\r\n        require(purchaseTokenAddress != address(0), InvalidPurchaseTokenAddress(purchaseTokenAddress));\r\n        require(deployer != address(0), InvalidDeployerAddress(deployer));\r\n        require(owner != address(0), InvalidOwnerAddress(owner));\r\n\r\n        address payable newCloneAddress = payable(Clones.clone(_dexLockerImplementationAddress ) );\r\n        DexLocker(newCloneAddress).initialize(dexRouterAddress,salesTokenAddress,purchaseTokenAddress, deployer, owner,_coinVaultImplementationAddress);\r\n\r\n        return  newCloneAddress;\r\n    }\r\n}"
    },
    "contracts/Lockers/LiquidityLocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.28;\r\n\r\n\r\nimport {IDexRouter, IDexFactory} from \"../IDexRouter.sol\";\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"hardhat/console.sol\";\r\nimport \"../Errors.sol\";\r\n\r\n\r\n\r\n\r\n\r\n// locks liquidity for LP tokens based on % of raised funds\r\ncontract LiquidityLocker{\r\n\r\n    using SafeERC20 for IERC20;\r\n    // using SafeMath for uint256;\r\n\r\n    \r\n\r\n     // timestamp when token release is enabled\r\n    uint256 private _releaseTime;\r\n\r\n    uint256 private _price; \r\n    \r\n\r\n    address private _owner; \r\n\r\n    address private _deployer;\r\n\r\n    uint256 constant private MAX_INT = 2**256 - 1;\r\n\r\n    uint256 public minTokensExpected ;\r\n    uint256 public maxTokensExpected ;\r\n    uint256 public minPurchaseTokenExpected ;\r\n    uint256 public maxPurchaseTokenExpected ;\r\n    \r\n\r\n    address private _token;\r\n    address purchaseTokenAddress;\r\n    address public lpTokenPairAddress;\r\n\r\n    IDexRouter private _dexRouter;\r\n    IDexFactory private _dexFactory;\r\n\r\n    bool private _campaignSucceded;\r\n\r\n    event LiquidityAddedToRouter(address indexed router, address indexed token1,address indexed token2, uint amountToken1, uint amountToken2);\r\n\r\n\r\n    constructor(address dexRouterAddress, address token,address purchaseToken, address owner, \r\n      uint256 price,uint256 releaseTime, \r\n    uint liquidityPercentOfRaisedFunds,uint minRaisedFunds, uint maxRaisedFunds) {\r\n        \r\n        if(releaseTime <= block.timestamp){\r\n          revert CurrentTimeIsBeforeRelease();\r\n        }\r\n        _releaseTime = releaseTime;\r\n        _dexRouter = IDexRouter(dexRouterAddress);\r\n        _dexFactory = IDexFactory(_dexRouter.factory());\r\n\r\n        _deployer = msg.sender;\r\n        _price = price;\r\n        _owner = owner;\r\n        _token = token;\r\n        purchaseTokenAddress=purchaseToken;\r\n        minPurchaseTokenExpected = (liquidityPercentOfRaisedFunds* minRaisedFunds)  / 10000;\r\n        minTokensExpected = _price * minPurchaseTokenExpected;\r\n\r\n        maxPurchaseTokenExpected = (liquidityPercentOfRaisedFunds * maxRaisedFunds)  / 10000;\r\n        maxTokensExpected = _price * maxPurchaseTokenExpected;\r\n\r\n    }\r\n\r\n    receive() external payable {\r\n\r\n    }\r\n\r\n    // function receivePurchaseTokens(uint256 amount) public payable {\r\n    //   IERC20(purchaseTokenAddress).safeTransferFrom(msg.sender, address(this), amount);\r\n    // }\r\n\r\n    /**\r\n    * @dev Add Liquidity to Dex at defined price, if no pool exists it will create one.\r\n    *  Approve token for router, require contract to have the necessary tokens\r\n    *\r\n    */\r\n    function addLiquidity() public {\r\n        if (msg.sender != address(_deployer)) revert OnlyDeployer();\r\n        if (_token == address(0)) revert NoZeroTokenAddress();\r\n        if (purchaseTokenAddress == address(0)) {\r\n            _addLiquidityWithEth();\r\n        } else {\r\n            _addLiquidityWithErc20PurchaseToken();\r\n        }\r\n    }\r\n\r\n    function _addLiquidityWithEth() private {\r\n        uint256 etherBalance = address(this).balance;\r\n        uint256 tokensAmount = _price * etherBalance/ 10**(18 - IERC20Metadata(_token).decimals());\r\n        \r\n        // uint256 tokensAmountMin = tokensAmount - (_price * etherBalance);\r\n        if (etherBalance < minPurchaseTokenExpected) revert NoEthForLiquidity();\r\n        if (IERC20(_token).balanceOf(address(this)) < minTokensExpected) revert NoTokenBalanceForLiquidity();\r\n        \r\n        lpTokenPairAddress = _dexFactory.getPair(_token, _dexRouter.WETH());\r\n        if (lpTokenPairAddress == address(0)) {\r\n            lpTokenPairAddress = _dexFactory.createPair(_token, _dexRouter.WETH());\r\n        }\r\n        \r\n        IERC20(_token).approve(address(_dexRouter), MAX_INT);\r\n        IERC20(_token).approve(lpTokenPairAddress, MAX_INT);\r\n\r\n        IERC20(_dexRouter.WETH()).approve(address(_dexRouter), MAX_INT);\r\n        IERC20(_dexRouter.WETH()).approve(lpTokenPairAddress, MAX_INT);\r\n        \r\n        _dexRouter.addLiquidityETH{value: etherBalance}(\r\n            _token,\r\n            tokensAmount,\r\n            tokensAmount,\r\n            etherBalance,\r\n            address(this),\r\n            block.timestamp + 100\r\n        );\r\n        \r\n        emit LiquidityAddedToRouter(address(_dexRouter), address(0),_token,etherBalance,tokensAmount  );\r\n    }\r\n\r\n\r\n    \r\n\r\n    function _addLiquidityWithErc20PurchaseToken() private {       \r\n      \r\n      uint256 puchaseTokenBalance = IERC20(purchaseTokenAddress).balanceOf(address(this));\r\n      uint256 tokenBalance = IERC20(_token).balanceOf(address(this));\r\n\r\n      uint256 tokensAmount = _price * puchaseTokenBalance;\r\n      // uint256 tokensAmountMin = tokensAmount - (_price * puchaseTokenBalance); \r\n      if (puchaseTokenBalance < minPurchaseTokenExpected) revert NoPurchaseTokensForLiquidity();\r\n      if (tokenBalance < minTokensExpected) revert NoTokensForLiquidity();\r\n       \r\n      \r\n      lpTokenPairAddress = _dexFactory.getPair(_token, purchaseTokenAddress );\r\n      if(lpTokenPairAddress==address(0)){\r\n        lpTokenPairAddress = _dexFactory.createPair(_token, purchaseTokenAddress);          \r\n      }        \r\n      \r\n      IERC20(_token).approve(address(_dexRouter), MAX_INT);\r\n      IERC20(purchaseTokenAddress).approve(address(_dexRouter), MAX_INT);\r\n      IERC20(_token).approve(lpTokenPairAddress, MAX_INT);\r\n      IERC20(purchaseTokenAddress).approve(lpTokenPairAddress, MAX_INT);\r\n\r\n\r\n      _dexRouter.addLiquidity(\r\n          _token,\r\n          purchaseTokenAddress,\r\n          tokenBalance,\r\n          puchaseTokenBalance,\r\n          tokenBalance,\r\n          puchaseTokenBalance,            \r\n          address(this),\r\n          block.timestamp + 100\r\n      );\r\n      \r\n      emit LiquidityAddedToRouter(address(_dexRouter), purchaseTokenAddress,_token,puchaseTokenBalance,tokenBalance  );\r\n    }\r\n\r\n    function setCampaignSucceded(bool status) public  {      \r\n      if (msg.sender != address(_deployer)) revert OnlyDeployer();\r\n      _campaignSucceded=status;\r\n    }\r\n\r\n   /**\r\n     * @return the time when the tokens are released.\r\n     */\r\n    function getReleaseTime() public view returns (uint256) {\r\n        return _releaseTime;\r\n    }\r\n\r\n      /**\r\n     * @return the owner of the locked funds\r\n     */\r\n    function getOwner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    /**\r\n     * @notice Transfers LP tokens held by Lock to owner.\r\n       @dev Able to withdraw LP funds after release time \r\n     */\r\n    function releaseLPTokens() public {\r\n      if (block.timestamp < _releaseTime) revert CurrentTimeIsBeforeRelease();\r\n      if (lpTokenPairAddress == address(0)) revert AddLiquidityNotCalledYet();\r\n\r\n      IERC20 lptoken = IERC20(lpTokenPairAddress);\r\n      uint256 amount = lptoken.balanceOf(address(this));\r\n      if (amount == 0) revert NoLPTokensToRelease();\r\n\r\n      lptoken.safeTransfer(_owner, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers tokens held by Lock to owner.\r\n       @dev Able to withdraw LP funds after release time \r\n     */\r\n    function releaseSalesTokens() public {\r\n      if (block.timestamp < _releaseTime) revert CurrentTimeIsBeforeRelease();\r\n      if (_campaignSucceded && lpTokenPairAddress == address(0)) revert AddLiquidityNotCalledYet();\r\n\r\n      uint256 amount = IERC20(_token).balanceOf(address(this));\r\n      if (amount == 0) revert NoTokensToRelease();\r\n\r\n      IERC20(_token).safeTransfer(_owner, amount);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers ETH/Purchase tokens back to the owner\r\n       @dev Function used only if it was not used all the ETH\r\n     */\r\n    function releasePurchaseTokens() public {\r\n      if (block.timestamp < _releaseTime) revert CurrentTimeIsBeforeRelease();\r\n      uint256 balance = 0;\r\n\r\n      if (purchaseTokenAddress == address(0)) {\r\n          balance = address(this).balance;\r\n      } else {\r\n          balance = IERC20(purchaseTokenAddress).balanceOf(address(this));\r\n      }\r\n      if (balance == 0) revert NoPurchaseTokensToRelease();\r\n\r\n      if (_campaignSucceded && lpTokenPairAddress == address(0)) revert AddLiquidityNotCalledYet();\r\n\r\n      if (purchaseTokenAddress == address(0)) {\r\n          payable(getOwner()).transfer(address(this).balance);\r\n      } else {\r\n          IERC20(purchaseTokenAddress).safeTransfer(_owner, balance);\r\n      }\r\n    }\r\n    \r\n}"
    },
    "contracts/Lockers/PurchasedCoinVestingVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.26;\r\n\r\n\r\nimport \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\n\r\n\r\nerror MoreThanYears(uint noOfYears);\r\nerror DurationLessThanCliff();\r\nerror DailyVestedAmountLessThanZero();\r\nerror OnlyOwner();\r\nerror AmountVestedLessThanZero();\r\n/**\r\n* Locks liquidity for Purchased Coins in a vested style. using Cliffs\r\n* @dev \r\n*/\r\ncontract PurchasedCoinVestingVault is Initializable, ReentrancyGuard  {\r\n    using SafeERC20 for IERC20;\r\n\r\n    uint256 constant public SECONDS_PER_DAY = 86400;\r\n\r\n    struct Grant {\r\n        uint256 startTime;\r\n        uint256 amount;\r\n        uint256 vestingDuration;\r\n        uint256 vestingCliff;\r\n        uint256 daysClaimed;\r\n        uint256 totalClaimed;\r\n    }\r\n    address private _owner;\r\n    address public _deployer;\r\n\r\n    address private _coinOrTokenAddress;\r\n    \r\n    event GrantTokensClaimed(address indexed recipient, uint256 amountClaimed);\r\n    \r\n    \r\n    Grant public grant;\r\n\r\n    ///Do not leave an implementation contract uninitialized. An uninitialized implementation contract can be taken over by an attacker, which may impact the proxy. \r\n    /// To prevent the implementation contract from being used, you should invoke the _disableInitializers function in the constructor to automatically lock it when it is deployed\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n    \r\n\r\n    function initialize(address vaultOwner, \r\n        uint256 _startTime,\r\n        uint256 _amount,\r\n        uint256 _vestingDurationInDays,\r\n        uint256 _vestingCliffInDays,\r\n        address coinOrTokenAddress) public initializer {\r\n\r\n        _deployer=msg.sender;\r\n        _owner=vaultOwner;\r\n        _coinOrTokenAddress=coinOrTokenAddress;\r\n        require(_vestingCliffInDays <= 10*365, MoreThanYears(10) );\r\n        require(_vestingDurationInDays <= 25*365, MoreThanYears(25));\r\n        require(_vestingDurationInDays >= _vestingCliffInDays, DurationLessThanCliff());\r\n        \r\n        uint256 amountVestedPerDay = _amount/_vestingDurationInDays;\r\n        require(amountVestedPerDay > 0, DailyVestedAmountLessThanZero());\r\n\r\n        // Transfer the grant tokens under the control of the vesting contract\r\n        // require(token.transferFrom(owner(), address(this), _amount), \"transfer failed\");\r\n\r\n        grant = Grant({\r\n            startTime: _startTime == 0 ? currentTime() : _startTime,\r\n            amount: _amount,\r\n            vestingDuration: _vestingDurationInDays,\r\n            vestingCliff: _vestingCliffInDays,\r\n            daysClaimed: 0,\r\n            totalClaimed: 0\r\n        });\r\n        \r\n        \r\n    }\r\n\r\n    receive() external payable {\r\n\r\n    }\r\n    // or\r\n    function receiveTokens(uint256 amount) public payable {\r\n      IERC20(_coinOrTokenAddress).safeTransferFrom(msg.sender, address(this), amount);\r\n    }\r\n\r\n    function owner() public view returns (address) {\r\n        \r\n        return _owner;\r\n\r\n    }\r\n\r\n    function transferOwnership(address newOwner) public  {\r\n        \r\n        require(msg.sender== _owner, OnlyOwner());\r\n        _owner=newOwner;\r\n\r\n    }\r\n    \r\n\r\n    /// @notice Calculate the vested and unclaimed months and tokens available for `_grantId` to claim\r\n    /// Due to rounding errors once grant duration is reached, returns the entire left grant amount\r\n    /// Returns (0, 0) if cliff has not been reached\r\n    function calculateGrantClaim() public view returns (uint256, uint256) {\r\n        \r\n\r\n        // For grants created with a future start date, that hasn't been reached, return 0, 0\r\n        if (currentTime() < grant.startTime) {\r\n            return (0, 0);\r\n        }\r\n\r\n        // Check cliff was reached\r\n        uint elapsedTime = currentTime()-grant.startTime;\r\n        uint elapsedDays = elapsedTime/SECONDS_PER_DAY;\r\n        \r\n        if (elapsedDays < grant.vestingCliff) {\r\n            return (elapsedDays, 0);\r\n        }\r\n\r\n        // If over vesting duration, all tokens vested\r\n        if (elapsedDays >= grant.vestingDuration) {\r\n            uint256 remainingGrant = grant.amount-grant.totalClaimed;\r\n            return (grant.vestingDuration, remainingGrant);\r\n        } else {\r\n            uint256 daysVested = elapsedDays-grant.daysClaimed;\r\n            uint256 amountVestedPerDay = grant.amount/ grant.vestingDuration;\r\n            uint256 amountVested = daysVested*amountVestedPerDay;\r\n            return (daysVested, amountVested);\r\n        }\r\n    }\r\n\r\n    /// @notice Allows a grant recipient to claim their vested tokens. Errors if no tokens have vested\r\n    /// It is advised recipients check they are entitled to claim via `calculateGrantClaim` before calling this\r\n    function claimVestedCoins() external nonReentrant {\r\n        uint256 daysVested;\r\n        uint256 amountVested;\r\n        address recipient=owner();\r\n\r\n        (daysVested, amountVested) = calculateGrantClaim();\r\n        require(amountVested > 0, AmountVestedLessThanZero());\r\n\r\n        \r\n        grant.daysClaimed = grant.daysClaimed+ daysVested;\r\n        grant.totalClaimed = grant.totalClaimed + amountVested;\r\n        \r\n        // token.safeTransfer(recipient, amountVested);\r\n        if(_coinOrTokenAddress==address(0)){\r\n            payable(recipient).transfer(amountVested);\r\n        }else{            \r\n            IERC20(_coinOrTokenAddress).safeTransfer(recipient, amountVested); \r\n        }\r\n        \r\n        emit GrantTokensClaimed(recipient, amountVested);\r\n    }\r\n\r\n    function currentTime() private view returns(uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function tokensVestedPerDay() public view returns(uint256) {\r\n        \r\n        return grant.amount/ grant.vestingDuration;\r\n    }\r\n\r\n    \r\n\r\n}"
    },
    "contracts/Lockers/TokenLocker.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.18;\r\n\r\n\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"./VestSchedule.sol\";\r\n\r\n\r\n/**\r\n* Locks ERC20 Tokens in a vested style.\r\n* @dev Percentages are specified normally, e.g. 50% is 50\r\n*/\r\ncontract TokenLocker is ReentrancyGuard{\r\n\r\n    using SafeERC20 for IERC20;\r\n    // using SafeMath for uint256;\r\n    \r\n\r\n   \r\n    address private _owner;\r\n\r\n    address private _deployer;    \r\n\r\n    address private _token;\r\n    \r\n\r\n    uint _cycles ;\r\n\r\n    event TokenReleased(address indexed token, uint256 amount);\r\n    \r\n    VestSchedule[] public tokenVestSchedule ;\r\n\r\n    constructor( address tokenAddress, address owner, \r\n        uint totalTokens, uint firstReleasePercent, uint firstReleaseDays, uint subsequentReleasePercent, uint subsequentReleaseDays) {\r\n\r\n        // require(schedule.length <= 8, \"TokenLocker: Vesting cannot have more than 8 schedules\");\r\n        \r\n     \r\n        require(firstReleasePercent + subsequentReleasePercent <= 100, \"Invalid%\");\r\n\r\n        _deployer = msg.sender;\r\n        \r\n        _owner = owner;\r\n        _token = tokenAddress;\r\n\r\n        // 50, 25\r\n        //30, 30\r\n        // 30, 35\r\n        uint subsequentCycles = (100 -  firstReleasePercent)/ subsequentReleasePercent; \r\n        bool hasExtraCycle = 100 -  firstReleasePercent  - (subsequentCycles * subsequentReleasePercent) > 0; \r\n        uint cycles = 1 +  subsequentCycles + ( hasExtraCycle? 1: 0 );\r\n\r\n        _cycles = cycles;\r\n\r\n        // tokenVestSchedule = new VestSchedule[](cycles);\r\n\r\n        // tokenVestSchedule[0] = VestSchedule({\r\n        //     releaseDate: block.timestamp + (firstReleaseDays * 1 days),\r\n        //     releaseAmount: firstReleasePercent * totalTokens * 10000/1000000,\r\n        //     hasBeenClaimed: false\r\n        // });\r\n\r\n\r\n        // for (uint i=0; i < subsequentCycles ; i++) {\r\n        //     //first index is firstRelease\r\n        //     tokenVestSchedule[i+1] = VestSchedule({\r\n        //         releaseDate: tokenVestSchedule[0].releaseDate + ((i+1) * subsequentReleaseDays * 1 days),\r\n        //         releaseAmount: subsequentReleasePercent * totalTokens * 10000/1000000,\r\n        //         hasBeenClaimed: false\r\n        //     });\r\n        // }\r\n\r\n        // //any extra \r\n        // if(hasExtraCycle){\r\n        //     // extra cycle will account for frist cycle and the subsequentscyels hence s + 1\r\n        //     tokenVestSchedule[subsequentCycles + 1] = VestSchedule({\r\n        //         releaseDate: tokenVestSchedule[subsequentCycles].releaseDate + ( subsequentReleaseDays * 1 days), // add days to last vesting day\r\n        //         releaseAmount: (100 -  firstReleasePercent  - (subsequentCycles * subsequentReleasePercent)) * totalTokens * 10000/1000000,\r\n        //         hasBeenClaimed: false\r\n        //     });\r\n        // }\r\n\r\n\r\n        \r\n\r\n        tokenVestSchedule.push( VestSchedule({\r\n            releaseDate: block.timestamp + (firstReleaseDays * 1 days),\r\n            releaseAmount: firstReleasePercent * totalTokens * 10000/1000000,\r\n            hasBeenClaimed: false\r\n        }) );\r\n\r\n\r\n        for (uint i=0; i < subsequentCycles ; i++) {\r\n            //first index is firstRelease\r\n            tokenVestSchedule.push( VestSchedule({\r\n                releaseDate: tokenVestSchedule[0].releaseDate + ((i+1) * subsequentReleaseDays * 1 days),\r\n                releaseAmount: subsequentReleasePercent * totalTokens * 10000/1000000,\r\n                hasBeenClaimed: false\r\n            }) );\r\n        }\r\n\r\n        //any extra \r\n        if(hasExtraCycle){\r\n            // extra cycle will account for frist cycle and the subsequentscyels hence s + 1\r\n            tokenVestSchedule.push( VestSchedule({\r\n                releaseDate: tokenVestSchedule[subsequentCycles].releaseDate + ( subsequentReleaseDays * 1 days), // add days to last vesting day\r\n                releaseAmount: (100 -  firstReleasePercent  - (subsequentCycles * subsequentReleasePercent)) * totalTokens * 10000/1000000,\r\n                hasBeenClaimed: false\r\n            }) );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the owner of the locked funds\r\n     */\r\n    function getOwner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n\r\n    function getVestingCycle() public view returns (VestSchedule[] memory schedule) {\r\n\r\n        schedule = new VestSchedule[](_cycles);\r\n\r\n        for (uint i=0; i < _cycles ; i++) {\r\n            \r\n            schedule[i]= tokenVestSchedule[i];\r\n        }\r\n        return schedule;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @notice Transfers tokens held by Lock to owner.\r\n       @dev Able to withdraw tokens after release time \r\n     */\r\n    function release() public nonReentrant {\r\n        uint256 amountToReleaseThisTime =0;\r\n        uint i;\r\n        for (i=0; i < _cycles; i++) { \r\n            if(block.timestamp >= tokenVestSchedule[i].releaseDate && !tokenVestSchedule[i].hasBeenClaimed ) {\r\n                amountToReleaseThisTime += tokenVestSchedule[i].releaseAmount;\r\n                tokenVestSchedule[i].hasBeenClaimed = true;\r\n            }            \r\n        }\r\n        \r\n        uint256 balance = IERC20(_token).balanceOf(address(this));\r\n        //require(balance > 0, \"TokenLocker: no tokens to release\");\r\n        require(balance >= amountToReleaseThisTime, \"TokenLocker: not enough tokens to release\");\r\n\r\n        IERC20(_token).safeTransfer(_owner, amountToReleaseThisTime);\r\n\r\n        emit TokenReleased(_token, amountToReleaseThisTime); \r\n    }\r\n\r\n\r\n    /**\r\n     * @notice Transfers any ETH back to the owner, ETH is not locked\r\n       @dev Function used to transfer eth mistakenly sent here\r\n     */\r\n    function withdrawETH() public {\r\n        require(address(this).balance > 0, \"TokenLocker: no Eth to release\");\r\n\r\n        payable(getOwner()).transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers any unrecognised token back to the owner, \r\n       @dev Function used to transfer Tokens mistakenly sent here\r\n     */\r\n    function withdrawToken(address tokenToSend) public {\r\n        require(_token!=tokenToSend, \"TokenLocker:Token meant for lock\");\r\n        require(IERC20(tokenToSend).balanceOf(address(this)) > 0, \"TokenLocker: no Token to release\");\r\n\r\n        IERC20(tokenToSend).safeTransfer(getOwner(), IERC20(tokenToSend).balanceOf(address(this))); \r\n        \r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the amount of releasable token tokens. token should be the address of an IERC20 contract.\r\n     */\r\n    function released() public view returns (uint ){\r\n        uint256 amount=0;\r\n        uint i;\r\n        for (i=0; i < _cycles; i++) { \r\n            if(tokenVestSchedule[i].hasBeenClaimed ) {\r\n                amount += tokenVestSchedule[i].releaseAmount;\r\n            }            \r\n        }\r\n        return amount;\r\n    }\r\n\r\n    /**\r\n     * @notice Getter for the amount of releasable token tokens. token should be the address of an IERC20 contract.\r\n     */\r\n    function releasable() public view returns (uint ){\r\n        uint256 amount=0;\r\n        uint i;\r\n        for (i=0; i < _cycles; i++) { \r\n            if( block.timestamp >= tokenVestSchedule[i].releaseDate && !tokenVestSchedule[i].hasBeenClaimed) {\r\n                amount += tokenVestSchedule[i].releaseAmount;\r\n            }            \r\n        }\r\n        return amount;\r\n    }\r\n}"
    },
    "contracts/Lockers/TokenLockerOld.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.8;\r\n\r\n\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n\r\nimport \"./VestSchedule.sol\";\r\n\r\n\r\n/**\r\n* Locks ERC20 Tokens in a vested style.\r\n* @dev Percentages are specified in hundreds, e.g. 50% is 5000\r\n*/\r\ncontract TokenLockerOld{\r\n\r\n    using SafeERC20 for IERC20;\r\n    // using SafeMath for uint256;\r\n    \r\n\r\n   \r\n    address private _owner;\r\n\r\n    address private _deployer;    \r\n\r\n    address private _token;\r\n    \r\n\r\n    \r\n    \r\n    VestSchedule[8] public tokenVestSchedule ;\r\n\r\n    constructor( address tokenAddress, address owner, VestSchedule[8] memory schedule) {\r\n\r\n        // require(schedule.length <= 8, \"TokenLocker: Vesting cannot have more than 8 schedules\");\r\n        \r\n        _deployer = msg.sender;\r\n        \r\n        _owner = owner;\r\n        _token = tokenAddress;\r\n\r\n        for (uint8 i=0; i < 8 /*100%*/; i++) {\r\n            schedule[i].hasBeenClaimed=false;\r\n            // tokenVestSchedule.push(schedule[i]);\r\n            tokenVestSchedule[i]=schedule[i];\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @return the owner of the locked funds\r\n     */\r\n    function getOwner() public view returns (address) {\r\n        return _owner;\r\n    }\r\n    \r\n    \r\n    /**\r\n     * @notice Transfers tokens held by Lock to owner.\r\n       @dev Able to withdraw tokens after release time \r\n     */\r\n    function release() public {\r\n        uint256 amountToReleaseThisTime =0;\r\n        uint i;\r\n        for (i=0; i <= 8; i++) { \r\n            if(block.timestamp >= tokenVestSchedule[i].releaseDate && !tokenVestSchedule[i].hasBeenClaimed ) {\r\n                amountToReleaseThisTime += tokenVestSchedule[i].releaseAmount;\r\n                tokenVestSchedule[i].hasBeenClaimed = true;\r\n            }            \r\n        }\r\n        \r\n        uint256 balance = IERC20(_token).balanceOf(address(this));\r\n        require(balance > 0, \"TokenLocker: no tokens to release\");\r\n        require(balance >= amountToReleaseThisTime, \"TokenLocker: not enough tokens to release\");\r\n\r\n        IERC20(_token).safeTransfer(_owner, amountToReleaseThisTime); \r\n    }\r\n\r\n    /**\r\n     * @notice Transfers any ETH back to the owner, ETH is not locked\r\n       @dev Function used to transfer eth mistakenly sent here\r\n     */\r\n    function releaseETH() public {\r\n        require(address(this).balance > 0, \"TokenLocker: no Eth to release\");\r\n\r\n        payable(getOwner()).transfer(address(this).balance);\r\n    }\r\n\r\n    /**\r\n     * @notice Transfers any unrecognised token back to the owner, \r\n       @dev Function used to transfer Tokens mistakenly sent here\r\n     */\r\n    function releaseToken(address tokenToSend) public {\r\n        require(_token!=tokenToSend, \"TokenLocker: cannot transfre token meant for lock\");\r\n        require(IERC20(tokenToSend).balanceOf(address(this)) > 0, \"TokenLocker: no Token to release\");\r\n\r\n        IERC20(tokenToSend).safeTransfer(getOwner(), IERC20(tokenToSend).balanceOf(address(this))); \r\n        \r\n    }\r\n}"
    },
    "contracts/Lockers/VestSchedule.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nstruct VestSchedule{\r\n    uint256 releaseDate;\r\n    uint256 releaseAmount;\r\n    bool hasBeenClaimed;\r\n}"
    },
    "contracts/Migrations.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity >=0.4.22 <0.9.0;\r\n\r\ncontract Migration {\r\n  address public owner = msg.sender;\r\n  uint public last_completed_migration;\r\n\r\n  modifier restricted() {\r\n    require(\r\n      msg.sender == owner,\r\n      \"This function is restricted to the contract's owner\"\r\n    );\r\n    _;\r\n  }\r\n\r\n  function setCompleted(uint completed) public restricted {\r\n    last_completed_migration = completed;\r\n  }\r\n}"
    },
    "contracts/NFTToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\nimport './Interfaces/Turnstile.sol';\r\n\r\ncontract NFTToken is ERC721, ERC721URIStorage, Ownable {\r\n    \r\n\r\n    uint private _tokenIdCounter;\r\n\r\n    address public turnstileAddress = address(0);\r\n    Turnstile private turnstile;\r\n\r\n    constructor() ERC721(\"ZSales NFT\", \"ZSX\") Ownable(msg.sender) {}\r\n\r\n    function _baseURI() internal pure override returns (string memory) {\r\n        return \"https://zsales.xyz/nft/\";\r\n    }\r\n\r\n    function safeMint(address to, string memory uri) public onlyOwner {\r\n        uint256 tokenId = _tokenIdCounter;\r\n        _tokenIdCounter++;\r\n        _safeMint(to, tokenId);\r\n        _setTokenURI(tokenId, uri);\r\n    }\r\n\r\n    function updateTurnstileAddress(address newAddress) public onlyOwner{\r\n        \r\n        turnstileAddress=newAddress;\r\n        turnstile = Turnstile(turnstileAddress);\r\n        //Registers the smart contract with Turnstile\r\n        //Mints the CSR NFT to the contract creator\r\n        turnstile.register(tx.origin);\r\n\r\n    }\r\n\r\n    // The following functions are overrides required by Solidity.\r\n\r\n\r\n    function tokenURI(uint256 tokenId)\r\n        public\r\n        view\r\n        override(ERC721, ERC721URIStorage)\r\n        returns (string memory)\r\n    {\r\n        return super.tokenURI(tokenId);\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId) public view override(ERC721, ERC721URIStorage) returns (bool) {\r\n\t\treturn super.supportsInterface(interfaceId);\r\n\t}\r\n}"
    },
    "contracts/Pads/Fairlaunch.sol": {
      "content": "// // SPDX-License-Identifier: MIT\r\n\r\n// pragma solidity ^0.8.20;\r\n\r\n\r\n\r\n\r\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n// // import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\n// import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n\r\n\r\n// library SafeMath {\r\n//     /**\r\n//      * @dev Returns the addition of two unsigned integers, reverting on\r\n//      * overflow.\r\n//      *\r\n//      * Counterpart to Solidity's `+` operator.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - Addition cannot overflow.\r\n//      */\r\n//     function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         uint256 c = a + b;\r\n//         require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n//         return c;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the subtraction of two unsigned integers, reverting on\r\n//      * overflow (when the result is negative).\r\n//      *\r\n//      * Counterpart to Solidity's `-` operator.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - Subtraction cannot overflow.\r\n//      */\r\n//     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         return sub(a, b, \"SafeMath: subtraction overflow\");\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n//      * overflow (when the result is negative).\r\n//      *\r\n//      * Counterpart to Solidity's `-` operator.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - Subtraction cannot overflow.\r\n//      */\r\n//     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n//         require(b <= a, errorMessage);\r\n//         uint256 c = a - b;\r\n\r\n//         return c;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the multiplication of two unsigned integers, reverting on\r\n//      * overflow.\r\n//      *\r\n//      * Counterpart to Solidity's `*` operator.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - Multiplication cannot overflow.\r\n//      */\r\n//     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n//         // benefit is lost if 'b' is also tested.\r\n//         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n//         if (a == 0) {\r\n//             return 0;\r\n//         }\r\n\r\n//         uint256 c = a * b;\r\n//         require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n//         return c;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the integer division of two unsigned integers. Reverts on\r\n//      * division by zero. The result is rounded towards zero.\r\n//      *\r\n//      * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n//      * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n//      * uses an invalid opcode to revert (consuming all remaining gas).\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - The divisor cannot be zero.\r\n//      */\r\n//     function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         return div(a, b, \"SafeMath: division by zero.\");\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n//      * division by zero. The result is rounded towards zero.\r\n//      *\r\n//      * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n//      * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n//      * uses an invalid opcode to revert (consuming all remaining gas).\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - The divisor cannot be zero.\r\n//      */\r\n//     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n//         require(b > 0, errorMessage);\r\n//         uint256 c = a / b;\r\n//         // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n//         return c;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n//      * Reverts when dividing by zero.\r\n//      *\r\n//      * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n//      * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n//      * invalid opcode to revert (consuming all remaining gas).\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - The divisor cannot be zero.\r\n//      */\r\n//     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         return mod(a, b, \"SafeMath: modulo by zero\");\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n//      * Reverts with custom message when dividing by zero.\r\n//      *\r\n//      * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n//      * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n//      * invalid opcode to revert (consuming all remaining gas).\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - The divisor cannot be zero.\r\n//      */\r\n//     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n//         require(b != 0, errorMessage);\r\n//         return a % b;\r\n//     }\r\n// }\r\n\r\n// library TransferHelper {\r\n//     function safeApprove(address token, address to, uint value) internal {\r\n//         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n//         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n//     }\r\n\r\n//     function safeTransfer(address token, address to, uint value) internal {\r\n//         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n//         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n//     }\r\n\r\n//     function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n//         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n//         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n//     }\r\n    \r\n//     // sends ETH or an erc20 token\r\n//     function safeTransferBaseToken(address token, address payable to, uint value, bool isERC20) internal {\r\n//         if (!isERC20) {\r\n//             to.transfer(value);\r\n//         } else {\r\n//             (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n//             require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n//         }\r\n//     }\r\n// }\r\n\r\n\r\n// // interface IBEP20 {\r\n// //     event Approval(address indexed owner, address indexed spender, uint value);\r\n// //     event Transfer(address indexed from, address indexed to, uint value);\r\n    \r\n// //     function decimals() external view returns (uint8);\r\n// //     function name() external view returns (string memory);\r\n// //     function symbol() external view returns (string memory);\r\n// //     function totalSupply() external view returns (uint);\r\n// //     function balanceOf(address owner) external view returns (uint);\r\n// //     function allowance(address owner, address spender) external view returns (uint);\r\n\r\n// //     function approve(address spender, uint value) external returns (bool);\r\n// //     function transfer(address to, uint value) external returns (bool);\r\n// //     function transferFrom(address from, address to, uint value) external returns (bool);\r\n// // }\r\n\r\n// interface IPancakeSwapRouter{\r\n// \t\tfunction factory() external pure returns (address);\r\n// \t\tfunction WETH() external pure returns (address);\r\n\r\n// \t\tfunction addLiquidity(\r\n// \t\t\t\taddress tokenA,\r\n// \t\t\t\taddress tokenB,\r\n// \t\t\t\tuint amountADesired,\r\n// \t\t\t\tuint amountBDesired,\r\n// \t\t\t\tuint amountAMin,\r\n// \t\t\t\tuint amountBMin,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline\r\n// \t\t) external returns (uint amountA, uint amountB, uint liquidity);\r\n// \t\tfunction addLiquidityETH(\r\n// \t\t\t\taddress token,\r\n// \t\t\t\tuint amountTokenDesired,\r\n// \t\t\t\tuint amountTokenMin,\r\n// \t\t\t\tuint amountETHMin,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline\r\n// \t\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n// \t\tfunction removeLiquidity(\r\n// \t\t\t\taddress tokenA,\r\n// \t\t\t\taddress tokenB,\r\n// \t\t\t\tuint liquidity,\r\n// \t\t\t\tuint amountAMin,\r\n// \t\t\t\tuint amountBMin,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline\r\n// \t\t) external returns (uint amountA, uint amountB);\r\n// \t\tfunction removeLiquidityETH(\r\n// \t\t\t\taddress token,\r\n// \t\t\t\tuint liquidity,\r\n// \t\t\t\tuint amountTokenMin,\r\n// \t\t\t\tuint amountETHMin,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline\r\n// \t\t) external returns (uint amountToken, uint amountETH);\r\n// \t\tfunction removeLiquidityWithPermit(\r\n// \t\t\t\taddress tokenA,\r\n// \t\t\t\taddress tokenB,\r\n// \t\t\t\tuint liquidity,\r\n// \t\t\t\tuint amountAMin,\r\n// \t\t\t\tuint amountBMin,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline,\r\n// \t\t\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n// \t\t) external returns (uint amountA, uint amountB);\r\n// \t\tfunction removeLiquidityETHWithPermit(\r\n// \t\t\t\taddress token,\r\n// \t\t\t\tuint liquidity,\r\n// \t\t\t\tuint amountTokenMin,\r\n// \t\t\t\tuint amountETHMin,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline,\r\n// \t\t\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n// \t\t) external returns (uint amountToken, uint amountETH);\r\n// \t\tfunction swapExactTokensForTokens(\r\n// \t\t\t\tuint amountIn,\r\n// \t\t\t\tuint amountOutMin,\r\n// \t\t\t\taddress[] calldata path,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline\r\n// \t\t) external returns (uint[] memory amounts);\r\n// \t\tfunction swapTokensForExactTokens(\r\n// \t\t\t\tuint amountOut,\r\n// \t\t\t\tuint amountInMax,\r\n// \t\t\t\taddress[] calldata path,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline\r\n// \t\t) external returns (uint[] memory amounts);\r\n// \t\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n// \t\t\t\texternal\r\n// \t\t\t\tpayable\r\n// \t\t\t\treturns (uint[] memory amounts);\r\n// \t\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n// \t\t\t\texternal\r\n// \t\t\t\treturns (uint[] memory amounts);\r\n// \t\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n// \t\t\t\texternal\r\n// \t\t\t\treturns (uint[] memory amounts);\r\n// \t\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n// \t\t\t\texternal\r\n// \t\t\t\tpayable\r\n// \t\t\t\treturns (uint[] memory amounts);\r\n\r\n// \t\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n// \t\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n// \t\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n// \t\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n// \t\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n// \t\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\r\n// \t\t\taddress token,\r\n// \t\t\tuint liquidity,\r\n// \t\t\tuint amountTokenMin,\r\n// \t\t\tuint amountETHMin,\r\n// \t\t\taddress to,\r\n// \t\t\tuint deadline\r\n// \t\t) external returns (uint amountETH);\r\n// \t\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n// \t\t\taddress token,\r\n// \t\t\tuint liquidity,\r\n// \t\t\tuint amountTokenMin,\r\n// \t\t\tuint amountETHMin,\r\n// \t\t\taddress to,\r\n// \t\t\tuint deadline,\r\n// \t\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n// \t\t) external returns (uint amountETH);\r\n\t\r\n// \t\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n// \t\t\tuint amountIn,\r\n// \t\t\tuint amountOutMin,\r\n// \t\t\taddress[] calldata path,\r\n// \t\t\taddress to,\r\n// \t\t\tuint deadline\r\n// \t\t) external;\r\n// \t\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n// \t\t\tuint amountOutMin,\r\n// \t\t\taddress[] calldata path,\r\n// \t\t\taddress to,\r\n// \t\t\tuint deadline\r\n// \t\t) external payable;\r\n// \t\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n// \t\t\tuint amountIn,\r\n// \t\t\tuint amountOutMin,\r\n// \t\t\taddress[] calldata path,\r\n// \t\t\taddress to,\r\n// \t\t\tuint deadline\r\n// \t\t) external;\r\n// }\r\n\r\n// interface IPancakeSwapFactory {\r\n// \t\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n// \t\tfunction feeTo() external view returns (address);\r\n// \t\tfunction feeToSetter() external view returns (address);\r\n\r\n// \t\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\r\n// \t\tfunction allPairs(uint) external view returns (address pair);\r\n// \t\tfunction allPairsLength() external view returns (uint);\r\n\r\n// \t\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n// \t\tfunction setFeeTo(address) external;\r\n// \t\tfunction setFeeToSetter(address) external;\r\n// }\r\n\r\n// // interface IMyContract {\r\n// //     function getProfit() external view returns(address);\r\n// //     function getPercent() external view returns (uint256);\r\n// // }\r\n\r\n// contract Fairlaunch is ReentrancyGuard {\r\n//     using SafeMath for uint256;\r\n//     using SafeERC20 for IERC20;\r\n\r\n//     struct PresaleInfo {\r\n//         address sale_token; // Token to be sold. Sale token\r\n//         address base_token;\r\n//         uint256 buyback;\r\n//         bool whitelist;\r\n//         uint256 selling_amount;\r\n//         uint256 raise_min; // Maximum base token BUY amount per buyer\r\n//         uint256 softcap; // Minimum raise amount\r\n//         uint256 liquidityPercent;\r\n//         uint256 presale_start;\r\n//         uint256 presale_end;\r\n//         PresaleType presale_type;\r\n//     }\r\n\r\n//     struct MetaInfo {\r\n//         bool presale_in_native;\r\n//         uint256 base_token_fee; // base token fee after finalize\r\n//         uint256 sale_token_fee; // sale token fee after finalize\r\n//         bool canceled;\r\n//         uint256 referral_fee;\r\n//         address referral_address;\r\n//     }\r\n    \r\n//     bool finalized;\r\n//     uint256 raised_amount;\r\n//     uint256 public referral_fee;\r\n//     address public referral_address;\r\n//     bool public whiteList;\r\n\r\n//     address public adminAddress;\r\n    \r\n//     struct TokenInfo {\r\n//         string name;\r\n//         string symbol;\r\n//         uint256 totalsupply;\r\n//         uint256 decimal;\r\n//     }\r\n\r\n//     modifier IsWhitelisted() {\r\n//         require(presale_info.presale_type == PresaleType.WHITELIST, \"whitelist not set\");\r\n//         _;\r\n//     }\r\n\r\n//     enum PresaleType { PUBLIC, WHITELIST }\r\n\r\n//     address owner;\r\n//     bool persaleSetting;\r\n\r\n//     PresaleInfo public presale_info;\r\n//     TokenInfo public tokeninfo;\r\n//     MetaInfo public meta_info;\r\n\r\n//     IPancakeSwapRouter public router;\r\n//     // IMyContract public profit;\r\n//     // address private profitAddress=0x800E6AaC8f0DCbd8E809ADD117898C59b90cc445;\r\n\r\n//     mapping(address => uint256) public buyers;\r\n//     mapping(address => bool) public whitelistInfo;\r\n//     mapping(address => bool) public flokiBurnerInfo;\r\n\r\n//     event PresaleCreated(address owner, address campaignAddress);\r\n//     event UserDepsitedSuccess(address user, uint256 amount);\r\n//     event UserWithdrawSuccess(uint256 amount);\r\n//     event UserWithdrawTokensSuccess(uint256 amount);\r\n\r\n//     address deadaddr = 0x000000000000000000000000000000000000dEaD;\r\n//     uint256 public lock_delay;\r\n\r\n//     modifier onlyOwner() {\r\n//         require(owner == msg.sender, \"Not presale owner.\");\r\n//         _;\r\n//     }\r\n\r\n//     constructor(\r\n//         address owner_,\r\n//         address _sale_token,\r\n//         address _base_token,\r\n//         bool presale_in_native,\r\n//         uint256 _buyback,\r\n//         bool _whitelist,\r\n//         uint256 _selling_amount,\r\n//         uint256 _softcap, \r\n//         uint256 _liquidityPercent,\r\n//         uint256 _presale_start,\r\n//         uint256 _presale_end,\r\n\r\n//         address _adminAddress,\r\n//         address _routerAddress\r\n//     ) {\r\n//         owner = msg.sender;\r\n//         adminAddress=_adminAddress;\r\n//         init_private(\r\n//             _sale_token,\r\n//             _base_token,\r\n//             presale_in_native,\r\n//             _buyback,\r\n//             _whitelist,\r\n//             _selling_amount,\r\n//             _softcap, \r\n//             _liquidityPercent,\r\n//             _presale_start,\r\n//             _presale_end,\r\n//             _routerAddress\r\n//         );\r\n//         owner = owner_;\r\n        \r\n//         emit PresaleCreated(owner, address(this));\r\n//     }\r\n\r\n//     function init_private (\r\n//         address _sale_token,\r\n//         address _base_token,\r\n//         bool presale_in_native,\r\n//         uint256 _buyback,\r\n//         bool _whitelist,\r\n//         uint256 _selling_amount,\r\n//         uint256 _softcap, \r\n//         uint256 _liquidityPercent,\r\n//         uint256 _presale_start,\r\n//         uint256 _presale_end,\r\n//         address _routerAddress\r\n//         ) public onlyOwner {\r\n\r\n//         require(persaleSetting == false, \"Already setted\");\r\n//         require(_sale_token != address(0), \"Zero Address\");\r\n        \r\n//         presale_info.sale_token = _sale_token;\r\n//         presale_info.base_token = _base_token;\r\n//         presale_info.buyback = _buyback;\r\n//         presale_info.whitelist = _whitelist;\r\n//         meta_info.presale_in_native = presale_in_native;\r\n//         presale_info.selling_amount = _selling_amount;\r\n//         presale_info.softcap = _softcap;\r\n//         presale_info.liquidityPercent = _liquidityPercent;\r\n\r\n//         presale_info.presale_end = _presale_end;\r\n//         presale_info.presale_start =  _presale_start;\r\n//         meta_info.presale_in_native = false;\r\n//         finalized = false;\r\n//         if(_whitelist == true) {\r\n//             presale_info.presale_type = PresaleType.WHITELIST;\r\n//         } else {\r\n//             presale_info.presale_type = PresaleType.PUBLIC;\r\n//         }\r\n\r\n//         //Set token token info\r\n//         tokeninfo.name = IERC20Metadata(presale_info.sale_token).name();\r\n//         tokeninfo.symbol = IERC20Metadata(presale_info.sale_token).symbol();\r\n//         tokeninfo.decimal = IERC20Metadata(presale_info.sale_token).decimals();\r\n//         tokeninfo.totalsupply = IERC20Metadata(presale_info.sale_token).totalSupply();\r\n//         router = IPancakeSwapRouter(_routerAddress); \r\n//         // profit = IMyContract(profitAddress);\r\n        \r\n//         persaleSetting = true;\r\n//     }\r\n\r\n//     function setOwner(address _newOwner) public onlyOwner {\r\n//         owner = _newOwner;\r\n//     }\r\n\r\n//     function presaleStatus() public view returns (uint256) {\r\n//         if(finalized == true) {\r\n//             return 5; // Finalized\r\n//         }\r\n//         if(meta_info.presale_in_native == true) {\r\n//             return 4; // Canceled\r\n//         }\r\n//         if ((block.timestamp > presale_info.presale_end) && (raised_amount < presale_info.softcap)) {\r\n//             return 3; // Failure\r\n//         }\r\n//         // if (status.raised_amount >= presale_info.hardcap) {\r\n//         //     return 2; // Wonderful - reached to Hardcap\r\n//         // }\r\n//         if ((block.timestamp > presale_info.presale_end) && (raised_amount >= presale_info.softcap)) {\r\n//             return 2; // SUCCESS - Presale ended with reaching Softcap\r\n//         }\r\n//         if ((block.timestamp >= presale_info.presale_start) && (block.timestamp <= presale_info.presale_end)) {\r\n//             return 1; // ACTIVE - Deposits enabled, now in Presale\r\n//         }\r\n//             return 0; // QUED - Awaiting start block\r\n//     }\r\n    \r\n//     // Accepts msg.value for eth or _amount for ERC20 tokens\r\n//     function userDeposit (uint256 _amount) public payable nonReentrant {\r\n//         if(presale_info.presale_type == PresaleType.WHITELIST) {\r\n//             require(whitelistInfo[msg.sender] == true, \"You are not whitelisted.\");\r\n//         } \r\n//         require(presaleStatus() == 1, \"NotActive\");\r\n//         // require(presale_info.raise_min <= msg.value, \"Balance is insufficent\");\r\n//         if (meta_info.presale_in_native) {\r\n//             require(msg.value > 0, \"INVBalance\");\r\n//         } else {\r\n//             require(_amount > 0, \"INVBalance\");\r\n//         }\r\n\r\n//         uint256 amount_in = meta_info.presale_in_native ? msg.value : _amount;\r\n//         buyers[msg.sender] = buyers[msg.sender].add(amount_in);\r\n//         raised_amount = raised_amount.add(amount_in);\r\n        \r\n//         if (!meta_info.presale_in_native) {\r\n//             TransferHelper.safeTransferFrom(address(presale_info.base_token), msg.sender, address(this), amount_in);\r\n//         }\r\n//         emit UserDepsitedSuccess(msg.sender, msg.value);\r\n//     }\r\n    \r\n//     // Buyers withdraw presale tokens\r\n//     // percentile withdrawls allows fee on transfer or rebasing tokens to still work\r\n//     function userWithdrawTokens () public nonReentrant {\r\n//         require(presaleStatus() == 2, \"Not succeeded\"); // Success\r\n//         require(block.timestamp >= presale_info.presale_end + lock_delay, \"Token Locked.\"); // Lock duration check\r\n//         uint256 value = calcSendTokens(msg.sender);\r\n        \r\n//         TransferHelper.safeTransfer(address(presale_info.sale_token), msg.sender, value);\r\n\r\n//         buyers[msg.sender] = 0;\r\n//         emit UserWithdrawTokensSuccess(value);\r\n//     }\r\n    \r\n//     // On presale failure\r\n//     // Percentile withdrawls allows fee on transfer or rebasing tokens to still work\r\n//     function userWithdrawBaseTokens () public nonReentrant {\r\n//         require(presaleStatus() == 3 || presaleStatus() == 4, \"NotFailedOrCanceled.\"); // FAILED\r\n//         uint256 value = buyers[msg.sender];\r\n//         address payable receiver = payable(msg.sender);\r\n\r\n//         TransferHelper.safeTransferBaseToken(presale_info.base_token, receiver, value, meta_info.presale_in_native);\r\n//         // receiver.transfer(value);\r\n\r\n//         // TransferHelper.safeTransferBaseToken(address(presale_info.sale_token), payable(msg.sender), value, false);\r\n//         buyers[msg.sender] = 0;\r\n//         emit UserWithdrawSuccess(value);\r\n//     }\r\n    \r\n//     // On presale failure\r\n//     function ownerWithdrawTokens () private onlyOwner {\r\n//         require(presaleStatus() == 3 || presaleStatus() == 4, \"NotFailedOrCanceled.\"); // FAILED\r\n//         TransferHelper.safeTransfer(address(presale_info.sale_token), owner, IERC20(presale_info.sale_token).balanceOf(address(this)));\r\n        \r\n//         emit UserWithdrawSuccess(IERC20(presale_info.sale_token).balanceOf(address(this)));\r\n//     }\r\n\r\n//     function purchaseICOCoin (address to) public nonReentrant onlyOwner {\r\n//         require(presaleStatus() == 2, \"Not succeeded\"); // Success\r\n        \r\n//         address payable reciver = payable(to);\r\n//         // uint256 percent = profit.getPercent();\r\n//         // address addr = profit.getProfit();\r\n//         // uint256 supply = address(this).balance;\r\n//         // payable(addr).transfer(supply.mul(percent).div(100));\r\n//         // approveTokens();\r\n\r\n//         // get profit of base token\r\n//         uint256 _raised_amount = raised_amount;\r\n//         if (meta_info.base_token_fee > 0) {\r\n//             uint256 basefee = _raised_amount.mul(meta_info.base_token_fee).div(100);\r\n//             _raised_amount.sub(basefee);\r\n//             if (meta_info.referral_address != address(0)) {\r\n//                 uint256 referralfee = basefee.mul(meta_info.referral_fee).div(100);\r\n//                 if (meta_info.presale_in_native) {\r\n//                     payable(meta_info.referral_address).transfer(referralfee);\r\n//                 } else {\r\n//                     TransferHelper.safeTransferBaseToken(presale_info.base_token, payable(meta_info.referral_address), referralfee, meta_info.presale_in_native);\r\n//                 }    \r\n//                 basefee.sub(referralfee);\r\n//             }\r\n//             if (meta_info.presale_in_native) {\r\n//                 payable(adminAddress).transfer(basefee);\r\n//             } else {\r\n//                 TransferHelper.safeTransferBaseToken(presale_info.base_token, payable(address(this)), basefee, meta_info.presale_in_native);\r\n//             }\r\n//         }\r\n//         // get profit of sale token\r\n//         if (meta_info.sale_token_fee > 0) {\r\n//             uint256 sold_amount = calcRate() * raised_amount / 10 ** (18 - tokeninfo.decimal);\r\n//             uint256 salefee = sold_amount.mul(meta_info.sale_token_fee).div(100);\r\n//             if (meta_info.referral_address != address(0)) {\r\n//                 uint256 referralfee = salefee.mul(meta_info.referral_fee).div(100);\r\n//                 TransferHelper.safeTransfer(presale_info.sale_token, msg.sender, salefee);\r\n//                 salefee.sub(referralfee);\r\n//             }\r\n//             TransferHelper.safeTransfer(presale_info.sale_token, meta_info.referral_address, salefee);\r\n//         }\r\n\r\n//         uint256 supply = meta_info.presale_in_native ? address(this).balance : IERC20(presale_info.base_token).balanceOf(address(this));\r\n//         uint256 liquiditySupply = supply * presale_info.liquidityPercent / 100;\r\n//         uint256 value = calcRate();\r\n//         uint256 tokenLiquidity = liquiditySupply *  value / (10 ** (18 - tokeninfo.decimal)); \r\n//         require(IERC20(presale_info.sale_token).balanceOf(address(this)) >= tokenLiquidity, \"insufficient tokens\");\r\n//         IERC20(presale_info.sale_token).approve(address(router), tokenLiquidity);\r\n//         // require(success == true, 'Approve failed');\r\n//         if (meta_info.presale_in_native) {\r\n//             router.addLiquidityETH{value: liquiditySupply}(\r\n//                 presale_info.sale_token,\r\n//                 tokenLiquidity,\r\n//                 0,\r\n//                 0,\r\n//                 reciver,\r\n//                 block.timestamp\r\n//             ); \r\n//         } else {\r\n//             bool success_ = IERC20(presale_info.base_token).approve(address(router), liquiditySupply);\r\n//             require(success_ == true, 'BaseToken ApproveFailed');\r\n//             router.addLiquidity(\r\n//                 presale_info.base_token, \r\n//                 presale_info.sale_token, \r\n//                 liquiditySupply, \r\n//                 tokenLiquidity, \r\n//                 0, \r\n//                 0, \r\n//                 reciver, \r\n//                 block.timestamp);\r\n//         }\r\n\r\n//         supply = supply.sub(liquiditySupply);\r\n//         TransferHelper.safeTransferBaseToken(presale_info.base_token, reciver, supply, meta_info.presale_in_native);\r\n//         finalized = true;\r\n//     }\r\n\r\n//     function getTimestamp () public view returns (uint256) {\r\n//         return block.timestamp;\r\n//     }\r\n\r\n//     function setLockDelay (uint256 delay) public onlyOwner {\r\n//         lock_delay = delay;\r\n//     }\r\n\r\n//     function setCancel() public onlyOwner {\r\n//         meta_info.presale_in_native = true;\r\n//     }\r\n\r\n//     function calcRate() public view returns (uint256 tokenRate) {\r\n//         uint256 value = meta_info.presale_in_native ? (address(this).balance) : IERC20(presale_info.base_token).balanceOf(address(this));\r\n//         tokenRate = 10 ** 18 / value * presale_info.selling_amount ;\r\n//     }\r\n\r\n//     function calcSendTokens(address user) public view returns (uint256 token_) {\r\n//         uint256 value = calcRate();\r\n//         token_ = value * buyers[user] / 10 ** (18 - tokeninfo.decimal);\r\n//     }\r\n\r\n//     function calcLiquidity() public view returns (uint256 tokens) {\r\n//         uint256 value = calcRate();\r\n//         uint256 liquiditySupply = address(this).balance * presale_info.liquidityPercent / 100;\r\n//         tokens = liquiditySupply *  value / (10 ** (18 - tokeninfo.decimal)); \r\n//     }\r\n\r\n//     function ownerView() public view returns (address) {\r\n//         return owner;\r\n//     }\r\n\r\n   \r\n\r\n//     function getProgress() public view returns (uint256) {\r\n//         uint256 value = raised_amount.mul(100).div(presale_info.softcap);\r\n//         return value;\r\n//     }\r\n\r\n//     function getRaised() public view returns (uint256) {\r\n//         return raised_amount;\r\n//     }\r\n\r\n//     function getUserStatus() public view returns (uint256) {\r\n//         return buyers[msg.sender];\r\n//     }\r\n\r\n\r\n\r\n//     function setRefferal(\r\n//         address _referralAddr,\r\n//         uint256 _referralFee\r\n//     ) public onlyOwner {\r\n//         meta_info.referral_address = _referralAddr;\r\n//         meta_info.referral_fee = _referralFee;\r\n//     }\r\n\r\n//     // Set base and sale token fees\r\n//     function setFees(\r\n//         uint256 _base_token_fee,\r\n//         uint256 _sale_token_fee\r\n//     ) public virtual onlyOwner {\r\n//         meta_info.base_token_fee = _base_token_fee;\r\n//         meta_info.sale_token_fee = _sale_token_fee;\r\n//     }\r\n\r\n//     // Set referral address and fee\r\n//     function setReferral(\r\n//         address referralAddress,\r\n//         uint256 referralFee\r\n//     ) public onlyOwner {\r\n//         referral_address =referralAddress;\r\n//         referral_fee = referralFee;\r\n//     }\r\n\r\n//     function setWhitelist() public onlyOwner {\r\n//         presale_info.presale_type = PresaleType.WHITELIST;\r\n//     }\r\n\r\n//     function _addWhitelistAddr(address addr, bool isBurner) private onlyOwner {\r\n//         whitelistInfo[addr] = true;\r\n//         flokiBurnerInfo[addr] = isBurner;\r\n//     }\r\n\r\n//     function _deleteWhitelistAddr(address addr) private onlyOwner {\r\n//         if (!flokiBurnerInfo[addr])\r\n//             whitelistInfo[addr] = false;\r\n//     }\r\n\r\n//     function setWhitelistInfo(address[] memory user, bool isBurner) public onlyOwner IsWhitelisted {\r\n//         for(uint i = 0 ; i < user.length ; i ++) {\r\n//             _addWhitelistAddr(user[i], isBurner);\r\n//         }\r\n//     }\r\n\r\n//     function deleteWhitelistInfo(address[] memory user) public onlyOwner IsWhitelisted {\r\n//         for(uint i = 0 ; i < user.length ; i ++) {\r\n//             _deleteWhitelistAddr(user[i]);\r\n//         }\r\n//     }\r\n\r\n//     function setWhiteListable(bool _whiteList) public onlyOwner(){\r\n//         whiteList = _whiteList;\r\n//     }\r\n// }"
    },
    "contracts/Pads/FairLaunchFactory.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\r\n// pragma solidity ^0.8.20;\r\n\r\n// import \"./Fairlaunch.sol\";\r\n// import \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\n// import \"@openzeppelin/contracts/utils/Context.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\n// // import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n// import \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\r\n\r\n// // import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n// import \"@openzeppelin/contracts/utils/Counters.sol\";\r\n\r\n// // interface IERC20 {\r\n// //     /**\r\n// //      * @dev Returns the amount of tokens in existence.\r\n// //      */\r\n// //     function totalSupply() external view returns (uint256);\r\n\r\n// //     /**\r\n// //      * @dev Returns the amount of tokens owned by `account`.\r\n// //      */\r\n// //     function balanceOf(address account) external view returns (uint256);\r\n\r\n// //     /**\r\n// //      * @dev Moves `amount` tokens from the caller's account to `recipient`.\r\n// //      *\r\n// //      * Returns a boolean value indicating whether the operation succeeded.\r\n// //      *\r\n// //      * Emits a {Transfer} event.\r\n// //      */\r\n// //     function transfer(address recipient, uint256 amount) external returns (bool);\r\n\r\n// //     /**\r\n// //      * @dev Returns the remaining number of tokens that `spender` will be\r\n// //      * allowed to spend on behalf of `owner` through {transferFrom}. This is\r\n// //      * zero by default.\r\n// //      *\r\n// //      * This value changes when {approve} or {transferFrom} are called.\r\n// //      */\r\n// //     function allowance(address owner, address spender) external view returns (uint256);\r\n\r\n// //     /**\r\n// //      * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\r\n// //      *\r\n// //      * Returns a boolean value indicating whether the operation succeeded.\r\n// //      *\r\n// //      * IMPORTANT: Beware that changing an allowance with this method brings the risk\r\n// //      * that someone may use both the old and the new allowance by unfortunate\r\n// //      * transaction ordering. One possible solution to mitigate this race\r\n// //      * condition is to first reduce the spender's allowance to 0 and set the\r\n// //      * desired value afterwards:\r\n// //      * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\r\n// //      *\r\n// //      * Emits an {Approval} event.\r\n// //      */\r\n// //     function approve(address spender, uint256 amount) external returns (bool);\r\n\r\n// //     /**\r\n// //      * @dev Moves `amount` tokens from `sender` to `recipient` using the\r\n// //      * allowance mechanism. `amount` is then deducted from the caller's\r\n// //      * allowance.\r\n// //      *\r\n// //      * Returns a boolean value indicating whether the operation succeeded.\r\n// //      *\r\n// //      * Emits a {Transfer} event.\r\n// //      */\r\n// //     function transferFrom(\r\n// //         address sender,\r\n// //         address recipient,\r\n// //         uint256 amount\r\n// //     ) external returns (bool);\r\n\r\n// //     /**\r\n// //      * @dev Emitted when `value` tokens are moved from one account (`from`) to\r\n// //      * another (`to`).\r\n// //      *\r\n// //      * Note that `value` may be zero.\r\n// //      */\r\n// //     event Transfer(address indexed from, address indexed to, uint256 value);\r\n\r\n// //     /**\r\n// //      * @dev Emitted when the allowance of a `spender` for an `owner` is set by\r\n// //      * a call to {approve}. `value` is the new allowance.\r\n// //      */\r\n// //     event Approval(address indexed owner, address indexed spender, uint256 value);\r\n// // }\r\n\r\n// contract FairLaunchFactory is Ownable {\r\n//   using Address for address payable;\r\n//   using SafeMath for uint256;\r\n//   using SafeERC20 for IERC20;\r\n\r\n//   event CampaignCreated(address indexed creator,uint256 indexed index, address createdCampaignAddress);\r\n\r\n//   address public feeTo;\r\n//   address _owner;\r\n//   uint256 public flatFee;\r\n//   uint256 public referral_fee;\r\n//   address public referral_address;\r\n//   uint256 public base_token_fee; // base token fee after finalize\r\n//   uint256 public sale_token_fee; // sale token fee after finalize        \r\n\r\n//   modifier enoughFee() {\r\n//     require(msg.value >= flatFee, \"Flat fee\");\r\n//     _;\r\n//   }\r\n\r\n\r\n//   constructor() {\r\n//     feeTo = msg.sender;\r\n//     flatFee = 10_000_000 gwei;\r\n//     _owner = msg.sender;\r\n//   }\r\n  \r\n//   // Call this function before create(...)\r\n//   // Set base token and sale token fees \r\n//   function setFees(\r\n//       uint256 _base_token_fee,\r\n//       uint256 _sale_token_fee\r\n//   ) public virtual onlyOwner {\r\n//       base_token_fee = _base_token_fee;\r\n//       sale_token_fee = _sale_token_fee;\r\n//   }\r\n\r\n//   function setFeeTo(address feeReceivingAddress) external onlyOwner {\r\n//     feeTo = feeReceivingAddress;\r\n//   }\r\n\r\n//   function setFlatFee(uint256 fee) external onlyOwner {\r\n//     flatFee = fee;\r\n//   }\r\n\r\n  \r\n\r\n//   function refundExcessiveFee() internal {\r\n//     uint256 refund = msg.value.sub(flatFee);\r\n//     if (refund > 0) {\r\n//       payable(msg.sender).sendValue(refund);\r\n//     }\r\n//   }\r\n\r\n//   function sendValue(address _token, address to, uint256 _selling_amount, uint256 _liquidityPercent) private {\r\n//     uint256 value = _selling_amount + _selling_amount.mul(_liquidityPercent).div(100);\r\n//     IERC20(_token).safeTransferFrom(msg.sender, to, value);\r\n//   }\r\n\r\n//   function getFeeTo() public view returns(address ) {\r\n//     return feeTo;\r\n//   }\r\n\r\n//   function getFlatFee() public view returns(uint256 ) {\r\n//     return flatFee;\r\n//   }\r\n\r\n//   function create(\r\n//     address _sale_token,\r\n//     address _base_token,\r\n//     bool presale_in_native,\r\n//     uint256 _buyback,\r\n//     bool _whitelist,\r\n//     uint256 _selling_amount,\r\n//     uint256 _softcap, \r\n//     uint256 _liquidityPercent,\r\n//     uint256 _presale_start,\r\n//     uint256 _presale_end,\r\n//     address router\r\n//   ) external payable enoughFee returns (address) {\r\n//     refundExcessiveFee();\r\n//     Fairlaunch newToken = new Fairlaunch(\r\n//       msg.sender,\r\n//       _sale_token,\r\n//       _base_token,\r\n//       presale_in_native,\r\n//       _buyback,\r\n//       _whitelist,\r\n//       _selling_amount,\r\n//       _softcap, \r\n//       _liquidityPercent,\r\n//       _presale_start,\r\n//       _presale_end,\r\n//       feeTo,\r\n//       router\r\n//     );\r\n\r\n//     sendValue(_sale_token, address(newToken), _selling_amount, _liquidityPercent);\r\n//     payable(feeTo).transfer(flatFee);\r\n//     emit  CampaignCreated(msg.sender, 1, address(newToken));\r\n//     return address(newToken);\r\n//   }\r\n// }"
    },
    "contracts/Pads/PresaleFactoryNew.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\r\n// pragma solidity >= 0.8.20;\r\n\r\n// import \"./PresaleNew.sol\";\r\n// import \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\n// contract PresaleFactoryNew {\r\n//   using Address for address payable;\r\n//   using SafeMath for uint256;\r\n\r\n//   address public feeTo;\r\n//   address _owner;\r\n//   uint256 public flatFee;\r\n//   uint256 public base_token_fee;\r\n//   uint256 public sale_token_fee;\r\n//   bool public presale_in_native;\r\n//   address public referralAddress;\r\n//   uint256 public referralFee;\r\n\r\n\r\n//   modifier enoughFee() {\r\n//     require(msg.value >= flatFee, \"Flat fee\");\r\n//     _;\r\n//   }\r\n\r\n//   modifier onlyOwner {\r\n//     require(msg.sender == _owner, \"You are not owner\");\r\n//     _;\r\n//   }\r\n\r\n//   constructor() {\r\n//     feeTo = msg.sender;\r\n//     flatFee = 10_000_000 gwei;\r\n//     _owner = msg.sender;\r\n//   }\r\n\r\n//   function setFeeTo(address feeReceivingAddress) external onlyOwner {\r\n//     feeTo = feeReceivingAddress;\r\n//   }\r\n\r\n//   function setFlatFee(uint256 fee) external onlyOwner {\r\n//     flatFee = fee;\r\n//   }\r\n\r\n//   function getFeeTo() public view returns(address ) {\r\n//     return feeTo;\r\n//   }\r\n\r\n//   function getFlatFee() public view returns(uint256 ) {\r\n//     return flatFee;\r\n//   }\r\n\r\n//   function transferOwner(address to) public onlyOwner {\r\n//     _owner = to;\r\n//   }\r\n\r\n//   function refundExcessiveFee() internal {\r\n//     uint256 refund = msg.value.sub(flatFee);\r\n//     if (refund > 0) {\r\n//       payable(msg.sender).sendValue(refund);\r\n//     }\r\n//   }\r\n\r\n//   function sendValue(address _token, address to, uint256 _hardcap, uint256 _liquidity_rate, uint256 _liquidityPercent, uint256 _token_rate) private  {\r\n//     uint256 listing = _hardcap.mul(_liquidity_rate).mul(_liquidityPercent).div(100);\r\n//     uint256 value = _hardcap.mul(_token_rate).add(listing); \r\n//     value = value.div(10 ** (18 - IBEP20(_token).decimals()));\r\n//     // value.div(10 ** 18);\r\n//     IBEP20(_token).transferFrom(msg.sender, to, value);\r\n//   }\r\n//   function create(\r\n//     address _sale_token,\r\n//     address _base_token, // Pool base token : BNB, BUSD, USDT, USDC, FLOKI\r\n//     uint256[2] memory _rates, // 0: token_rate, 1: liquidity_rate\r\n//     uint256[2] memory _raises, // 0: min, 1: max\r\n//     uint256 _softcap, \r\n//     uint256 _hardcap,\r\n//     uint256 _liquidityPercent,\r\n//     uint256 _presale_start,\r\n//     uint256 _presale_end\r\n//   ) external payable enoughFee returns (address) {\r\n//     refundExcessiveFee();\r\n//     PresaleNew newToken = new PresaleNew(\r\n//       msg.sender, \r\n//       _sale_token, \r\n//       _base_token, \r\n//       _rates[0], _rates[1],\r\n//       _raises[0], _raises[1],\r\n//       _softcap, _hardcap, _liquidityPercent, \r\n//       _presale_start, _presale_end\r\n//     );\r\n\r\n//     // const value = hardcap * presale * 1.02 + 0.98 * hardcap * listing * liquidity / 100\r\n//     // uint256 value = _selling_amount + _selling_amount.mul(_liquidityPercent).div(100);\r\n//     sendValue(_sale_token, address(newToken), _hardcap, _rates[1], _liquidityPercent, _rates[0]);\r\n//     payable(feeTo).transfer(flatFee);\r\n//     return address(newToken);\r\n//   }\r\n// }"
    },
    "contracts/Pads/PresaleNew.sol": {
      "content": "// // SPDX-License-Identifier: MIT\r\n\r\n// pragma solidity ^0.8.20;\r\n\r\n// abstract contract ReentrancyGuard {\r\n//     // Booleans are more expensive than uint256 or any type that takes up a full\r\n//     // word because each write operation emits an extra SLOAD to first read the\r\n//     // slot's contents, replace the bits taken up by the boolean, and then write\r\n//     // back. This is the compiler's defense against contract upgrades and\r\n//     // pointer aliasing, and it cannot be disabled.\r\n\r\n//     // The values being non-zero value makes deployment a bit more expensive,\r\n//     // but in exchange the refund on every call to nonReentrant will be lower in\r\n//     // amount. Since refunds are capped to a percentage of the total\r\n//     // transaction's gas, it is best to keep them low in cases like this one, to\r\n//     // increase the likelihood of the full refund coming into effect.\r\n//     uint256 private constant _NOT_ENTERED = 1;\r\n//     uint256 private constant _ENTERED = 2;\r\n\r\n//     uint256 private _status;\r\n\r\n//     constructor () {\r\n//         _status = _NOT_ENTERED;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Prevents a contract from calling itself, directly or indirectly.\r\n//      * Calling a `nonReentrant` function from another `nonReentrant`\r\n//      * function is not supported. It is possible to prevent this from happening\r\n//      * by making the `nonReentrant` function external, and make it call a\r\n//      * `private` function that does the actual work.\r\n//      */\r\n//     modifier nonReentrant() {\r\n//         // On the first call to nonReentrant, _notEntered will be true\r\n//         require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\r\n\r\n//         // Any calls to nonReentrant after this point will fail\r\n//         _status = _ENTERED;\r\n\r\n//         _;\r\n\r\n//         // By storing the original value once again, a refund is triggered (see\r\n//         // https://eips.ethereum.org/EIPS/eip-2200)\r\n//         _status = _NOT_ENTERED;\r\n//     }\r\n// }\r\n\r\n// library SafeMath {\r\n//     /**\r\n//      * @dev Returns the addition of two unsigned integers, reverting on\r\n//      * overflow.\r\n//      *\r\n//      * Counterpart to Solidity's `+` operator.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - Addition cannot overflow.\r\n//      */\r\n//     function add(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         uint256 c = a + b;\r\n//         require(c >= a, \"SafeMath: addition overflow\");\r\n\r\n//         return c;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the subtraction of two unsigned integers, reverting on\r\n//      * overflow (when the result is negative).\r\n//      *\r\n//      * Counterpart to Solidity's `-` operator.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - Subtraction cannot overflow.\r\n//      */\r\n//     function sub(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         return sub(a, b, \"SafeMath: subtraction overflow\");\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\r\n//      * overflow (when the result is negative).\r\n//      *\r\n//      * Counterpart to Solidity's `-` operator.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - Subtraction cannot overflow.\r\n//      */\r\n//     function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n//         require(b <= a, errorMessage);\r\n//         uint256 c = a - b;\r\n\r\n//         return c;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the multiplication of two unsigned integers, reverting on\r\n//      * overflow.\r\n//      *\r\n//      * Counterpart to Solidity's `*` operator.\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - Multiplication cannot overflow.\r\n//      */\r\n//     function mul(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\r\n//         // benefit is lost if 'b' is also tested.\r\n//         // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\r\n//         if (a == 0) {\r\n//             return 0;\r\n//         }\r\n\r\n//         uint256 c = a * b;\r\n//         require(c / a == b, \"SafeMath: multiplication overflow\");\r\n\r\n//         return c;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the integer division of two unsigned integers. Reverts on\r\n//      * division by zero. The result is rounded towards zero.\r\n//      *\r\n//      * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n//      * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n//      * uses an invalid opcode to revert (consuming all remaining gas).\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - The divisor cannot be zero.\r\n//      */\r\n//     function div(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         return div(a, b, \"SafeMath: division by zero.\");\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\r\n//      * division by zero. The result is rounded towards zero.\r\n//      *\r\n//      * Counterpart to Solidity's `/` operator. Note: this function uses a\r\n//      * `revert` opcode (which leaves remaining gas untouched) while Solidity\r\n//      * uses an invalid opcode to revert (consuming all remaining gas).\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - The divisor cannot be zero.\r\n//      */\r\n//     function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n//         require(b > 0, errorMessage);\r\n//         uint256 c = a / b;\r\n//         // assert(a == b * c + a % b); // There is no case in which this doesn't hold\r\n\r\n//         return c;\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n//      * Reverts when dividing by zero.\r\n//      *\r\n//      * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n//      * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n//      * invalid opcode to revert (consuming all remaining gas).\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - The divisor cannot be zero.\r\n//      */\r\n//     function mod(uint256 a, uint256 b) internal pure returns (uint256) {\r\n//         return mod(a, b, \"SafeMath: modulo by zero\");\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\r\n//      * Reverts with custom message when dividing by zero.\r\n//      *\r\n//      * Counterpart to Solidity's `%` operator. This function uses a `revert`\r\n//      * opcode (which leaves remaining gas untouched) while Solidity uses an\r\n//      * invalid opcode to revert (consuming all remaining gas).\r\n//      *\r\n//      * Requirements:\r\n//      *\r\n//      * - The divisor cannot be zero.\r\n//      */\r\n//     function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\r\n//         require(b != 0, errorMessage);\r\n//         return a % b;\r\n//     }\r\n// }\r\n\r\n// library TransferHelper {\r\n//     function safeApprove(address token, address to, uint value) internal {\r\n//         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n//         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n//     }\r\n\r\n//     function safeTransfer(address token, address to, uint value) internal {\r\n//         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n//         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n//     }\r\n\r\n//     function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n//         (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n//         require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n//     }\r\n    \r\n//     // sends ETH or an erc20 token\r\n//     function safeTransferBaseToken(address token, address payable to, uint value, bool isERC20) internal {\r\n//         if (!isERC20) {\r\n//             to.transfer(value);\r\n//         } else {\r\n//             (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n//             require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n//         }\r\n//     }\r\n// }\r\n\r\n\r\n// interface IBEP20 {\r\n//     event Approval(address indexed owner, address indexed spender, uint value);\r\n//     event Transfer(address indexed from, address indexed to, uint value);\r\n    \r\n//     function decimals() external view returns (uint8);\r\n//     function name() external view returns (string memory);\r\n//     function symbol() external view returns (string memory);\r\n//     function totalSupply() external view returns (uint);\r\n//     function balanceOf(address owner) external view returns (uint);\r\n//     function allowance(address owner, address spender) external view returns (uint);\r\n\r\n//     function approve(address spender, uint value) external returns (bool);\r\n//     function transfer(address to, uint value) external returns (bool);\r\n//     function transferFrom(address from, address to, uint value) external returns (bool);\r\n// }\r\n\r\n// interface IPancakeSwapRouter{\r\n// \t\tfunction factory() external pure returns (address);\r\n// \t\tfunction WETH() external pure returns (address);\r\n\r\n// \t\tfunction addLiquidity(\r\n// \t\t\t\taddress tokenA,\r\n// \t\t\t\taddress tokenB,\r\n// \t\t\t\tuint amountADesired,\r\n// \t\t\t\tuint amountBDesired,\r\n// \t\t\t\tuint amountAMin,\r\n// \t\t\t\tuint amountBMin,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline\r\n// \t\t) external returns (uint amountA, uint amountB, uint liquidity);\r\n// \t\tfunction addLiquidityETH(\r\n// \t\t\t\taddress token,\r\n// \t\t\t\tuint amountTokenDesired,\r\n// \t\t\t\tuint amountTokenMin,\r\n// \t\t\t\tuint amountETHMin,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline\r\n// \t\t) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n// \t\tfunction removeLiquidity(\r\n// \t\t\t\taddress tokenA,\r\n// \t\t\t\taddress tokenB,\r\n// \t\t\t\tuint liquidity,\r\n// \t\t\t\tuint amountAMin,\r\n// \t\t\t\tuint amountBMin,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline\r\n// \t\t) external returns (uint amountA, uint amountB);\r\n// \t\tfunction removeLiquidityETH(\r\n// \t\t\t\taddress token,\r\n// \t\t\t\tuint liquidity,\r\n// \t\t\t\tuint amountTokenMin,\r\n// \t\t\t\tuint amountETHMin,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline\r\n// \t\t) external returns (uint amountToken, uint amountETH);\r\n// \t\tfunction removeLiquidityWithPermit(\r\n// \t\t\t\taddress tokenA,\r\n// \t\t\t\taddress tokenB,\r\n// \t\t\t\tuint liquidity,\r\n// \t\t\t\tuint amountAMin,\r\n// \t\t\t\tuint amountBMin,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline,\r\n// \t\t\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n// \t\t) external returns (uint amountA, uint amountB);\r\n// \t\tfunction removeLiquidityETHWithPermit(\r\n// \t\t\t\taddress token,\r\n// \t\t\t\tuint liquidity,\r\n// \t\t\t\tuint amountTokenMin,\r\n// \t\t\t\tuint amountETHMin,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline,\r\n// \t\t\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n// \t\t) external returns (uint amountToken, uint amountETH);\r\n// \t\tfunction swapExactTokensForTokens(\r\n// \t\t\t\tuint amountIn,\r\n// \t\t\t\tuint amountOutMin,\r\n// \t\t\t\taddress[] calldata path,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline\r\n// \t\t) external returns (uint[] memory amounts);\r\n// \t\tfunction swapTokensForExactTokens(\r\n// \t\t\t\tuint amountOut,\r\n// \t\t\t\tuint amountInMax,\r\n// \t\t\t\taddress[] calldata path,\r\n// \t\t\t\taddress to,\r\n// \t\t\t\tuint deadline\r\n// \t\t) external returns (uint[] memory amounts);\r\n// \t\tfunction swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n// \t\t\t\texternal\r\n// \t\t\t\tpayable\r\n// \t\t\t\treturns (uint[] memory amounts);\r\n// \t\tfunction swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n// \t\t\t\texternal\r\n// \t\t\t\treturns (uint[] memory amounts);\r\n// \t\tfunction swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n// \t\t\t\texternal\r\n// \t\t\t\treturns (uint[] memory amounts);\r\n// \t\tfunction swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n// \t\t\t\texternal\r\n// \t\t\t\tpayable\r\n// \t\t\t\treturns (uint[] memory amounts);\r\n\r\n// \t\tfunction quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n// \t\tfunction getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n// \t\tfunction getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n// \t\tfunction getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n// \t\tfunction getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n// \t\tfunction removeLiquidityETHSupportingFeeOnTransferTokens(\r\n// \t\t\taddress token,\r\n// \t\t\tuint liquidity,\r\n// \t\t\tuint amountTokenMin,\r\n// \t\t\tuint amountETHMin,\r\n// \t\t\taddress to,\r\n// \t\t\tuint deadline\r\n// \t\t) external returns (uint amountETH);\r\n// \t\tfunction removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n// \t\t\taddress token,\r\n// \t\t\tuint liquidity,\r\n// \t\t\tuint amountTokenMin,\r\n// \t\t\tuint amountETHMin,\r\n// \t\t\taddress to,\r\n// \t\t\tuint deadline,\r\n// \t\t\tbool approveMax, uint8 v, bytes32 r, bytes32 s\r\n// \t\t) external returns (uint amountETH);\r\n\t\r\n// \t\tfunction swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n// \t\t\tuint amountIn,\r\n// \t\t\tuint amountOutMin,\r\n// \t\t\taddress[] calldata path,\r\n// \t\t\taddress to,\r\n// \t\t\tuint deadline\r\n// \t\t) external;\r\n// \t\tfunction swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n// \t\t\tuint amountOutMin,\r\n// \t\t\taddress[] calldata path,\r\n// \t\t\taddress to,\r\n// \t\t\tuint deadline\r\n// \t\t) external payable;\r\n// \t\tfunction swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n// \t\t\tuint amountIn,\r\n// \t\t\tuint amountOutMin,\r\n// \t\t\taddress[] calldata path,\r\n// \t\t\taddress to,\r\n// \t\t\tuint deadline\r\n// \t\t) external;\r\n// }\r\n\r\n// interface IPancakeSwapFactory {\r\n// \t\tevent PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n// \t\tfunction feeTo() external view returns (address);\r\n// \t\tfunction feeToSetter() external view returns (address);\r\n\r\n// \t\tfunction getPair(address tokenA, address tokenB) external view returns (address pair);\r\n// \t\tfunction allPairs(uint) external view returns (address pair);\r\n// \t\tfunction allPairsLength() external view returns (uint);\r\n\r\n// \t\tfunction createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n// \t\tfunction setFeeTo(address) external;\r\n// \t\tfunction setFeeToSetter(address) external;\r\n// }\r\n\r\n// interface IMyContract {\r\n//     function getProfit() external view returns(address);\r\n//     function getPercent() external view returns (uint256);\r\n// }\r\n\r\n// contract PresaleNew is ReentrancyGuard {\r\n//     using SafeMath for uint256;\r\n\r\n//     enum PresaleType { PUBLIC, WHITELIST }\r\n\r\n//     struct MetaInfo {\r\n//         bool presale_in_native; // if this flag is true the presale is raising NATIVE currency, otherwise an BEP20 token such as FLOKI\r\n//         uint256 base_token_fee; // base token fee after finalize\r\n//         uint256 sale_token_fee; // sale token fee after finalize\r\n//         bool canceled;\r\n//         uint256 referral_fee;\r\n//         address referral_address;\r\n//     }\r\n\r\n//     struct PresaleInfo {\r\n//         address sale_token; // Sale token\r\n//         address base_token; // Pool base token\r\n//         uint256 token_rate; // 1 base token = ? s_tokens, fixed price\r\n//         uint256 liquidity_rate;\r\n//         uint256 raise_min; // Maximum base token BUY amount per buyer\r\n//         uint256 raise_max; // The amount of presale tokens up for presale\r\n//         uint256 softcap; // Minimum raise amount\r\n//         uint256 hardcap; // Maximum raise amount\r\n//         uint256 liquidityPercent;\r\n//         uint256 presale_start;\r\n//         uint256 presale_end;\r\n//         PresaleType presale_type;\r\n//         uint256 public_time;\r\n//     }\r\n//     bool finalized;\r\n\r\n//     struct PresaleStatus {\r\n//         bool force_failed; // Set this flag to force fail the presale\r\n//         uint256 raised_amount; // Total base currency raised (usually ETH)\r\n//         uint256 sold_amount; // Total presale tokens sold\r\n//         uint256 token_withdraw; // Total tokens withdrawn post successful presale\r\n//         uint256 base_withdraw; // Total base tokens withdrawn on presale failure\r\n//         uint256 num_buyers; // Number of unique participants\r\n//         uint256 end_time;\r\n//     }\r\n\r\n//     struct BuyerInfo {\r\n//         uint256 base; // Total base token (usually ETH) deposited by user, can be withdrawn on presale failure\r\n//         uint256 sale; // Num presale tokens a user owned, can be withdrawn on presale success\r\n//     }\r\n    \r\n//     struct TokenInfo {\r\n//         string name;\r\n//         string symbol;\r\n//         uint256 totalsupply;\r\n//         uint256 decimal;\r\n//     }\r\n\r\n//     address owner;\r\n\r\n//     PresaleInfo public presale_info;\r\n//     PresaleStatus public status;\r\n//     TokenInfo public tokeninfo;\r\n//     MetaInfo public meta_info;\r\n\r\n//     bool public whiteList;\r\n//     uint256 persaleSetting;\r\n//     IPancakeSwapRouter public router;\r\n//     IMyContract public profit;\r\n\r\n//     mapping(address => BuyerInfo) public buyers;\r\n//     mapping(address => bool) public whitelistInfo;\r\n//     mapping(address => bool) public flokiBurnerInfo;\r\n\r\n//     event PresaleCreated(address, address);\r\n//     event UserDepsitedSuccess(address, uint256);\r\n//     event UserWithdrawSuccess(uint256);\r\n//     event UserWithdrawTokensSuccess(uint256);\r\n\r\n//     address deadaddr = 0x000000000000000000000000000000000000dEaD;\r\n\r\n//     uint256 public lock_delay;\r\n//     address profitAddress = 0x800E6AaC8f0DCbd8E809ADD117898C59b90cc445;\r\n\r\n//     modifier onlyOwner() {\r\n//         require(owner == msg.sender, \"Not presale owner.\");\r\n//         _;\r\n//     }\r\n\r\n//     modifier IsWhitelisted() {\r\n//         require(presale_info.presale_type == PresaleType.WHITELIST, \"whitelist not set\");\r\n//         _;\r\n//     }\r\n\r\n//     constructor(\r\n//         address owner_,\r\n//         address _sale_token,\r\n//         address _base_token,\r\n//         uint256 _token_rate,\r\n//         uint256 _liquidity_rate,\r\n//         uint256 _raise_min,\r\n//         uint256 _raise_max, \r\n//         uint256 _softcap, \r\n//         uint256 _hardcap,\r\n//         uint256 _liquidityPercent,\r\n//         uint256 _presale_start,\r\n//         uint256 _presale_end\r\n//     ) {\r\n//         owner = msg.sender;\r\n//         init_private(\r\n//             _sale_token,\r\n//             _base_token,\r\n//             _token_rate,\r\n//             _liquidity_rate,\r\n//             _raise_min, \r\n//             _raise_max, \r\n//             _softcap, \r\n//             _hardcap,\r\n//             _liquidityPercent,\r\n//             _presale_start,\r\n//             _presale_end\r\n//         );\r\n//         owner = owner_;\r\n        \r\n//         emit PresaleCreated(owner, address(this));\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Leaves the contract without owner. It will not be possible to call\r\n//      * `onlyOwner` functions anymore. Can only be called by the current owner.\r\n//      *\r\n//      * NOTE: Renouncing ownership will leave the contract without an owner,\r\n//      * thereby removing any functionality that is only available to the owner.\r\n//      */\r\n//     function renounceOwnership() public virtual onlyOwner {\r\n//         _transferOwnership(address(0));\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n//      * Can only be called by the current owner.\r\n//      */\r\n//     function transferOwnership(address newOwner) public virtual onlyOwner {\r\n//         require(newOwner != address(0), \"Ownable: new owner is the zero address\");\r\n//         _transferOwnership(newOwner);\r\n//     }\r\n\r\n//     /**\r\n//      * @dev Transfers ownership of the contract to a new account (`newOwner`).\r\n//      * Internal function without access restriction.\r\n//      */\r\n//     function _transferOwnership(address newOwner) internal virtual {\r\n//         owner = newOwner;\r\n//     }\r\n\r\n//     function init_private (\r\n//         address _sale_token,\r\n//         address _base_token,\r\n//         uint256 _token_rate,\r\n//         uint256 _liquidity_rate,\r\n//         uint256 _raise_min, \r\n//         uint256 _raise_max, \r\n//         uint256 _softcap, \r\n//         uint256 _hardcap,\r\n//         uint256 _liquidityPercent,\r\n//         uint256 _presale_start,\r\n//         uint256 _presale_end\r\n//         ) public onlyOwner {\r\n\r\n//         require(persaleSetting == 0, \"Already setted\");\r\n//         require(_sale_token != address(0), \"Zero Address\");\r\n        \r\n//         presale_info.sale_token = address(_sale_token);\r\n//         presale_info.base_token = address(_base_token);\r\n//         presale_info.token_rate = _token_rate;\r\n//         presale_info.liquidity_rate = _liquidity_rate;\r\n//         presale_info.raise_min = _raise_min;\r\n//         presale_info.raise_max = _raise_max;\r\n//         presale_info.softcap = _softcap;\r\n//         presale_info.hardcap = _hardcap;\r\n//         presale_info.liquidityPercent = _liquidityPercent;\r\n\r\n//         presale_info.presale_end = _presale_end;\r\n//         presale_info.presale_start =  _presale_start;\r\n//         if(whiteList == true) {\r\n//             presale_info.presale_type = PresaleType.WHITELIST;\r\n//         } else {\r\n//             presale_info.presale_type = PresaleType.PUBLIC;\r\n//         }\r\n//         meta_info.canceled = false;\r\n//         finalized = false;\r\n\r\n//         //Set token token info\r\n//         tokeninfo.name = IBEP20(presale_info.sale_token).name();\r\n//         tokeninfo.symbol = IBEP20(presale_info.sale_token).symbol();\r\n//         tokeninfo.decimal = IBEP20(presale_info.sale_token).decimals();\r\n//         tokeninfo.totalsupply = IBEP20(presale_info.sale_token).totalSupply();\r\n//         router = IPancakeSwapRouter(0xcd7d16fB918511BF7269eC4f48d61D79Fb26f918); \r\n//         profit = IMyContract(profitAddress);\r\n\r\n//         persaleSetting = 1;\r\n//     }\r\n\r\n//     function setOwner(address _newOwner) public onlyOwner {\r\n//         owner = _newOwner;\r\n//     }\r\n\r\n//     function presaleStatus() public returns (uint256) {\r\n//         if(finalized == true) {\r\n//             return 5; // Finalized\r\n//         }\r\n//         if(meta_info.canceled == true) {\r\n//             return 4; // Canceled\r\n//         }\r\n//         if ((block.timestamp > presale_info.presale_end) && (status.raised_amount < presale_info.softcap)) {\r\n//             return 3; // Failure\r\n//         }\r\n//         if (status.raised_amount >= presale_info.hardcap) {\r\n//             status.end_time = block.timestamp;\r\n//             return 2; // Wonderful - reached to Hardcap\r\n//         }\r\n//         if ((block.timestamp > presale_info.presale_end) && (status.raised_amount >= presale_info.softcap)) {\r\n//             status.end_time = block.timestamp;\r\n//             return 2; // SUCCESS - Presale ended with reaching Softcap\r\n//         }\r\n//         if ((block.timestamp >= presale_info.presale_start) && (block.timestamp <= presale_info.presale_end)) {\r\n//             return 1; // ACTIVE - Deposits enabled, now in Presale\r\n//         }\r\n//             return 0; // QUED - Awaiting start block\r\n//     }\r\n    \r\n//     // Accepts msg.value for eth or _amount for ERC20 tokens\r\n//     function userDeposit (uint256 _amount) public payable nonReentrant {\r\n//         if(presale_info.presale_type == PresaleType.WHITELIST) {\r\n//             require(whitelistInfo[msg.sender] == true, \"You are not whitelisted.\");\r\n//         } else if(presale_info.public_time != 0) {\r\n//             if(presale_info.public_time > block.timestamp) {\r\n//                 require(whitelistInfo[msg.sender] == true, \"You are not whitelisted.\");\r\n//             }\r\n//         }\r\n//         require(presaleStatus() == 1, \"Not Active\");\r\n//         if (meta_info.presale_in_native) {\r\n//             require(presale_info.raise_min <= msg.value, \"Balance is insufficent\");\r\n//             require(presale_info.raise_max >= msg.value, \"Balance is too much\"); \r\n//         } else {\r\n//             require(presale_info.raise_min <= _amount, \"Balance is insufficent\");\r\n//             require(presale_info.raise_max >= _amount, \"Balance is too much\");\r\n//         }\r\n\r\n//         BuyerInfo storage buyer = buyers[msg.sender];\r\n\r\n//         uint256 amount_in = meta_info.presale_in_native ? msg.value : _amount;\r\n//         uint256 allowance = presale_info.raise_max.sub(buyer.base);\r\n//         uint256 remaining = presale_info.hardcap - status.raised_amount;\r\n\r\n//         allowance = allowance > remaining ? remaining : allowance;\r\n//         if (amount_in > allowance) {\r\n//             amount_in = allowance;\r\n//         }\r\n\r\n//         uint256 tokensSold = amount_in.mul(presale_info.token_rate).div(10 ** (18 - tokeninfo.decimal));\r\n\r\n//         require(tokensSold > 0, \"ZERO TOKENS\");\r\n//         require(status.raised_amount * presale_info.token_rate <= IBEP20(presale_info.sale_token).balanceOf(address(this)).mul(10 ** (18 - tokeninfo.decimal)), \"Token remain error\");\r\n        \r\n//         if (buyer.base == 0) {\r\n//             status.num_buyers++;\r\n//         }\r\n//         buyers[msg.sender].base = buyers[msg.sender].base.add(amount_in);\r\n//         buyers[msg.sender].sale = buyers[msg.sender].sale.add(tokensSold);\r\n//         status.raised_amount = status.raised_amount.add(amount_in);\r\n//         status.sold_amount = status.sold_amount.add(tokensSold);\r\n        \r\n\r\n//         // return unused ETH\r\n//         if (meta_info.presale_in_native && amount_in < msg.value) {\r\n//             payable(msg.sender).transfer(msg.value.sub(amount_in));\r\n//         }\r\n\r\n//         if (!meta_info.presale_in_native) {\r\n//             TransferHelper.safeTransferFrom(address(presale_info.base_token), msg.sender, address(this), amount_in);\r\n//         }\r\n        \r\n//         emit UserDepsitedSuccess(msg.sender, msg.value);\r\n//     }\r\n    \r\n//     // withdraw presale tokens\r\n//     // percentile withdrawls allows fee on transfer or rebasing tokens to still work\r\n//     function userWithdrawTokens () public nonReentrant {\r\n//         require(presaleStatus() == 2, \"Not succeeded\"); // Success\r\n//         require(block.timestamp >= status.end_time + lock_delay, \"Token Locked.\"); // Lock duration check\r\n        \r\n//         BuyerInfo storage buyer = buyers[msg.sender];\r\n//         uint256 remaintoken = status.sold_amount.sub(status.token_withdraw);\r\n//         require(remaintoken >= buyer.sale, \"Nothing to withdraw.\");\r\n        \r\n//         TransferHelper.safeTransfer(address(presale_info.sale_token), msg.sender, buyer.sale);\r\n        \r\n//         status.token_withdraw = status.token_withdraw.add(buyer.sale);\r\n//         buyers[msg.sender].sale = 0;\r\n//         buyers[msg.sender].base = 0;\r\n        \r\n//         emit UserWithdrawTokensSuccess(buyer.sale);\r\n//     }\r\n    \r\n//     // On presale failure\r\n//     // Percentile withdrawls allows fee on transfer or rebasing tokens to still work\r\n//     function userWithdrawBaseTokens () public nonReentrant {\r\n//         require(presaleStatus() == 3 || presaleStatus() == 4, \"Not failed or canceled.\"); // FAILED\r\n        \r\n//         // Refund\r\n//         BuyerInfo storage buyer = buyers[msg.sender];\r\n        \r\n//         uint256 remainingBaseBalance = meta_info.presale_in_native ? address(this).balance : IBEP20(presale_info.base_token).balanceOf(address(this));\r\n        \r\n//         require(remainingBaseBalance >= buyer.base, \"Nothing to withdraw.\");\r\n\r\n//         status.base_withdraw = status.base_withdraw.add(buyer.base);\r\n        \r\n//         address payable reciver = payable(msg.sender);\r\n//         // reciver.transfer(buyer.base);\r\n//         TransferHelper.safeTransferBaseToken(presale_info.base_token, reciver, buyer.base, meta_info.presale_in_native);\r\n\r\n//         if(msg.sender == owner) {\r\n//             ownerWithdrawTokens();\r\n//             // return;\r\n//         }\r\n\r\n//         buyer.base = 0;\r\n//         buyer.sale = 0;\r\n//         buyers[msg.sender].base = 0;\r\n//         buyers[msg.sender].sale = 0;\r\n        \r\n//         emit UserWithdrawSuccess(buyer.base);\r\n//     }\r\n    \r\n//     // On presale failure\r\n//     function ownerWithdrawTokens () private onlyOwner {\r\n//         TransferHelper.safeTransfer(address(presale_info.sale_token), owner, IBEP20(presale_info.sale_token).balanceOf(address(this)));\r\n        \r\n//         emit UserWithdrawSuccess(IBEP20(presale_info.sale_token).balanceOf(address(this)));\r\n//     }\r\n\r\n//     function purchaseICOCoin (address to) public nonReentrant onlyOwner {\r\n//         require(presaleStatus() == 2, \"Not succeeded\"); // Success\r\n        \r\n//         address payable reciver = payable(to);\r\n//         // uint256 _percent = profit.getPercent();\r\n//         address addr = profit.getProfit();\r\n        \r\n//         // get profit of base token\r\n//         if (meta_info.base_token_fee > 0) {\r\n//             uint256 basefee = status.raised_amount.mul(meta_info.base_token_fee).div(100);\r\n//             status.raised_amount.sub(basefee);\r\n//             if (meta_info.referral_address != address(0)) {\r\n//                 uint256 referralfee = basefee.mul(meta_info.referral_fee).div(100);\r\n//                 if (meta_info.presale_in_native) {\r\n//                     payable(meta_info.referral_address).transfer(referralfee);\r\n//                 } else {\r\n//                     TransferHelper.safeTransferBaseToken(presale_info.base_token, payable(meta_info.referral_address), referralfee, meta_info.presale_in_native);\r\n//                 }    \r\n//                 basefee.sub(referralfee);\r\n//             }\r\n//             if (meta_info.presale_in_native) {\r\n//                 payable(addr).transfer(basefee);\r\n//             } else {\r\n//                 TransferHelper.safeTransferBaseToken(presale_info.base_token, payable(address(this)), basefee, meta_info.presale_in_native);\r\n//             }\r\n//         }\r\n//         // get profit of sale token\r\n//         if (meta_info.sale_token_fee > 0) {\r\n//             uint256 salefee = status.sold_amount.mul(meta_info.sale_token_fee).div(100);\r\n//             if (meta_info.referral_address != address(0)) {\r\n//                 uint256 referralfee = salefee.mul(meta_info.referral_fee).div(100);\r\n//                 TransferHelper.safeTransfer(presale_info.sale_token, msg.sender, salefee);\r\n//                 salefee.sub(referralfee);\r\n//             }\r\n//             TransferHelper.safeTransfer(presale_info.sale_token, meta_info.referral_address, salefee);\r\n//         }\r\n\r\n//         uint256 supply = meta_info.presale_in_native ? address(this).balance : IBEP20(presale_info.base_token).balanceOf(address(this));\r\n//         uint256 liquiditySupply = supply * presale_info.liquidityPercent / 100;\r\n//         uint256 tokenLiquidity = liquiditySupply * presale_info.liquidity_rate / (10 ** (18 - tokeninfo.decimal)); \r\n//         require(IBEP20(presale_info.sale_token).balanceOf(address(this)) >= tokenLiquidity, \"insufficient tokens\");\r\n//         bool success = IBEP20(presale_info.sale_token).approve(address(router), tokenLiquidity);\r\n//         require(success == true, 'Approve failed');\r\n//         if (meta_info.presale_in_native) {\r\n//             router.addLiquidityETH{value: liquiditySupply}(\r\n//                 presale_info.sale_token,\r\n//                 tokenLiquidity,\r\n//                 0,\r\n//                 0,\r\n//                 reciver,\r\n//                 block.timestamp\r\n//             ); \r\n//         } else {\r\n//             bool success_ = IBEP20(presale_info.base_token).approve(address(router), liquiditySupply);\r\n//             require(success_ == true, 'Base Token Approve failed');\r\n//             router.addLiquidity(\r\n//                 presale_info.base_token, \r\n//                 presale_info.sale_token, \r\n//                 liquiditySupply, \r\n//                 tokenLiquidity, \r\n//                 0, \r\n//                 0, \r\n//                 reciver, \r\n//                 block.timestamp);\r\n//         }\r\n        \r\n//         require(supply >= liquiditySupply, \"insufficient value\");\r\n//         supply = supply.sub(liquiditySupply);\r\n//         TransferHelper.safeTransferBaseToken(presale_info.base_token, reciver, supply, meta_info.presale_in_native);\r\n//         finalized = true;\r\n//     }\r\n\r\n//     function getTimestamp () public view returns (uint256) {\r\n//         return block.timestamp;\r\n//     }\r\n\r\n//     function setLockDelay (uint256 delay) public onlyOwner {\r\n//         lock_delay = delay;\r\n//     }\r\n\r\n//     function remainingBurn() public onlyOwner {\r\n//         require(presaleStatus() == 2, \"Not succeeded\"); // Success\r\n//         require(presale_info.hardcap * presale_info.token_rate >= status.sold_amount, \"Nothing to burn\");\r\n        \r\n//         uint256 rushTokenAmount = presale_info.hardcap * presale_info.token_rate - status.sold_amount;\r\n\r\n//         TransferHelper.safeTransfer(address(presale_info.sale_token), address(deadaddr), rushTokenAmount);\r\n//     }\r\n\r\n//     function setWhitelist() public onlyOwner {\r\n//         presale_info.presale_type = PresaleType.WHITELIST;\r\n//     }\r\n\r\n//     function _addWhitelistAddr(address addr, bool isBurner) private onlyOwner {\r\n//         whitelistInfo[addr] = true;\r\n//         flokiBurnerInfo[addr] = isBurner;\r\n//     }\r\n\r\n//     function _deleteWhitelistAddr(address addr) private onlyOwner {\r\n//         if (!flokiBurnerInfo[addr])\r\n//             whitelistInfo[addr] = false;\r\n//     }\r\n\r\n//     function setWhitelistInfo(address[] memory user, bool isBurner) public onlyOwner IsWhitelisted {\r\n//         for(uint i = 0 ; i < user.length ; i ++) {\r\n//             _addWhitelistAddr(user[i], isBurner);\r\n//         }\r\n//     }\r\n\r\n//     function deleteWhitelistInfo(address[] memory user) public onlyOwner IsWhitelisted {\r\n//         for(uint i = 0 ; i < user.length ; i ++) {\r\n//             _deleteWhitelistAddr(user[i]);\r\n//         }\r\n//     }\r\n\r\n//     function setPublic(uint256 time) public onlyOwner  {\r\n//         presale_info.presale_type = PresaleType.PUBLIC;\r\n//         presale_info.public_time = time;\r\n//     }\r\n\r\n//     function setCancel() public onlyOwner {\r\n//         meta_info.canceled = true;\r\n//     }\r\n\r\n//     function getSaleType () public view returns (bool) {\r\n//         if(presale_info.presale_type == PresaleType.PUBLIC) {\r\n//             return true;\r\n//         } else {\r\n//             return false;\r\n//         }\r\n//     }\r\n    \r\n//     function getOwner () public view returns (address) {\r\n//         return owner;\r\n//     }\r\n\r\n//     function getProgress() public view returns (uint256 ) {\r\n//         uint256 value = status.raised_amount.mul(100).div(presale_info.hardcap);\r\n//         return value;\r\n//     }\r\n\r\n//     function getUserStatus() public view returns (uint256) {\r\n//         return buyers[msg.sender].base;\r\n//     }\r\n\r\n//     function setProfitAddress(address to) public onlyOwner {\r\n//         profitAddress = to;\r\n//     }\r\n    \r\n//     // Set base and sale token fees\r\n//     function setFees(\r\n//         uint256 _base_token_fee,\r\n//         uint256 _sale_token_fee\r\n//     ) public virtual onlyOwner {\r\n//         meta_info.base_token_fee = _base_token_fee;\r\n//         meta_info.sale_token_fee = _sale_token_fee;\r\n//     }\r\n\r\n//     // Set base token is native currency or not\r\n//     function setPresaleInNative(\r\n//         bool withNative\r\n//     ) public onlyOwner {\r\n//         meta_info.presale_in_native = withNative;\r\n//     }\r\n\r\n//     // Set referral address and fee\r\n//     function setRefferal(\r\n//         address _referralAddr,\r\n//         uint256 _referralFee\r\n//     ) public onlyOwner {\r\n//         meta_info.referral_address = _referralAddr;\r\n//         meta_info.referral_fee = _referralFee;\r\n//     }\r\n// }"
    },
    "contracts/Pads/ThirdPart.sol": {
      "content": "// // SPDX-License-Identifier: MIT\r\n\r\n// pragma solidity ^0.8.4;\r\n\r\n// contract MyContract {\r\n//     address profitAddress;\r\n//     address owner;\r\n//     uint256 profitPercent;\r\n\r\n//     modifier onlyOwner {\r\n//         require(owner == msg.sender, 'Not owner');\r\n//         _;\r\n//     }\r\n//     constructor(address _addr, uint256 _percent) {\r\n//         profitAddress = _addr;\r\n//         profitPercent = _percent;\r\n//         owner = msg.sender;\r\n//     }\r\n//     function setProfit(address _addr) public onlyOwner{\r\n//         profitAddress = _addr;\r\n//     }\r\n\r\n//     function setPercent(uint256 _percent) public onlyOwner {\r\n//         profitPercent = _percent;\r\n//     }\r\n\r\n//     function getProfit() external view returns(address) {\r\n//         return profitAddress;\r\n//     }\r\n\r\n//     function getPercent() external view returns (uint256) {\r\n//         return profitPercent;\r\n//     }\r\n\r\n//     function transferOwner(address to) public onlyOwner {\r\n//         owner = to;\r\n//     }\r\n// }"
    },
    "contracts/Presale.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.10;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol\";\r\nimport \"@openzeppelin/contracts/utils/math/Math.sol\";\r\n\r\ncontract Presale {\r\n    using Math for uint256;\r\n\r\n    address public admin;\r\n    address public tokenAddress;\r\n    address public baseCurrencyAddress;\r\n    uint256 public rate;\r\n\r\n    event TokensPurchased(address buyer, uint256 amountPaid, uint256 amountBought);\r\n\r\n    constructor(\r\n        address _tokenAddress,\r\n        address _baseCurrencyAddress,\r\n        uint256 _rate\r\n    ) {\r\n        admin = msg.sender;\r\n        tokenAddress = _tokenAddress;\r\n        baseCurrencyAddress = _baseCurrencyAddress;\r\n        rate = _rate;\r\n    }\r\n\r\n    function buyTokens(uint256 amount) external {\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n\r\n        IERC20 baseCurrency = IERC20(baseCurrencyAddress);\r\n        if(address(0)!=baseCurrencyAddress){\r\n            \r\n\r\n            uint256 allowance = baseCurrency.allowance(msg.sender, address(this));\r\n            require(allowance >= amount, \"Allowance not sufficient\");\r\n        }\r\n        \r\n        uint256 tokensToBuy = amount*rate/(10**getDecimals(baseCurrencyAddress));\r\n        require(tokensToBuy > 0, \"Insufficient tokens available for purchase\");\r\n\r\n        baseCurrency.transferFrom(msg.sender, address(this), amount);\r\n        IERC20(tokenAddress).transfer(msg.sender, tokensToBuy);\r\n\r\n        emit TokensPurchased(msg.sender, amount, tokensToBuy);\r\n    }\r\n\r\n    function calcRates(uint256 amount) public view returns  (uint,uint,uint) {\r\n        require(amount > 0, \"Amount must be greater than 0\");\r\n\r\n        // IERC20 baseCurrency = IERC20(baseCurrencyAddress);\r\n        // if(address(0)!=baseCurrencyAddress){\r\n            \r\n\r\n        //     uint256 allowance = baseCurrency.allowance(msg.sender, address(this));\r\n        //     require(allowance >= amount, \"Allowance not sufficient\");\r\n        // }\r\n        \r\n        uint256 tokensToBuy = amount*rate/(10**getDecimals(baseCurrencyAddress));\r\n        require(tokensToBuy > 0, \"Insufficient tokens available for purchase\");\r\n\r\n        // baseCurrency.transferFrom(msg.sender, address(this), amount);\r\n        // IERC20(tokenAddress).transfer(msg.sender, tokensToBuy);\r\n\r\n        return  (\r\n            tokensToBuy, \r\n            amount*rate/(10**getDecimals(tokenAddress)),\r\n            amount*rate/(10** (getDecimals(baseCurrencyAddress) - getDecimals(tokenAddress))) \r\n        ) ;\r\n    }\r\n\r\n    function multiply(uint a,uint aDecimal, uint b, uint bDecimal) public pure returns(uint){\r\n        a= normalizeTokenAmount(a, aDecimal);\r\n        b= normalizeTokenAmount(b, bDecimal);\r\n\r\n        return a*b;\r\n    }\r\n\r\n    /**\r\n     * Normalization function that adjusts token amounts to a common decimal base (18 decimals in this case). \r\n     * This function either scales up or scales down the token amount based on the number of decimals the token uses,\r\n     * ensuring the final amount will be always displayed with 18 decimals. \r\n     * Of course this can result in a minor truncation if tokens >18 decimals are being used, this must be considered\r\n     */\r\n    function normalizeTokenAmount(uint tokenAmount, uint tokenDecimals) public pure returns (uint) {\r\n        uint standardDecimal = 18;\r\n        if(tokenDecimals>standardDecimal){\r\n            return tokenAmount / (10 ** (tokenDecimals-standardDecimal));\r\n        }\r\n        else if(tokenDecimals< standardDecimal){\r\n            return tokenAmount * (10 ** (standardDecimal - tokenDecimals));\r\n        }\r\n        else{\r\n            return tokenAmount;\r\n        }\r\n    }\r\n\r\n\r\n\r\n    function getDecimals(address _tokenAddress) private view returns (uint256) {\r\n        if (_tokenAddress == address(0)) {\r\n            return 18; // Assuming native currency has 18 decimals\r\n        } else {\r\n            return IERC20Metadata(_tokenAddress).decimals();\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/Test.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.0;\r\nimport \"hardhat/console.sol\";\r\n\r\n\r\ncontract Test {\r\n    bytes public t;\r\n    uint hardCap= 100 ether;\r\n\r\n    uint public usdcDecimals = 6;\r\n    uint public pbtDecimals = 18;//base\r\n    // uint public exchangeRateWei;\r\n\r\n    constructor()  {\r\n        \r\n    }\r\n\r\n    \r\n\r\n    function calculatePBT(uint exchangeRateWei, uint amountUSDCWei) public view returns (uint) {\r\n        return amountUSDCWei * exchangeRateWei;\r\n    }\r\n\r\n    function calculatePBT2(uint exchangeRateWei, uint amountUSDCWei) public view returns (uint) {\r\n        return (amountUSDCWei * exchangeRateWei) / (10**(pbtDecimals - usdcDecimals   ));\r\n    }\r\n\r\n    function calculatePBTDiv(uint exchangeRate, uint amountUSDCWei) public view returns (uint) {\r\n        return (amountUSDCWei * exchangeRate) / (10**(pbtDecimals - usdcDecimals   ));  //base - token\r\n    }\r\n\r\n    function calculatePBT3(uint exchangeRateWei, uint amountUSDCWei) public view returns (uint) {\r\n        //10 ** 18 / value * presale_info.selling_amount\r\n        return 10 ** 18 / (amountUSDCWei * exchangeRateWei) ; // / (10**(usdcDecimals - pbtDecimals  ));\r\n    }\r\n\r\n\r\n\r\n    function bytesToAddress(bytes calldata data) private pure returns (string memory s) {\r\n        // bytes memory b = data;\r\n        // assembly {\r\n        //   addr := mload(add(b, 20))\r\n        // } \r\n\r\n        s= string(data);\r\n    }\r\n\r\n    \r\n    function decodeArray(bytes calldata data) public pure returns(string[] memory result){\r\n        uint8 stringLength = 64;\r\n        uint n = data.length/stringLength;\r\n        result = new string[](n);\r\n        \r\n        for(uint i=0; i<n; i++){\r\n            result[i] = bytesToAddress(data[i*stringLength:(i+1)*stringLength]);\r\n        }\r\n    }\r\n\r\n    function bytesToBytes32Array(bytes memory data)\r\n        public\r\n        pure\r\n        returns (bytes32[] memory)\r\n    {\r\n        // Find 32 bytes segments nb\r\n        uint256 dataNb = data.length / 32;\r\n        // Create an array of dataNb elements\r\n        bytes32[] memory dataList = new bytes32[](dataNb);\r\n        // Start array index at 0\r\n        uint256 index = 0;\r\n        // Loop all 32 bytes segments\r\n        for (uint256 i = 32; i <= data.length; i = i + 32) {\r\n            bytes32 temp;\r\n            // Get 32 bytes from data\r\n            assembly {\r\n                temp := mload(add(data, i))\r\n            }\r\n            // Add extracted 32 bytes to list\r\n            dataList[index] = temp;\r\n            index++;\r\n        }\r\n        // Return data list\r\n        return (dataList);\r\n    }\r\n\r\n\r\n    fallback(bytes calldata data) external payable returns (bytes memory) {\r\n        // // payable(_coinLocker).transfer(msg.value);\r\n        // // console.log('data:',msg.data);\r\n        // t=msg.data;\r\n        // (address[] memory _str1) = abi.decode(msg.data, (address[]));\r\n        // console.log('data:', _str1[0]);\r\n\r\n        // string[] memory addresses = decodeArray(data);\r\n        // console.log('data:', addresses[0]);\r\n        // console.log('data:', addresses[1]);\r\n\r\n        \r\n        bytes32[] memory addresses = bytesToBytes32Array(data);\r\n        console.log('data1:', addresses.length);\r\n        // console.log('data2:', addresses[1]);\r\n\r\n        return '';\r\n    }\r\n\r\n    \r\n\r\n    \r\n}"
    },
    "contracts/Token.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract Token is ERC20 {\r\n    constructor() ERC20(\"Test\", \"TST\") {\r\n        _mint(msg.sender, 700_000  ether);\r\n        _mint(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 150_000  ether);\r\n        _mint(0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199, 150_000  ether);\r\n    }\r\n}"
    },
    "contracts/Token2.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.17;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract Token2 is ERC20 {\r\n    constructor(string memory name, string memory symbol) ERC20(name, symbol) {\r\n        _mint(msg.sender, 700_000  ether);\r\n        _mint(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 150_000  ether);\r\n        _mint(0x8626f6940E2eb28930eFb4CeF49B2d1F2C9C1199, 150_000  ether);\r\n    }\r\n}"
    },
    "contracts/TokenMinters/BurnMintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\n\r\ncontract BurnMintable is ERC20Burnable{\r\n\r\n    uint8 _decimals;\r\n    uint tokenFeePercent = 65;  //0.65% - percent fee of token to take\r\n\r\n    constructor(string memory name, string memory symbol, uint256 totalSupply, uint8 decimals,address tokenOwner,\r\n        address tokenFeeCollector, uint _tokenFeePercent) ERC20(name, symbol) {\r\n            \r\n        tokenFeePercent=_tokenFeePercent;\r\n        uint fee = totalSupply * tokenFeePercent/10000;\r\n        _mint(tokenOwner, totalSupply - fee);\r\n        _mint(tokenFeeCollector, fee);\r\n        _decimals = decimals;\r\n    }\r\n   \r\n   function decimals() public view virtual override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}"
    },
    "contracts/TokenMinters/Cloneable/BurnMintable.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract BurnMintableCloneable is ERC20Burnable{\r\n\r\n    uint8 _decimals;\r\n    uint tokenFeePercent = 300;  //3% - percent fee of token to take\r\n\r\n    constructor(string memory name, string memory symbol, uint256 totalSupply, uint8 decimals,address tokenOwner,address tokenFeeCollector) ERC20(name, symbol){\r\n        uint fee = totalSupply * tokenFeePercent/10000;\r\n        _mint(tokenOwner, totalSupply - fee);\r\n        _mint(tokenFeeCollector, fee);\r\n        _decimals = decimals;\r\n    }\r\n   \r\n   function decimals() public view virtual override returns (uint8) {\r\n        return _decimals;\r\n    }\r\n}"
    },
    "contracts/TokenMinters/Cloneable/SimpleERC20.sol": {
      "content": "// // SPDX-License-Identifier: MIT\r\n\r\n// pragma solidity ^0.8.13;\r\n\r\n// import \"@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol\";\r\n// // import \"@openzeppelin/contracts/proxy/utils/Initializable.sol\";\r\n// import \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\r\n// import \"hardhat/console.sol\";\r\n\r\n// contract SimpleERC20Cloneable is Initializable, ERC20Upgradeable{\r\n\r\n//     uint8 _decimals;\r\n//     uint tokenFeePercent = 200;  //2% - percent fee of token to take\r\n\r\n//     // constructor(string memory name, string memory symbol, uint256 totalSupply, uint8 decimals,address tokenOwner,address tokenFeeCollector) ERC20(name, symbol){\r\n//     //     uint fee = totalSupply * tokenFeePercent/10000;\r\n//     //     _mint(tokenOwner, totalSupply - fee);\r\n//     //     _mint(tokenFeeCollector, fee);\r\n//     //     _decimals = decimals;\r\n//     // }\r\n\r\n//     function initialize(string memory name, string memory symbol, uint256 totalSupply, uint8 decimals,address tokenOwner,address tokenFeeCollector) public initializer {\r\n//         __ERC20_init(name, symbol);\r\n//         //__Ownable_init();\r\n\r\n//         tokenFeePercent = 200;  //2% - percent fee of token to take\r\n//         console.log(\"Initializing....\");\r\n//         uint fee = totalSupply * tokenFeePercent/10000;\r\n//         _mint(tokenOwner, totalSupply - fee);\r\n//         _mint(tokenFeeCollector, fee);\r\n//         _decimals = decimals;\r\n//     }\r\n\r\n//     function decimals() public view virtual override returns(uint8){\r\n//         return _decimals;\r\n//     }\r\n\r\n// }"
    },
    "contracts/TokenMinters/Cloneable/StandardERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract StandardERC20Cloneable is ERC20{\r\n\r\n    uint8 _decimals;\r\n    uint tokenFeePercent = 250;  //2.5% - percent fee of token to take\r\n\r\n    constructor(string memory name, string memory symbol,uint256 totalSupply, uint8 decimals,address tokenOwner,address tokenFeeCollector) ERC20(name, symbol){\r\n        uint fee = totalSupply * tokenFeePercent/10000;\r\n        _mint(tokenOwner, totalSupply - fee);\r\n        _mint(tokenFeeCollector, fee);\r\n        _decimals = decimals;\r\n    }\r\n\r\n    function decimals() public view virtual override returns(uint8){\r\n        return _decimals;\r\n    }\r\n}"
    },
    "contracts/TokenMinters/SimpleERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.13;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract SimpleERC20 is ERC20{\r\n\r\n    uint8 _decimals;\r\n    uint tokenFeePercent = 50;  //0.5% - percent fee of token to take\r\n\r\n    constructor(string memory name, string memory symbol, uint256 totalSupply, uint8 decimals,address tokenOwner,\r\n    address tokenFeeCollector, uint _tokenFeePercent) ERC20(name, symbol) {\r\n            \r\n        tokenFeePercent=_tokenFeePercent;\r\n        uint fee = totalSupply * tokenFeePercent/10000;\r\n        _mint(tokenOwner, totalSupply - fee);\r\n        _mint(tokenFeeCollector, fee);\r\n        _decimals = decimals;\r\n    }\r\n\r\n    function decimals() public view virtual override returns(uint8){\r\n        return _decimals;\r\n    }\r\n\r\n}"
    },
    "contracts/TokenMinters/StandardERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\r\n\r\ncontract StandardERC20 is ERC20{\r\n\r\n    uint8 _decimals;\r\n    uint tokenFeePercent = 60;  //0.6% - percent fee of token to take\r\n\r\n    constructor(string memory name, string memory symbol,uint256 totalSupply, uint8 decimal,\r\n        address tokenOwner,address tokenFeeCollector, uint _tokenFeePercent) ERC20(name, symbol) {\r\n            \r\n        tokenFeePercent=_tokenFeePercent;\r\n        uint fee = totalSupply * tokenFeePercent/10000;\r\n        _mint(tokenOwner, totalSupply - fee);\r\n        _mint(tokenFeeCollector, fee);\r\n        _decimals = decimal;\r\n    }\r\n\r\n    function decimals() public view virtual override returns(uint8){\r\n        return _decimals;\r\n    }\r\n}"
    },
    "contracts/TokenMinters/TokenMinterFactory.sol": {
      "content": "// SPDX-License-Identifier: UNLICENSED\r\n\r\npragma solidity ^0.8.26;\r\n\r\nimport \"@openzeppelin/contracts/utils/Context.sol\";\r\nimport \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\r\n\r\n// import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\nimport \"hardhat/console.sol\";\r\n\r\nimport './SimpleERC20.sol';\r\nimport './StandardERC20.sol';\r\nimport './BurnMintable.sol';\r\n\r\nimport '../Interfaces/Turnstile.sol';\r\n\r\nerror InSufficientFee();\r\n\r\ncontract TokenMinterFactory is Context,Ownable  {\r\n    using SafeERC20 for IERC20;\r\n\r\n    enum TokenTypes{ \r\n        SIMPLE,\r\n        STANDARD,\r\n        BURNMINTABLE\r\n    }\r\n\r\n    \r\n    using EnumerableMap for EnumerableMap.UintToAddressMap;\r\n    \r\n    // Declare a set state variable\r\n    EnumerableMap.UintToAddressMap private _tokens;\r\n\r\n    uint private _counter;\r\n\r\n    address public turnstileAddress = address(0);\r\n    Turnstile private turnstile;\r\n        \r\n    \r\n    mapping(TokenTypes => uint) public nativeFees; //TokenType -> fee \r\n    mapping(TokenTypes => uint) public tokenFees; //TokenType -> fee \r\n\r\n    address private tokenFeeCollector ;\r\n\r\n    mapping(address => uint256[]) private ownersToken; //owneraddress -> tokensIndex    \r\n\r\n    address[] public _tokensList; //tokenAddress\r\n\r\n    event TokenCreated(address creator, uint256 indexed index, address createdTokenAddress);\r\n\r\n    mapping(TokenTypes => uint) private tokenTypeCount;\r\n\r\n    constructor(uint[3] memory _nativeFees, uint[3] memory _tokenFees) Ownable(msg.sender)  {      \r\n       tokenFeeCollector= address(this);\r\n\r\n       nativeFees[TokenTypes.SIMPLE]=_nativeFees[0];// 0.001 ether;\r\n       nativeFees[TokenTypes.STANDARD]=_nativeFees[1];//0.0015 ether;\r\n       nativeFees[TokenTypes.BURNMINTABLE]=_nativeFees[2];//0.003 ether;\r\n\r\n       tokenFees[TokenTypes.SIMPLE]=_tokenFees[0];// 0.001 ether;\r\n       tokenFees[TokenTypes.STANDARD]=_tokenFees[1];//0.0015 ether;\r\n       tokenFees[TokenTypes.BURNMINTABLE]=_tokenFees[2];//0.003 ether;\r\n    }\r\n\r\n    function setTokenFeeCollector(address newAddress) public onlyOwner{\r\n        tokenFeeCollector=newAddress;\r\n    }\r\n\r\n    function setNativeFee(TokenTypes tokenType, uint256 newPrice) public onlyOwner{\r\n        \r\n        nativeFees[tokenType]=newPrice;\r\n    }\r\n\r\n    function setTokenFee(TokenTypes tokenType, uint256 newPrice) public onlyOwner{\r\n        \r\n        tokenFees[tokenType]=newPrice;\r\n    }\r\n\r\n    function updateTurnstileAddress(address newAddress) public onlyOwner{\r\n        \r\n        turnstileAddress=newAddress;\r\n        turnstile = Turnstile(turnstileAddress);\r\n        //Registers the smart contract with Turnstile\r\n        //Mints the CSR NFT to the contract creator\r\n        turnstile.register(tx.origin);\r\n\r\n    }\r\n\r\n\r\n    \r\n    function createNewToken(TokenTypes tokenType,\r\n        string memory name,\r\n        string memory symbol,\r\n        uint8 decimals,\r\n        uint totalSupply\r\n    ) public payable  {\r\n\r\n        require(msg.value >= nativeFees[tokenType], InSufficientFee() );\r\n            \r\n        _counter++; \r\n        uint index = _counter;\r\n\r\n        address sender = msg.sender;\r\n\r\n        tokenTypeCount[tokenType]++;\r\n\r\n        address newTokenAddress;\r\n\r\n        if(tokenType == TokenTypes.SIMPLE){\r\n            SimpleERC20 s= new SimpleERC20(name, symbol, totalSupply, decimals, sender, tokenFeeCollector, tokenFees[tokenType]);\r\n            newTokenAddress = address(s);\r\n        }else if(tokenType == TokenTypes.STANDARD){\r\n            StandardERC20 s= new StandardERC20(name, symbol, totalSupply, decimals, sender, tokenFeeCollector, tokenFees[tokenType]);\r\n            newTokenAddress = address(s);\r\n        }else if(tokenType == TokenTypes.BURNMINTABLE){\r\n            BurnMintable s= new BurnMintable(name, symbol, totalSupply, decimals, sender, tokenFeeCollector, tokenFees[tokenType]);\r\n            newTokenAddress = address(s);\r\n        }\r\n\r\n        _tokens.set(index, newTokenAddress);\r\n        ownersToken[sender].push( index);\r\n        _tokensList.push(newTokenAddress);\r\n        emit TokenCreated(sender,index, newTokenAddress);\r\n\r\n    \r\n    }\r\n\r\n\r\n    function getTokenTypeCount(TokenTypes tokenType) public view returns (uint256 count){\r\n        \r\n        return tokenTypeCount[tokenType];\r\n    }\r\n\r\n    //offset \r\n    function allOwnersTokens(uint256 limit, uint256 offset) public view returns (uint256[] memory) {\r\n        uint256[] memory list = new uint256[](offset) ;\r\n        for (uint256 i=limit; i < limit + offset ; i++) {\r\n            list[i-limit] = ownersToken[msg.sender][i]; \r\n        }\r\n        return list;\r\n    }\r\n\r\n    \r\n    function tokensCount() public view returns (uint256) {\r\n        return _counter;\r\n    }\r\n\r\n    function withdrawTokens(address tokenAddress) public onlyOwner  \r\n    {\r\n        IERC20 _token = IERC20(tokenAddress);\r\n        uint amount = _token.balanceOf(address(this));\r\n        require(amount > 0, \"TokenMinterFactory: No Tokens to claim\");\r\n        _token.safeTransfer( _msgSender(), amount);\r\n    }\r\n\r\n    \r\n\r\n      \r\n\r\n    function tokenAt(uint256 index) public view returns (uint256 key, address value) {\r\n        return _tokens.at(index);\r\n    }\r\n\r\n    function tryGetTokenByKey(uint256 key) public view returns (bool, address) {\r\n        return _tokens.tryGet(key);\r\n    }\r\n\r\n    \r\n\r\n    // //abi.encodePacked(x)\r\n    // function concatenate(string memory s1, string memory s2) public pure returns (string memory) {\r\n    //     return string(abi.encodePacked(s1, s2));\r\n    // }\r\n\r\n    // function concatenate(string memory s1, address s2) public pure returns (string memory) {\r\n    //     return string(abi.encodePacked(s1, s2));\r\n    // }\r\n\r\n}"
    },
    "contracts/TokenMinters/TokenMinterFactoryClone.sol": {
      "content": "// // SPDX-License-Identifier: UNLICENSED\r\n\r\n// pragma solidity ^0.8.13;\r\n\r\n// import \"@openzeppelin/contracts/utils/Context.sol\";\r\n// import \"@openzeppelin/contracts/utils/structs/EnumerableMap.sol\";\r\n\r\n// // import \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\n// import \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n// import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n// import { Clones } from \"@openzeppelin/contracts/proxy/Clones.sol\";\r\n// import \"hardhat/console.sol\";\r\n\r\n// import './Cloneable/SimpleERC20.sol';\r\n// import './Cloneable/StandardERC20.sol';\r\n// import './Cloneable/BurnMintable.sol';\r\n\r\n\r\n// contract TokenMinterFactoryCloneable is Context,Ownable  {\r\n//     using SafeERC20 for IERC20;\r\n\r\n//     enum TokenTypes{ \r\n//         SIMPLE,\r\n//         STANDARD,\r\n//         BURNMINTABLE\r\n//     }\r\n\r\n    \r\n//     using EnumerableMap for EnumerableMap.UintToAddressMap;\r\n    \r\n//     // Declare a set state variable\r\n//     EnumerableMap.UintToAddressMap private _tokens;\r\n\r\n//     uint private _counter;\r\n\r\n    \r\n    \r\n//     mapping(TokenTypes => uint) private nativeFees; //TokenType -> fee \r\n\r\n//     address private tokenFeeCollector ;\r\n\r\n//     mapping(address => uint256[]) private ownersToken; //owneraddress -> tokensIndex    \r\n\r\n//     address[] public _tokensList; //tokenAddress\r\n\r\n//     event TokenCreated(address creator, uint256 indexed index, address createdTokenAddress);\r\n\r\n//     mapping(TokenTypes => uint) private tokenTypeCount;\r\n\r\n//     constructor() Ownable(msg.sender)  {      \r\n//        tokenFeeCollector= address(this);\r\n\r\n//        nativeFees[TokenTypes.SIMPLE]=0.001 ether;\r\n//        nativeFees[TokenTypes.STANDARD]=0.0015 ether;\r\n//        nativeFees[TokenTypes.BURNMINTABLE]=0.003 ether;\r\n//     }\r\n\r\n//     function setTokenFeeCollector(address newAddress) public onlyOwner{\r\n//         tokenFeeCollector=newAddress;\r\n//     }\r\n\r\n//     function setZSaleNativeFee(TokenTypes tokenType, uint256 newPrice) public onlyOwner{\r\n        \r\n//         nativeFees[tokenType]=newPrice;\r\n//     }\r\n\r\n    \r\n//     function createNewToken(TokenTypes tokenType,\r\n//         string memory name,\r\n//         string memory symbol,\r\n//         uint8 decimals,\r\n//         uint totalSupply\r\n//     ) public payable  {\r\n\r\n//         require(msg.value >= nativeFees[tokenType], 'TokenFactory: Requires Token Creation Price' );\r\n            \r\n//         _counter++; \r\n//         uint index = _counter;\r\n\r\n//         address sender = msg.sender;\r\n\r\n//         tokenTypeCount[tokenType]++;\r\n\r\n//         if(tokenType == TokenTypes.SIMPLE){\r\n//             // SimpleERC20Cloneable s= new SimpleERC20Cloneable();\r\n//             // // s.initialize(name, symbol, totalSupply, decimals, sender, tokenFeeCollector);\r\n            \r\n//             // address newTokenAddress = address(s);\r\n//             // console.log('newTokenAddress: ', newTokenAddress);\r\n//             // (bool success, bytes memory returndata) = newTokenAddress.delegatecall(abi.encodeWithSignature(\"initialize(string,string,uint256,uint8,address,address)\", name, symbol, totalSupply, decimals, sender, tokenFeeCollector));\r\n\r\n//             //  // if the function call reverted\r\n//             // if (success == false) {\r\n//             //     // if there is a return reason string\r\n//             //     if (returndata.length > 0) {\r\n//             //         // bubble up any reason for revert\r\n//             //         assembly {\r\n//             //             let returndata_size := mload(returndata)\r\n//             //             revert(add(32, returndata), returndata_size)\r\n//             //         }\r\n//             //     } else {\r\n//             //         revert(\"Function call reverted\");\r\n//             //     }\r\n//             // }\r\n\r\n//             // _tokens.set(index, newTokenAddress);\r\n//             // ownersToken[sender].push( index);\r\n//             // _tokensList.push(newTokenAddress);\r\n//             // emit TokenCreated(sender,index, newTokenAddress);\r\n//         }else if(tokenType == TokenTypes.STANDARD){\r\n//             // StandardERC20Cloneable s= new StandardERC20Cloneable(name, symbol, totalSupply, decimals, sender, tokenFeeCollector);\r\n//             // address newTokenAddress = address(s);\r\n//             // _tokens.set(index, newTokenAddress);\r\n//             // ownersToken[sender].push( index);\r\n//             // _tokensList.push(newTokenAddress);\r\n//             // emit TokenCreated(sender,index, newTokenAddress);\r\n//         }else if(tokenType == TokenTypes.BURNMINTABLE){\r\n//             // BurnMintableCloneable s= new BurnMintableCloneable(name, symbol, totalSupply, decimals, sender, tokenFeeCollector);\r\n//             // address newTokenAddress = address(s);\r\n//             // _tokens.set(index, newTokenAddress);\r\n//             // ownersToken[sender].push( index);\r\n//             // _tokensList.push(newTokenAddress);\r\n//             // emit TokenCreated(sender,index, newTokenAddress);\r\n//         }\r\n\r\n        \r\n\r\n    \r\n//     }\r\n\r\n\r\n//     function getTokenTypeCount(TokenTypes tokenType) public view returns (uint256 count){\r\n        \r\n//         return tokenTypeCount[tokenType];\r\n//     }\r\n\r\n//     //offset \r\n//     function allOwnersTokens(uint256 limit, uint256 offset) public view returns (uint256[] memory) {\r\n//         uint256[] memory list = new uint256[](offset) ;\r\n//         for (uint256 i=limit; i < limit + offset ; i++) {\r\n//             list[i-limit] = ownersToken[msg.sender][i]; \r\n//         }\r\n//         return list;\r\n//     }\r\n\r\n    \r\n//     function tokensCount() public view returns (uint256) {\r\n//         return _counter;\r\n//     }\r\n\r\n//     function withdrawTokens(address tokenAddress) public onlyOwner  \r\n//     {\r\n//         IERC20 _token = IERC20(tokenAddress);\r\n//         uint amount = _token.balanceOf(address(this));\r\n//         require(amount > 0, \"TokenMinterFactory: No Tokens to claim\");\r\n//         _token.safeTransfer( _msgSender(), amount);\r\n//     }\r\n\r\n    \r\n\r\n      \r\n\r\n//     function tokenAt(uint256 index) public view returns (uint256 key, address value) {\r\n//         return _tokens.at(index);\r\n//     }\r\n\r\n//     function tryGetTokenByKey(uint256 key) public view returns (bool, address) {\r\n//         return _tokens.tryGet(key);\r\n//     }\r\n\r\n    \r\n\r\n//     // //abi.encodePacked(x)\r\n//     // function concatenate(string memory s1, string memory s2) public pure returns (string memory) {\r\n//     //     return string(abi.encodePacked(s1, s2));\r\n//     // }\r\n\r\n//     // function concatenate(string memory s1, address s2) public pure returns (string memory) {\r\n//     //     return string(abi.encodePacked(s1, s2));\r\n//     // }\r\n\r\n// }"
    },
    "contracts/uniswapv2/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IERC20Uniswap {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external view returns (string memory);\r\n    function symbol() external view returns (string memory);\r\n    function decimals() external view returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n}\r\n"
    },
    "contracts/uniswapv2/interfaces/IUniswapV2Callee.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Callee {\r\n    function uniswapV2Call(address sender, uint amount0, uint amount1, bytes calldata data) external;\r\n}\r\n"
    },
    "contracts/uniswapv2/interfaces/IUniswapV2ERC20.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2ERC20 {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n}"
    },
    "contracts/uniswapv2/interfaces/IUniswapV2Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Factory {\r\n    event PairCreated(address indexed token0, address indexed token1, address pair, uint);\r\n\r\n    function feeTo() external view returns (address);\r\n    function feeToSetter() external view returns (address);\r\n    function migrator() external view returns (address);\r\n\r\n    function getPair(address tokenA, address tokenB) external view returns (address pair);\r\n    function allPairs(uint) external view returns (address pair);\r\n    function allPairsLength() external view returns (uint);\r\n\r\n    function createPair(address tokenA, address tokenB) external returns (address pair);\r\n\r\n    function setFeeTo(address) external;\r\n    function setFeeToSetter(address) external;\r\n    function setMigrator(address) external;\r\n\r\n    function pairCodeHash() external view returns (bytes32);\r\n}\r\n"
    },
    "contracts/uniswapv2/interfaces/IUniswapV2Pair.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IUniswapV2Pair {\r\n    event Approval(address indexed owner, address indexed spender, uint value);\r\n    event Transfer(address indexed from, address indexed to, uint value);\r\n\r\n    function name() external pure returns (string memory);\r\n    function symbol() external pure returns (string memory);\r\n    function decimals() external pure returns (uint8);\r\n    function totalSupply() external view returns (uint);\r\n    function balanceOf(address owner) external view returns (uint);\r\n    function allowance(address owner, address spender) external view returns (uint);\r\n\r\n    function approve(address spender, uint value) external returns (bool);\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function transferFrom(address from, address to, uint value) external returns (bool);\r\n\r\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\r\n    function PERMIT_TYPEHASH() external pure returns (bytes32);\r\n    function nonces(address owner) external view returns (uint);\r\n\r\n    function permit(address owner, address spender, uint value, uint deadline, uint8 v, bytes32 r, bytes32 s) external;\r\n\r\n    event Mint(address indexed sender, uint amount0, uint amount1);\r\n    event Burn(address indexed sender, uint amount0, uint amount1, address indexed to);\r\n    event Swap(\r\n        address indexed sender,\r\n        uint amount0In,\r\n        uint amount1In,\r\n        uint amount0Out,\r\n        uint amount1Out,\r\n        address indexed to\r\n    );\r\n    event Sync(uint112 reserve0, uint112 reserve1);\r\n\r\n    function MINIMUM_LIQUIDITY() external pure returns (uint);\r\n    function factory() external view returns (address);\r\n    function token0() external view returns (address);\r\n    function token1() external view returns (address);\r\n    function getReserves() external view returns (uint112 reserve0, uint112 reserve1, uint32 blockTimestampLast);\r\n    function price0CumulativeLast() external view returns (uint);\r\n    function price1CumulativeLast() external view returns (uint);\r\n    function kLast() external view returns (uint);\r\n\r\n    function mint(address to) external returns (uint liquidity);\r\n    function burn(address to) external returns (uint amount0, uint amount1);\r\n    function swap(uint amount0Out, uint amount1Out, address to, bytes calldata data) external;\r\n    function skim(address to) external;\r\n    function sync() external;\r\n\r\n    function initialize(address, address) external;\r\n}"
    },
    "contracts/uniswapv2/interfaces/IUniswapV2Router01.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.6.2;\r\n\r\ninterface IUniswapV2Router01 {\r\n    function factory() external pure returns (address);\r\n    function WETH() external pure returns (address);\r\n\r\n    function addLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint amountADesired,\r\n        uint amountBDesired,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB, uint liquidity);\r\n    function addLiquidityETH(\r\n        address token,\r\n        uint amountTokenDesired,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidity);\r\n    function removeLiquidity(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETH(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function removeLiquidityWithPermit(\r\n        address tokenA,\r\n        address tokenB,\r\n        uint liquidity,\r\n        uint amountAMin,\r\n        uint amountBMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountA, uint amountB);\r\n    function removeLiquidityETHWithPermit(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountToken, uint amountETH);\r\n    function swapExactTokensForTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapTokensForExactTokens(\r\n        uint amountOut,\r\n        uint amountInMax,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint[] memory amounts);\r\n    function swapExactETHForTokens(uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n    function swapTokensForExactETH(uint amountOut, uint amountInMax, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapExactTokensForETH(uint amountIn, uint amountOutMin, address[] calldata path, address to, uint deadline)\r\n        external\r\n        returns (uint[] memory amounts);\r\n    function swapETHForExactTokens(uint amountOut, address[] calldata path, address to, uint deadline)\r\n        external\r\n        payable\r\n        returns (uint[] memory amounts);\r\n\r\n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\r\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\r\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\r\n    function getAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\r\n    function getAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\r\n}"
    },
    "contracts/uniswapv2/interfaces/IUniswapV2Router02.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.6.2;\r\n\r\nimport './IUniswapV2Router01.sol';\r\n\r\ninterface IUniswapV2Router02 is IUniswapV2Router01 {\r\n    function removeLiquidityETHSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline\r\n    ) external returns (uint amountETH);\r\n    function removeLiquidityETHWithPermitSupportingFeeOnTransferTokens(\r\n        address token,\r\n        uint liquidity,\r\n        uint amountTokenMin,\r\n        uint amountETHMin,\r\n        address to,\r\n        uint deadline,\r\n        bool approveMax, uint8 v, bytes32 r, bytes32 s\r\n    ) external returns (uint amountETH);\r\n\r\n    function swapExactTokensForTokensSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n    function swapExactETHForTokensSupportingFeeOnTransferTokens(\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external payable;\r\n    function swapExactTokensForETHSupportingFeeOnTransferTokens(\r\n        uint amountIn,\r\n        uint amountOutMin,\r\n        address[] calldata path,\r\n        address to,\r\n        uint deadline\r\n    ) external;\r\n}"
    },
    "contracts/uniswapv2/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.5.0;\r\n\r\ninterface IWETH {\r\n    function deposit() external payable;\r\n    function transfer(address to, uint value) external returns (bool);\r\n    function withdraw(uint) external;\r\n}"
    },
    "contracts/uniswapv2/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0\r\n\r\npragma solidity >=0.6.0;\r\n\r\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\r\nlibrary TransferHelper {\r\n    function safeApprove(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\r\n    }\r\n\r\n    function safeTransfer(address token, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\r\n    }\r\n\r\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\r\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n    }\r\n\r\n    function safeTransferETH(address to, uint value) internal {\r\n        (bool success,) = to.call{value:value}(new bytes(0));\r\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\r\n    }\r\n}\r\n"
    },
    "contracts/ZVault/ERC20VestingVault.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n\r\npragma solidity ^0.8.8;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\n\r\n\r\ncontract ERC20VestingVault is Ownable {\r\n    \r\n\r\n    \r\n    modifier onlyValidAddress(address _recipient) {\r\n        require(_recipient != address(0) && _recipient != address(this) && _recipient != address(token), \"not valid _recipient\");\r\n        _;\r\n    }\r\n\r\n    uint256 constant internal SECONDS_PER_DAY = 86400;\r\n\r\n    struct Grant {\r\n        uint256 startTime;\r\n        uint256 amount;\r\n        uint16 vestingDuration;\r\n        uint16 vestingCliff;\r\n        uint16 daysClaimed;\r\n        uint256 totalClaimed;\r\n        address recipient;\r\n    }\r\n\r\n    event GrantAdded(address indexed recipient, uint256 vestingId);\r\n    event GrantTokensClaimed(address indexed recipient, uint256 amountClaimed);\r\n    event GrantRemoved(address recipient, uint256 amountVested, uint256 amountNotVested);\r\n    \r\n\r\n    IERC20 public token;\r\n    \r\n    mapping (uint256 => Grant) public tokenGrants;\r\n    mapping (address => uint[]) private activeGrants;\r\n    \r\n    uint256 public totalVestingCount;\r\n\r\n    constructor(IERC20 _token) Ownable(msg.sender) public {\r\n        require(address(_token) != address(0));\r\n        \r\n        token = _token;\r\n    }\r\n    \r\n    function addTokenGrant(\r\n        address _recipient,\r\n        uint256 _startTime,\r\n        uint256 _amount,\r\n        uint16 _vestingDurationInDays,\r\n        uint16 _vestingCliffInDays    \r\n    ) \r\n        external\r\n        onlyOwner\r\n    {\r\n        require(_vestingCliffInDays <= 10*365, \"more than 10 years\");\r\n        require(_vestingDurationInDays <= 25*365, \"more than 25 years\");\r\n        require(_vestingDurationInDays >= _vestingCliffInDays, \"Duration < Cliff\");\r\n        \r\n        uint256 amountVestedPerDay = _amount/_vestingDurationInDays;\r\n        require(amountVestedPerDay > 0, \"amountVestedPerDay > 0\");\r\n\r\n        // Transfer the grant tokens under the control of the vesting contract\r\n        // require(token.transferFrom(owner(), address(this), _amount), \"transfer failed\");\r\n\r\n        Grant memory grant = Grant({\r\n            startTime: _startTime == 0 ? currentTime() : _startTime,\r\n            amount: _amount,\r\n            vestingDuration: _vestingDurationInDays,\r\n            vestingCliff: _vestingCliffInDays,\r\n            daysClaimed: 0,\r\n            totalClaimed: 0,\r\n            recipient: _recipient\r\n        });\r\n        tokenGrants[totalVestingCount] = grant;\r\n        activeGrants[_recipient].push(totalVestingCount);\r\n        emit GrantAdded(_recipient, totalVestingCount);\r\n        totalVestingCount++;\r\n    }\r\n\r\n    function getActiveGrants(address _recipient) public view returns(uint256[] memory){\r\n        return activeGrants[_recipient];\r\n    }\r\n\r\n    /// @notice Calculate the vested and unclaimed months and tokens available for `_grantId` to claim\r\n    /// Due to rounding errors once grant duration is reached, returns the entire left grant amount\r\n    /// Returns (0, 0) if cliff has not been reached\r\n    function calculateGrantClaim(uint256 _grantId) public view returns (uint16, uint256) {\r\n        Grant storage tokenGrant = tokenGrants[_grantId];\r\n\r\n        // For grants created with a future start date, that hasn't been reached, return 0, 0\r\n        if (currentTime() < tokenGrant.startTime) {\r\n            return (0, 0);\r\n        }\r\n\r\n        // Check cliff was reached\r\n        uint elapsedTime = currentTime()-tokenGrant.startTime;\r\n        uint elapsedDays = elapsedTime/SECONDS_PER_DAY;\r\n        \r\n        if (elapsedDays < tokenGrant.vestingCliff) {\r\n            return (uint16(elapsedDays), 0);\r\n        }\r\n\r\n        // If over vesting duration, all tokens vested\r\n        if (elapsedDays >= tokenGrant.vestingDuration) {\r\n            uint256 remainingGrant = tokenGrant.amount-tokenGrant.totalClaimed;\r\n            return (tokenGrant.vestingDuration, remainingGrant);\r\n        } else {\r\n            uint16 daysVested = uint16(elapsedDays-tokenGrant.daysClaimed);\r\n            uint256 amountVestedPerDay = tokenGrant.amount/ uint256(tokenGrant.vestingDuration);\r\n            uint256 amountVested = uint256(daysVested*amountVestedPerDay);\r\n            return (daysVested, amountVested);\r\n        }\r\n    }\r\n\r\n    /// @notice Allows a grant recipient to claim their vested tokens. Errors if no tokens have vested\r\n    /// It is advised recipients check they are entitled to claim via `calculateGrantClaim` before calling this\r\n    function claimVestedTokens(uint256 _grantId) external {\r\n        uint16 daysVested;\r\n        uint256 amountVested;\r\n        (daysVested, amountVested) = calculateGrantClaim(_grantId);\r\n        require(amountVested > 0, \"amountVested is 0\");\r\n\r\n        Grant storage tokenGrant = tokenGrants[_grantId];\r\n        tokenGrant.daysClaimed = uint16(tokenGrant.daysClaimed+ daysVested);\r\n        tokenGrant.totalClaimed = uint256(tokenGrant.totalClaimed + amountVested);\r\n        \r\n        require(token.transfer(tokenGrant.recipient, amountVested), \"no tokens\");\r\n        emit GrantTokensClaimed(tokenGrant.recipient, amountVested);\r\n    }\r\n\r\n    // /// @notice Terminate token grant transferring all vested tokens to the `_grantId`\r\n    // /// and returning all non-vested tokens to the V12 MultiSig\r\n    // /// Secured to the V12 MultiSig only\r\n    // /// @param _grantId grantId of the token grant recipient\r\n    // function removeTokenGrant(uint256 _grantId) \r\n    //     external \r\n    //     onlyOwner\r\n    // {\r\n    //     Grant storage tokenGrant = tokenGrants[_grantId];\r\n    //     address recipient = tokenGrant.recipient;\r\n    //     uint16 daysVested;\r\n    //     uint256 amountVested;\r\n    //     (daysVested, amountVested) = calculateGrantClaim(_grantId);\r\n\r\n    //     uint256 amountNotVested = (tokenGrant.amount.sub(tokenGrant.totalClaimed)).sub(amountVested);\r\n\r\n    //     require(token.transfer(recipient, amountVested));\r\n    //     require(token.transfer(v12MultiSig, amountNotVested));\r\n\r\n    //     tokenGrant.startTime = 0;\r\n    //     tokenGrant.amount = 0;\r\n    //     tokenGrant.vestingDuration = 0;\r\n    //     tokenGrant.vestingCliff = 0;\r\n    //     tokenGrant.daysClaimed = 0;\r\n    //     tokenGrant.totalClaimed = 0;\r\n    //     tokenGrant.recipient = address(0);\r\n\r\n    //     emit GrantRemoved(recipient, amountVested, amountNotVested);\r\n    // }\r\n\r\n    function currentTime() private view returns(uint256) {\r\n        return block.timestamp;\r\n    }\r\n\r\n    function tokensVestedPerDay(uint256 _grantId) public view returns(uint256) {\r\n        Grant storage tokenGrant = tokenGrants[_grantId];\r\n        return tokenGrant.amount/uint256(tokenGrant.vestingDuration);\r\n    }\r\n\r\n    \r\n\r\n}"
    },
    "contracts/ZVault/LiquidityLockerTest.sol": {
      "content": "// // SPDX-License-Identifier: MIT\r\n// pragma solidity ^0.8.0;\r\n\r\n\r\n// import {IDexRouter, IDexFactory} from \"../IDexRouter.sol\";\r\n// import \"hardhat/console.sol\";\r\n// import \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\n\r\n\r\n\r\n\r\n// // locks liquidity for LP tokens based on % of raised funds\r\n// contract LiquidityLockerTest{\r\n\r\n//     using SafeERC20 for IERC20;\r\n//     // using SafeMath for uint256;\r\n\r\n    \r\n\r\n//      // timestamp when token release is enabled\r\n//     uint256 private _releaseTime;\r\n\r\n//     uint256 private _price; \r\n    \r\n\r\n//     address private _owner; \r\n\r\n//     address private _deployer;\r\n\r\n//     uint256 constant private MAX_INT = 2**256 - 1;\r\n\r\n//     uint256 public totalTokensExpected ;\r\n//     uint256 public totalEthExpected ;\r\n    \r\n\r\n//     address private _token;\r\n//     address public lpTokenPairAddress;\r\n\r\n//     IDexRouter private _dexRouter;\r\n//     IDexFactory private _dexFactory;\r\n\r\n\r\n    \r\n\r\n    \r\n\r\n//     constructor(address dexRouterAddress, address token, address owner, uint256 price,uint256 releaseTime, uint liquidityPercentOfRaisedFunds,uint maxRaisedFunds) {\r\n//         require(releaseTime > block.timestamp, \"LiquidityLocker: release time is before current time\");\r\n//         _releaseTime = releaseTime;\r\n//         _dexRouter = IDexRouter(dexRouterAddress);\r\n//         _dexFactory = IDexFactory(_dexRouter.factory());\r\n\r\n//         _deployer = msg.sender;\r\n//         _price = price;\r\n//         _owner = owner;\r\n//         _token = token;\r\n//         console.log(\"liquidityPercentOfRaisedFunds:\", liquidityPercentOfRaisedFunds);\r\n//         console.log(\"maxRaisedFunds:\", maxRaisedFunds);\r\n//         console.log(\"_price:\", _price);\r\n//         totalEthExpected = (liquidityPercentOfRaisedFunds* maxRaisedFunds)  / 100;\r\n//         totalTokensExpected = _price * totalEthExpected;\r\n\r\n//         console.log(\"totalEthExpected:\", totalEthExpected);\r\n//         console.log(\"totalTokensExpected:\", totalTokensExpected);\r\n//     }\r\n\r\n//     receive() external payable {\r\n\r\n//     }\r\n\r\n//     /**\r\n//     * @dev Add Liquidity to Dex at defined price, if no pool exists it will create one.\r\n//     *  Approve token for router, require contract to have the necessary tokens\r\n//     *\r\n//      */\r\n//     function addLiquidity() public {\r\n        \r\n        \r\n//         require(msg.sender == address(_deployer), \"LiquidityLocker: Only deployer can call this function\");\r\n//         require(_token != address(0), \"LiquidityLocker: Token can not be zero\");\r\n//         uint256 etherBalance = address(this).balance;\r\n        \r\n//         uint256 tokensAmount = _price * etherBalance;\r\n//         uint256 tokensAmountMin = tokensAmount - (_price * etherBalance);\r\n//         require(etherBalance >= totalEthExpected, \"LiquidityLocker: no ether to add liquidity\"); \r\n\r\n              \r\n//         require( IERC20(_token).balanceOf(address(this)) >= totalTokensExpected, \"LiquidityLocker: no token balance to add liquidity\");\r\n        \r\n        \r\n//         lpTokenPairAddress = _dexFactory.getPair(_token, _dexRouter.WETH() );\r\n//         if(lpTokenPairAddress==address(0)){\r\n//           lpTokenPairAddress = _dexFactory.createPair(_token, _dexRouter.WETH());          \r\n//         }        \r\n        \r\n//         // _factory.createPair(address(this), _router.WETH());\r\n//         IERC20(_token).approve(address(_dexRouter), MAX_INT);\r\n//         IERC20(_token).approve(lpTokenPairAddress, MAX_INT);\r\n//         console.log(\"lpTokenPairAddress:\", lpTokenPairAddress);\r\n//         _dexRouter.addLiquidityETH{value: totalEthExpected}(_token, tokensAmount , tokensAmount, totalEthExpected, address(this), block.timestamp + 100);\r\n\r\n        \r\n//     }\r\n\r\n  \r\n\r\n//    /**\r\n//      * @return the time when the tokens are released.\r\n//      */\r\n//     function getReleaseTime() public view returns (uint256) {\r\n//         return _releaseTime;\r\n//     }\r\n\r\n//       /**\r\n//      * @return the owner of the locked funds\r\n//      */\r\n//     function getOwner() public view returns (address) {\r\n//         return _owner;\r\n//     }\r\n    \r\n//     /**\r\n//      * @notice Transfers LP tokens held by Lock to owner.\r\n//        @dev Able to withdraw LP funds after release time \r\n//      */\r\n//     function releaseLPTokens() public {\r\n//         // solhint-disable-next-line not-rely-on-time\r\n//         require(block.timestamp >= _releaseTime, \"LiquidityLocker: current time is before release time\");\r\n\r\n//         IERC20 lptoken=IERC20(lpTokenPairAddress);\r\n//         uint256 amount = lptoken.balanceOf(address(this));\r\n//         require(amount > 0, \"LiquidityLocker: no LP tokens to release\");\r\n\r\n//         lptoken.safeTransfer(_owner, amount); \r\n//     }\r\n\r\n//     /**\r\n//      * @notice Transfers tokens held by Lock to owner.\r\n//        @dev Able to withdraw LP funds after release time \r\n//      */\r\n//     function release() public {\r\n//         // solhint-disable-next-line not-rely-on-time\r\n//         require(block.timestamp >= _releaseTime, \"LiquidityLocker: current time is before release time\");\r\n\r\n//         uint256 amount = IERC20(_token).balanceOf(address(this));\r\n//         require(amount > 0, \"LiquidityLocker: no tokens to release\");\r\n\r\n//         IERC20(_token).safeTransfer(_owner, amount); \r\n//     }\r\n\r\n//        /**\r\n//      * @notice Transfers ETH back to the owner\r\n//        @dev Function used only if it was not used all the ETH\r\n//      */\r\n//     function releaseETH() public {\r\n//         // solhint-disable-next-line not-rely-on-time\r\n//         require(block.timestamp >= _releaseTime, \"LiquidityLocker: current time is before release time\");\r\n//         require(address(this).balance > 0, \"LiquidityLocker: no Eth to release\");\r\n\r\n//         payable(getOwner()).transfer(address(this).balance);\r\n//     }\r\n// }"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.4.22 <0.9.0;\n\nlibrary console {\n    address constant CONSOLE_ADDRESS =\n        0x000000000000000000636F6e736F6c652e6c6f67;\n\n    function _sendLogPayloadImplementation(bytes memory payload) internal view {\n        address consoleAddress = CONSOLE_ADDRESS;\n        /// @solidity memory-safe-assembly\n        assembly {\n            pop(\n                staticcall(\n                    gas(),\n                    consoleAddress,\n                    add(payload, 32),\n                    mload(payload),\n                    0,\n                    0\n                )\n            )\n        }\n    }\n\n    function _castToPure(\n      function(bytes memory) internal view fnIn\n    ) internal pure returns (function(bytes memory) pure fnOut) {\n        assembly {\n            fnOut := fnIn\n        }\n    }\n\n    function _sendLogPayload(bytes memory payload) internal pure {\n        _castToPure(_sendLogPayloadImplementation)(payload);\n    }\n\n    function log() internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log()\"));\n    }\n    function logInt(int256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n    }\n\n    function logUint(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function logString(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function logBool(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function logAddress(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function logBytes(bytes memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n    }\n\n    function logBytes1(bytes1 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n    }\n\n    function logBytes2(bytes2 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n    }\n\n    function logBytes3(bytes3 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n    }\n\n    function logBytes4(bytes4 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n    }\n\n    function logBytes5(bytes5 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n    }\n\n    function logBytes6(bytes6 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n    }\n\n    function logBytes7(bytes7 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n    }\n\n    function logBytes8(bytes8 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n    }\n\n    function logBytes9(bytes9 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n    }\n\n    function logBytes10(bytes10 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n    }\n\n    function logBytes11(bytes11 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n    }\n\n    function logBytes12(bytes12 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n    }\n\n    function logBytes13(bytes13 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n    }\n\n    function logBytes14(bytes14 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n    }\n\n    function logBytes15(bytes15 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n    }\n\n    function logBytes16(bytes16 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n    }\n\n    function logBytes17(bytes17 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n    }\n\n    function logBytes18(bytes18 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n    }\n\n    function logBytes19(bytes19 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n    }\n\n    function logBytes20(bytes20 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n    }\n\n    function logBytes21(bytes21 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n    }\n\n    function logBytes22(bytes22 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n    }\n\n    function logBytes23(bytes23 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n    }\n\n    function logBytes24(bytes24 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n    }\n\n    function logBytes25(bytes25 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n    }\n\n    function logBytes26(bytes26 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n    }\n\n    function logBytes27(bytes27 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n    }\n\n    function logBytes28(bytes28 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n    }\n\n    function logBytes29(bytes29 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n    }\n\n    function logBytes30(bytes30 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n    }\n\n    function logBytes31(bytes31 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n    }\n\n    function logBytes32(bytes32 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n    }\n\n    function log(uint256 p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n    }\n\n    function log(string memory p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n    }\n\n    function log(bool p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n    }\n\n    function log(address p0) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n    }\n\n    function log(uint256 p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n    }\n\n    function log(uint256 p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n    }\n\n    function log(uint256 p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n    }\n\n    function log(uint256 p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n    }\n\n    function log(string memory p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n    }\n\n    function log(string memory p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n    }\n\n    function log(string memory p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n    }\n\n    function log(string memory p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n    }\n\n    function log(bool p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n    }\n\n    function log(bool p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n    }\n\n    function log(bool p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n    }\n\n    function log(bool p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n    }\n\n    function log(address p0, uint256 p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n    }\n\n    function log(address p0, string memory p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n    }\n\n    function log(address p0, bool p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n    }\n\n    function log(address p0, address p1) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n    }\n\n    function log(string memory p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n    }\n\n    function log(bool p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, uint256 p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, string memory p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, bool p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, uint256 p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, string memory p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, bool p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n    }\n\n    function log(address p0, address p1, address p2) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(uint256 p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(string memory p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(bool p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, uint256 p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, string memory p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, bool p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, uint256 p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, string memory p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, bool p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, uint256 p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, string memory p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, bool p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n    }\n\n    function log(address p0, address p1, address p2, address p3) internal pure {\n        _sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n    }\n\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 2000,
      "details": {
        "yul": true
      }
    },
    "viaIR": true,
    "evmVersion": "paris",
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}